<!DOCTYPE html>
<!-- CACHE BUST: 2024-12-19 16:00:00 - TRANSFORMATION AGENT ROUTING FIX -->
<html>
<head>
    <meta charset="UTF-8">
    <title>RgentAI Assistant</title>
    <style>
      :root {
        /* Default light theme variables - will be overridden by JavaScript */
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-card: #ffffff;
        --text-primary: #2c3e50;
        --text-secondary: #6c757d;
        --border-color: #dee2e6;
        --input-bg: #ffffff;
        --code-bg: #f8f9fa;
        --rgent-primary: #ff6b35; /* Will be overridden by JavaScript for theme awareness */
        --rgent-accent: #3498db; /* Will be overridden by JavaScript for theme awareness */
      }
      
      body { 
        font-family: Arial, sans-serif; 
        margin: 20px; 
        background-color: var(--bg-primary);
        color: var(--text-primary);
        transition: all 0.3s ease;
      }
      
      /* Tab Navigation */
      .tab-navigation {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        justify-content: flex-end;
      }
      
      .tab-btn {
        padding: 8px 16px;
        background-color: var(--bg-card);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
      }
      
      .tab-btn.active {
        background-color: var(--text-primary);
        color: var(--bg-primary);
        border-color: var(--text-primary);
      }
      
      .tab-btn:hover {
        background-color: var(--text-secondary);
        color: var(--bg-primary);
        border-color: var(--text-secondary);
      }
      
      .tab-content {
        display: none;
      }
      
      .tab-content.active {
        display: block;
      }
      
      .chat-container { 
        height: 60vh; 
        min-height: 250px;
        max-height: 70vh;
        overflow-y: auto; 
        border: 1px solid var(--border-color); 
        border-radius: 8px; 
        padding: 15px; 
        margin-bottom: 15px; 
        background-color: var(--bg-card); 
        transition: all 0.3s ease;
      }
      .message { 
        margin-bottom: 10px; 
        padding: 8px 12px; 
        border-radius: 8px; 
        max-width: 80%; 
        word-wrap: break-word;
        overflow-wrap: break-word;
        white-space: normal;
        transition: all 0.3s ease;
      }
      .user-message { 
        background-color: var(--text-primary); 
        color: var(--bg-primary); 
        margin-left: auto; 
        margin-right: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .ai-message { 
        background-color: var(--bg-card); 
        color: var(--text-primary); 
        line-height: 1.5;
        word-wrap: break-word;
        word-break: normal;
        overflow-wrap: break-word;
        hyphens: none;
        white-space: normal;
        border: 1px solid var(--border-color);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .ai-message strong {
        font-weight: bold;
      }
      
      .ai-message em {
        font-style: italic;
      }
      
      .ai-message code {
        background-color: var(--code-bg);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 0.9em;
      }
      
      .debug-button {
        background-color: #dc3545 !important;
        color: white !important;
        border: none !important;
        padding: 8px 12px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
      }
      
      .analyze-button {
        background-color: #805ad5 !important;
        color: white !important;
        border: none !important;
        padding: 8px 12px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
      }
      
      .analyze-button:hover {
        background-color: #6b46c1 !important;
      }
      
      .access-button {
        background-color: #8e44ad !important;
        color: white !important;
        border: none !important;
        padding: 8px 16px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
      }
      
      .access-button:hover {
        background-color: #7d3c98 !important;
      }
      
      .send-button {
        background-color: #27ae60 !important;
        color: white !important;
        border: none !important;
        padding: 8px 16px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
      }
      
      .send-button:hover {
        background-color: #229954 !important;
      }
      
      .send-button.stop-mode {
        background-color: #e74c3c !important;
        animation: pulse-stop 2s infinite;
      }
      
      .send-button.stop-mode:hover {
        background-color: #c0392b !important;
      }
      
      /* Agent Auto Execute Toggle Styles */
      .auto-execute-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: 12px;
      }
      
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
      }
      
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      
      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 24px;
      }
      
      .toggle-slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
      }
      
      input:checked + .toggle-slider {
        background-color: #27ae60;
      }
      
      input:checked + .toggle-slider:before {
        transform: translateX(20px);
      }
      
      .toggle-label {
        font-size: 12px;
        color: var(--text-secondary);
        font-weight: 500;
        white-space: nowrap;
      }
      
      /* Execute Cleaning Button Styles */
      .execute-cleaning-button {
        background-color: #27ae60 !important;
        color: white !important;
        border: none !important;
        padding: 10px 20px !important;
        border-radius: 6px !important;
        cursor: pointer !important;
        font-size: 14px !important;
        font-weight: 600 !important;
        transition: all 0.3s ease !important;
        margin-top: 10px !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        display: inline-block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      .execute-cleaning-button:hover {
        background-color: #229954;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      }
      
      .execute-cleaning-button:active {
        background-color: #1e8449;
        transform: translateY(0);
      }
      
      @keyframes pulse-stop {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
      }
      
      /* Prevent breaking of common terms */
      .ai-message {
        word-break: normal !important;
        hyphens: none !important;
      }
      
      /* Specific protection for function names and data frame names */
      .ai-message div {
        word-break: normal !important;
        hyphens: none !important;
      }
      .code-block { 
        background-color: var(--code-bg); 
        border: 1px solid var(--border-color); 
        border-radius: 8px; 
        padding: 15px; 
        margin: 15px 0; 
        font-family: 'Courier New', monospace;
        white-space: pre;
        overflow-x: auto;
        overflow-y: hidden;
        color: var(--text-primary);
        position: relative;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        max-width: 100%;
      }
      
      .code-block-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--bg-secondary);
        margin: -15px -15px 10px -15px;
        padding: 8px 15px;
        border-radius: 8px 8px 0 0;
        color: var(--text-primary);
        font-size: 12px;
        font-weight: bold;
        width: 100%;
      }
      .code-block-actions {
        margin-left: auto;
        display: flex;
        gap: 8px;
        align-items: center;
      }
      
      .copy-button {
        background-color: #38a169;
        color: white;
        border: none;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        transition: background-color 0.2s;
      }
      
      .copy-button:hover {
        background-color: #2f855a;
      }
      
      .copy-button:active {
        background-color: #276749;
      }
      
      .copy-button.copied {
        background-color: #3182ce;
      }
      .insert-button { 
        background-color: #28a745; 
        color: white; 
        border: none; 
        padding: 5px 10px; 
        border-radius: 4px; 
        cursor: pointer; 
        margin: 5px; 
      }
      .insert-button:hover { 
        background-color: #218838; 
      }
      .input-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      
      .input-row {
        display: flex;
        gap: 10px;
      }
      
      .button-row {
        display: flex;
        gap: 10px;
      }
      
      .button-row button {
        flex: 1;
      }
      input[type="text"] { 
        flex: 1;
        padding: 8px; 
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--input-bg);
        color: var(--text-primary);
      }
      button { 
        padding: 8px 16px; 
        background-color: var(--rgent-primary); 
        color: white; 
        border: none; 
        border-radius: 4px; 
        cursor: pointer; 
        transition: all 0.3s ease;
      }
      button:hover {
        background-color: var(--rgent-accent);
      }

      
      /* Usage Tab Styles */
      .usage-container {
        background-color: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 15px;
        color: var(--text-primary);
      }
      
      .stats-section {
        margin-bottom: 30px;
      }
      
      .stats-section h4 {
        margin-bottom: 15px;
        color: var(--text-primary);
        font-size: 16px;
      }
      
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }
      
      /* Usage Breakdown Styles */
      .usage-breakdown {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 15px;
      }
      
      .usage-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: var(--bg-secondary);
        border-radius: 6px;
        border: 1px solid var(--border-color);
      }
      
      .feature-name {
        font-weight: 500;
        color: var(--text-primary);
      }
      
      .api-calls {
        font-size: 14px;
        color: var(--text-secondary);
        font-family: monospace;
      }
      
      /* Plan Type Box - Horizontal Prominent Display */
      .plan-type-box {
        background: var(--bg-card);
        border: 2px solid var(--rgent-accent);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        text-align: center;
        color: var(--text-primary);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .plan-type-header {
        margin-bottom: 10px;
      }
      
      .plan-type-header h3 {
        margin: 0 0 5px 0;
        font-size: 18px;
        font-weight: bold;
        color: var(--text-primary);
      }
      
      .plan-type-header small {
        color: var(--text-secondary);
        font-size: 12px;
      }
      
      .plan-type-display {
        font-size: 32px;
        font-weight: bold;
        color: var(--rgent-accent);
      }
      
      /* Subscription Info Box */
      .subscription-info-box {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        color: var(--text-primary);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .subscription-header {
        margin-bottom: 15px;
      }
      
      .subscription-header h3 {
        margin: 0 0 5px 0;
        font-size: 18px;
        font-weight: bold;
        color: var(--text-primary);
      }
      
      .subscription-header small {
        color: var(--text-secondary);
        font-size: 12px;
      }
      
      .subscription-details {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      
      .subscription-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid var(--border-color);
      }
      
      .subscription-item:last-child {
        border-bottom: none;
      }
      
      .subscription-label {
        font-weight: 500;
        color: var(--text-secondary);
        font-size: 14px;
      }
      
      .subscription-value {
        font-weight: 600;
        color: var(--text-primary);
        font-size: 14px;
        text-align: right;
      }
      
      /* Total Cost Box - Horizontal Prominent Display */
      .total-cost-box {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        text-align: center;
        color: var(--text-primary);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .total-cost-header {
        margin-bottom: 10px;
      }
      
      .total-cost-header h3 {
        margin: 0 0 5px 0;
        font-size: 18px;
        font-weight: bold;
        color: var(--text-primary);
      }
      
      .total-cost-header small {
        color: var(--text-secondary);
        font-size: 12px;
      }
      
      .total-cost-amount {
        font-size: 32px;
        font-weight: bold;
        color: var(--text-primary);
      }
      
      /* Input Output Container - Side by Side */
      .input-output-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }
      
      .stat-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .stat-card h4 {
        margin-bottom: 10px;
        color: var(--text-primary);
        font-size: 14px;
      }
      
      .stat-card div {
        font-size: 24px;
        font-weight: bold;
        color: var(--text-primary);
        margin-bottom: 5px;
      }
      
      .stat-card small {
        color: var(--text-secondary);
        font-size: 12px;
      }
      
      /* Progress Bar */
      .progress-fill {
        background: linear-gradient(90deg, var(--rgent-accent), var(--rgent-accent-dark));
        height: 20px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 12px;
        transition: width 0.3s ease;
      }
      
      #monthly-progress-bar, #free-progress-bar {
        background: var(--bg-secondary);
        border-radius: 10px;
        height: 20px;
        overflow: hidden;
        border: 1px solid var(--border-color);
      }
      
      .access-section {
        background-color: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 15px;
        text-align: center;
        color: var(--text-primary);
      }
      
      .form-group {
        margin-bottom: 15px;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 5px;
        color: var(--text-primary);
        font-weight: bold;
      }
      
      .form-group input {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--input-bg);
        color: var(--text-primary);
      }
      
      .access-help {
        margin-top: 10px;
        font-size: 12px;
        color: var(--text-secondary);
      }
      
      .access-help a {
        color: var(--rgent-accent);
        text-decoration: none;
      }
      
      .access-help a:hover {
        text-decoration: underline;
      }
      
      /* Guide Tab Styles */
      .guide-container {
        background-color: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 15px;
        color: var(--text-primary);
      }
      
      .guide-section {
        margin-bottom: 30px;
      }
      
      .guide-section h3 {
        margin-bottom: 15px;
        color: var(--text-primary);
        font-size: 18px;
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 8px;
      }
      
      .guide-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .guide-card h4 {
        margin-bottom: 10px;
        color: var(--text-primary);
        font-size: 16px;
        font-weight: bold;
      }
      
      .guide-card p {
        margin-bottom: 10px;
        line-height: 1.5;
        color: var(--text-secondary);
      }
      
      .guide-card ul {
        margin: 10px 0;
        padding-left: 20px;
      }
      
      .guide-card li {
        margin-bottom: 5px;
        line-height: 1.4;
        color: var(--text-secondary);
      }
      
      .guide-card code {
        background-color: var(--code-bg);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 0.9em;
        color: var(--text-primary);
      }
      
      /* Progress bar for free trial */
      #free-progress-bar {
        width: 100%;
        height: 20px;
        background-color: var(--bg-secondary);
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid var(--border-color);
      }
      
      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--rgent-primary), var(--rgent-accent));
        border-radius: 10px;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 12px;
        font-weight: bold;
      }
      
      /* Agents Tab Styles */
      .agents-container {
        padding: 20px;
        max-width: 600px;
        margin: 0 auto;
      }
      
      .agents-header {
        text-align: center;
        margin-bottom: 30px;
      }
      
      .agents-header h2 {
        color: var(--text-primary);
        margin-bottom: 10px;
      }
      
      .agents-header p {
        color: var(--text-secondary);
        font-size: 16px;
      }
      
      .agent-selection {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .agent-card {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        display: flex;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      
      .agent-card:hover:not(.disabled) {
        border-color: var(--rgent-primary);
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }
      
      .agent-card.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      .agent-icon {
        font-size: 32px;
        margin-right: 20px;
      }
      
      .agent-info {
        flex: 1;
      }
      
      .agent-info h3 {
        color: var(--text-primary);
        margin: 0 0 5px 0;
        font-size: 18px;
      }
      
      .agent-info p {
        color: var(--text-secondary);
        margin: 0;
        font-size: 14px;
      }
      
      .agent-arrow {
        font-size: 20px;
        color: var(--text-secondary);
        margin-left: 15px;
      }
      
      /* Transformation Tab Styles */
      .transformation-container {
        padding: 20px;
        max-width: 800px;
        margin: 0 auto;
      }
      
      .transformation-header {
        text-align: center;
        margin-bottom: 30px;
      }
      
      .transformation-header h2 {
        color: var(--text-primary);
        margin-bottom: 10px;
      }
      
      .transformation-header p {
        color: var(--text-secondary);
        font-size: 16px;
      }
      
      .transformation-config {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 25px;
      }
      
      .transformation-checklist {
        margin-top: 20px;
        padding: 20px;
        background-color: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        display: none; /* FIXED: Start hidden, will be shown when dataframe selected */
      }
      
      .statistical-checklist {
        margin-top: 20px;
        padding: 20px;
        background-color: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        display: none; /* Start hidden, will be shown when dataframe selected */
      }
      
      .variable-selection {
        background-color: var(--bg-primary);
        padding: 15px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        margin-top: 10px;
      }
      
      .variable-selection label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: var(--text-primary);
      }
      
      .variable-selection select {
        width: 100%;
        margin-bottom: 10px;
      }
      
      .test-guidance {
        margin-top: 8px;
        padding: 10px;
        background: linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 100%);
        border-left: 4px solid #4a90e2;
        border-radius: 6px;
        font-size: 12px;
        line-height: 1.4;
        color: #2c3e50;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .test-guidance .warning {
        color: #e67e22;
        font-weight: 600;
      }
      
      .transformation-checklist h4 {
        color: var(--text-primary);
        margin-bottom: 20px;
        font-size: 18px;
      }
      
      /* Agent Configuration Styles */
      .agent-config {
        animation: slideIn 0.3s ease;
      }
      
      .config-header {
        display: flex;
        align-items: center;
        margin-bottom: 25px;
        padding-bottom: 15px;
        border-bottom: 1px solid var(--border-color);
      }
      
      .back-btn {
        background: none;
        border: none;
        color: var(--rgent-primary);
        cursor: pointer;
        font-size: 14px;
        margin-right: 15px;
        padding: 5px 0;
      }
      
      .back-btn:hover {
        text-decoration: underline;
      }
      
      .config-header h3 {
        color: var(--text-primary);
        margin: 0;
        font-size: 20px;
      }
      
      .config-form {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      
      .form-group {
        display: flex;
        flex-direction: column;
      }
      
      .form-group label {
        color: var(--text-primary);
        font-weight: 600;
        margin-bottom: 8px;
        font-size: 14px;
      }
      
      .form-group select {
        padding: 10px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--input-bg);
        color: var(--text-primary);
        font-size: 14px;
      }
      
      .start-agent-btn {
        padding: 12px 20px;
        background: var(--rgent-primary);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 10px;
      }
      
      .start-agent-btn:hover:not(:disabled) {
        background: var(--rgent-accent);
      }
      
      .start-agent-btn:disabled {
        background: var(--text-secondary);
        cursor: not-allowed;
        opacity: 0.6;
      }
      
      /* Visualization Plot Configuration Styles */
      .plot-configs {
        margin-top: 15px;
        padding: 15px;
        background: var(--background-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }
      
      .plot-config-section {
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        background: var(--background-primary);
      }
      
      .plot-config-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      
      .plot-config-header h5 {
        margin: 0;
        color: var(--text-primary);
      }
      
      .plot-config-details {
        margin-top: 15px;
      }
      
      .remove-plot-btn {
        background: #ff4444;
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.3s ease;
      }
      
      .remove-plot-btn:hover {
        background: #cc0000;
      }
      
      .add-plot-section {
        margin-top: 15px;
        text-align: center;
      }
      
      .add-plot-btn {
        background: #2ed573;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: background-color 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      
      .add-plot-btn:hover {
        background: #26d065;
      }
      
      @keyframes slideIn {
        from { opacity: 0; transform: translateX(20px); }
        to { opacity: 1; transform: translateX(0); }
      }
      
      /* Cleaning Checklist Styles */
      .cleaning-checklist {
        margin-top: 20px;
        padding: 20px;
        background: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid rgba(var(--rgent-primary-rgb), 0.2);
      }
      
      .cleaning-checklist h4 {
        color: var(--text-primary);
        margin: 0 0 15px 0;
        font-size: 16px;
        font-weight: 600;
      }
      
      .checklist-group {
        margin-bottom: 15px;
      }
      
      .checkbox-item {
        display: flex;
        align-items: flex-start;
        cursor: pointer;
        padding: 12px;
        border-radius: 6px;
        transition: background-color 0.2s ease;
        position: relative;
      }
      
      .checkbox-item:hover {
        background: rgba(var(--rgent-primary-rgb), 0.05);
      }
      
      .checkbox-item input[type="checkbox"] {
        display: none;
      }
      
      .checkmark {
        width: 20px;
        height: 20px;
        border: 2px solid var(--border-color);
        border-radius: 4px;
        margin-right: 12px;
        flex-shrink: 0;
        position: relative;
        transition: all 0.2s ease;
        background: var(--bg-primary);
      }
      
      .checkbox-item input[type="checkbox"]:checked + .checkmark {
        background: var(--rgent-primary);
        border-color: var(--rgent-primary);
      }
      
      .checkbox-item input[type="checkbox"]:checked + .checkmark::after {
        content: '✓';
        position: absolute;
        left: 3px;
        top: -1px;
        color: white;
        font-size: 14px;
        font-weight: bold;
      }
      
      .checkbox-item.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      
      .checkbox-item.disabled .checkmark {
        background: var(--bg-tertiary);
        border-color: var(--border-color);
      }
      
      .checkbox-item.disabled input[type="checkbox"]:checked + .checkmark {
        background: var(--text-secondary);
        border-color: var(--text-secondary);
      }
      
      .checkbox-item.disabled input[type="checkbox"]:checked + .checkmark::after {
        content: '—';
        top: 1px;
        left: 4px;
      }
      
      .checkbox-item .checkbox-content {
        flex: 1;
      }
      
      .checkbox-item small {
        display: block;
        color: var(--text-secondary);
        font-size: 12px;
        margin-top: 2px;
        line-height: 1.3;
      }
      
      /* Variable Selection Styles */
      .variable-selection-subsection {
        margin-top: 15px;
        padding: 12px;
        background: rgba(var(--rgent-primary-rgb), 0.03);
        border-radius: 6px;
        border: 1px solid rgba(var(--rgent-primary-rgb), 0.08);
      }
      
      .variable-selection-subsection h6 {
        color: var(--text-primary);
        margin: 0 0 10px 0;
        font-size: 13px;
        font-weight: 600;
      }
      
      .variable-selection-controls {
        display: flex;
        gap: 8px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      
      .variable-selection-controls .btn-small {
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 4px;
        border: 1px solid rgba(var(--rgent-primary-rgb), 0.2);
        background: var(--background-primary);
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .variable-selection-controls .btn-small:hover {
        background: rgba(var(--rgent-primary-rgb), 0.1);
        border-color: rgba(var(--rgent-primary-rgb), 0.3);
      }
      
      .btn-small {
        padding: 6px 12px;
        font-size: 12px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .btn-small:hover {
        background: var(--rgent-primary);
        color: white;
        border-color: var(--rgent-primary);
      }
      
      .variable-selection-container {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        padding: 10px;
      }
      
      .variable-checkbox-item {
        display: flex;
        align-items: center;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      
      .variable-checkbox-item:hover {
        background: rgba(var(--rgent-primary-rgb), 0.05);
      }
      
      .variable-checkbox-item input[type="checkbox"] {
        margin-right: 8px;
        cursor: pointer;
      }
      
      .variable-info {
        flex: 1;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .variable-name {
        font-weight: 500;
        color: var(--text-primary);
      }
      
      .variable-type {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 3px;
        background: var(--bg-tertiary);
        color: var(--text-secondary);
      }
      
      .variable-type.numeric {
        background: rgba(34, 197, 94, 0.1);
        color: #16a34a;
      }
      
      .variable-type.categorical {
        background: rgba(59, 130, 246, 0.1);
        color: #2563eb;
      }
      
      .sub-options {
        margin-left: 32px;
        margin-top: 8px;
        padding: 10px;
        background: var(--bg-primary);
        border-radius: 4px;
        border: 1px solid var(--border-color);
      }
      
      .sub-options label {
        font-size: 12px;
        color: var(--text-secondary);
        margin-bottom: 5px;
        display: block;
      }
      
      .sub-select {
        width: 100%;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 12px;
      }
      
      .sub-textarea {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 12px;
        font-family: inherit;
        resize: vertical;
        min-height: 60px;
      }
      

      
      /* Modal Styles */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .modal-content {
        background: var(--bg-card);
        border-radius: 12px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        margin: 20px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      }
      
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 24px;
        border-bottom: 1px solid var(--border-color);
      }
      
      .modal-header h3 {
        color: var(--text-primary);
        margin: 0;
        font-size: 20px;
      }
      
      .modal-close {
        font-size: 24px;
        cursor: pointer;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }
      
      .modal-close:hover {
        color: var(--text-primary);
      }
      
      .modal-body {
        padding: 24px;
      }
      
      .config-section {
        margin-bottom: 24px;
      }
      
      .config-section label {
        display: block;
        color: var(--text-primary);
        font-weight: 600;
        margin-bottom: 8px;
      }
      
      .config-section select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--input-bg);
        color: var(--text-primary);
        font-size: 14px;
      }
      
      .dataframe-info {
        margin-top: 12px;
        padding: 12px;
        background: var(--bg-secondary);
        border-radius: 6px;
        font-size: 13px;
        color: var(--text-secondary);
      }
      
      .radio-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .radio-option {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        transition: background 0.3s ease;
      }
      
      .radio-option:hover {
        background: var(--bg-secondary);
      }
      
      .radio-option input[type="radio"] {
        margin: 0;
      }
      
      .workflow-steps {
        color: var(--text-secondary);
        padding-left: 20px;
      }
      
      .workflow-steps li {
        margin-bottom: 4px;
      }
      
      .modal-footer {
        padding: 20px 24px;
        border-top: 1px solid var(--border-color);
        background: var(--bg-secondary);
        border-radius: 0 0 12px 12px;
      }
      
      .modal-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }
      
      .btn-secondary {
        padding: 10px 20px;
        background: var(--bg-card);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
      }
      
      .btn-secondary:hover {
        background: var(--bg-secondary);
      }
      
      .btn-primary {
        padding: 10px 20px;
        background: var(--rgent-primary);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
      }
      
      .btn-primary:hover:not(:disabled) {
        background: var(--rgent-accent);
      }
      
      .btn-primary:disabled {
        background: var(--text-secondary);
        cursor: not-allowed;
        opacity: 0.6;
      }
      
    </style>
</head>
<body>
            <h3>Rgent - Your RStudio AI Assistant</h3>
    
    <!-- Access Code Section -->
    <div id="access-section" class="access-section">
      <div class="form-group">
        <label for="access-code">Access Code:</label>
        <div style="position: relative; display: flex; align-items: center;">
          <input type="password" id="access-code" placeholder="Enter your access code" style="flex: 1; margin-right: 10px;">
          <button type="button" id="toggleAccessCode" style="background: none; border: none; cursor: pointer; color: #925de8; font-size: 12px; padding: 8px 12px; font-weight: 500; text-decoration: underline; white-space: nowrap;">
            Show
          </button>
        </div>
      </div>
                <button onclick="validateAccess()" class="access-button">Validate Access</button>
      <div id="access-status"></div>
      <div class="access-help">
        <p>Forgot your access code? <a href="https://rgentai.com/signin.html" target="_blank">Click here</a></p>
      </div>
    </div>
    
    <!-- Main Interface with Tabs -->
    <div id="main-interface" style="display: none;">
      <!-- Tab Navigation -->
      <div class="tab-navigation">
        <button class="tab-btn active" onclick="switchTab('chat')">&#128172; Chat</button>
        <button class="tab-btn" onclick="switchTab('agents')" id="agents-tab-btn">🤖 Agents</button>

        <button class="tab-btn" onclick="switchTab('usage')">&#128202; Usage</button>
        <button class="tab-btn" onclick="switchTab('guide')">📖 Guide</button>
        <button class="tab-btn" onclick="newConversation()" id="new-conversation-button" disabled>🔄 New Chat</button>
      </div>
      
      <!-- Chat Tab -->
      <div id="chat-tab" class="tab-content active">
        <div id="chat-container" class="chat-container">
          <div class="message ai-message">Connecting to RStudio...</div>
        </div>
        <div class="input-container">
          <div class="input-row">
            <input type="text" id="user-input" placeholder="Type your question here..." disabled>
            <button onclick="sendMessage()" id="send-button" disabled class="send-button">Send</button>
            <div class="auto-execute-toggle">
              <label class="toggle-switch">
                <input type="checkbox" id="auto-execute-toggle" checked>
                <span class="toggle-slider"></span>
              </label>
              <span class="toggle-label">Auto Execute</span>
            </div>
          </div>
          <div class="button-row">
            <button onclick="debugLastError()" id="debug-error-button" disabled class="debug-button">&#128027; Debug Last Error</button>
            <button onclick="analyzeLastPlot()" id="analyze-plot-button" disabled class="analyze-button">📊 Analyze Last Plot</button>
          </div>
        </div>

      </div>
      
      <!-- Usage Tab -->
      <div id="usage-tab" class="tab-content">
        <div class="usage-container">
          <div class="section">
            <h3>📊 Usage Statistics</h3>
            
            <!-- Overall Stats -->
            <div class="stats-section" id="paid-usage-section">
              
              <!-- Plan Type Display -->
              <div class="plan-type-box">
                <div class="plan-type-header">
                  <h3>Current Plan</h3>
                  <small>Your subscription</small>
                </div>
                <div class="plan-type-display" id="plan-type-display">-</div>
              </div>
              
              <!-- Subscription Info -->
              <div class="subscription-info-box">
                <div class="subscription-header">
                  <h3>Subscription Details</h3>
                  <small>Billing information</small>
                </div>
                <div class="subscription-details">
                  <div class="subscription-item">
                    <span class="subscription-label">Status:</span>
                    <span class="subscription-value" id="subscription-status">-</span>
                </div>
                  <div class="subscription-item">
                    <span class="subscription-label">Next Billing:</span>
                    <span class="subscription-value" id="subscription-end-date">-</span>
                  </div>

              </div>
            </div>

            </div>



            <!-- Monthly Usage -->
            <div class="stats-section" id="monthly-usage-section">
              <h4>Monthly Usage</h4>
              
              <!-- Monthly Requests -->
              <div class="stat-card">
                <h4>Monthly Requests</h4>
                <div id="monthly-requests">-</div>
                <small id="monthly-requests-limit">-</small>
              </div>
              
              <!-- Requests Remaining -->
                <div class="stat-card">
                <h4>Requests Remaining</h4>
                <div id="requests-remaining">-</div>
                <small>This month</small>
                </div>
              
              <!-- Progress Bar -->
                <div class="stat-card">
                <h4>Progress</h4>
                <div id="monthly-progress-bar">
                  <div class="progress-fill" id="monthly-progress-fill"></div>
                </div>
                <small>Monthly usage progress</small>
              </div>
            </div>

            <!-- Free Trial Stats -->
            <div class="stats-section" id="free-trial-section" style="display: none;">
              <h4>🎁 Free Trial Usage</h4>
              <div class="stats">
                <div class="stat-card">
                  <h4>Requests Used</h4>
                  <div id="free-requests-used">-</div>
                  <small>Out of 25 free requests</small>
                </div>
                <div class="stat-card">
                  <h4>Requests Remaining</h4>
                  <div id="free-requests-remaining">-</div>
                  <small>Free trial requests left</small>
                </div>
                <div class="stat-card">
                  <h4>Progress</h4>
                  <div id="free-progress-bar">
                    <div class="progress-fill" id="free-progress-fill"></div>
                  </div>
                  <small>Free trial progress</small>
                </div>
              </div>
            </div>

            <div id="usage-status" class="status" style="display: none;"></div>
            
            <!-- API Usage Info -->
            <div class="stats-section">
              <h4>💡 Requests per Feature</h4>
              <div class="usage-breakdown">
                <div class="usage-item">
                  <span class="feature-name">💬 Basic Chat</span>
                  <span class="api-calls">1 request per message</span>
          </div>
                <div class="usage-item">
                  <span class="feature-name">📊 Analyze Last Plot</span>
                  <span class="api-calls">1 request when used</span>
                </div>
                <div class="usage-item">
                  <span class="feature-name">🐛 Debug Last Error</span>
                  <span class="api-calls">1 request when used</span>
                </div>
                <div class="usage-item">
                  <span class="feature-name">🤖 Agent Workflows</span>
                  <span class="api-calls">2-5 requests per workflow</span>
                </div>
              </div>
              <small style="color: var(--text-secondary); font-style: italic;">
                Agents use: 1 analysis request + 1 code generation request + up to 3 error fix requests if needed
              </small>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Agents Tab -->
      <div id="agents-tab" class="tab-content">
        <div class="agents-container">
          <div class="agents-header">
            <div class="header-with-back" style="display: flex; justify-content: space-between; align-items: center;">
              <h2 id="agents-main-header">🤖 AI Agents</h2>
              <button id="back-to-agents-btn" class="back-btn" onclick="showAgentSelection()" style="display: none;">← Back to Agents</button>
            </div>
            <p id="agent-selection-prompt">Select an agent to get started</p>
          </div>
          
          <!-- Agent Selection View -->
          <div id="agent-selection" class="agent-selection">
            <div class="agent-card" onclick="selectAgent('cleaning')">
              <div class="agent-icon">🧹</div>
              <div class="agent-info">
                <h3>Data Cleaning Agent</h3>
                <p>Clean datasets: handle missing values, fix types, remove outliers</p>
              </div>
              <div class="agent-arrow">→</div>
            </div>
            
            <div class="agent-card" onclick="selectAgent('transformation')">
              <div class="agent-icon">🔄</div>
              <div class="agent-info">
                <h3>Data Transformation Agent</h3>
                <p>Transform data: create variables, apply functions, reshape structure</p>
              </div>
              <div class="agent-arrow">→</div>
            </div>
            
            <div class="agent-card" onclick="selectAgent('visualization')">
              <div class="agent-icon">🎨</div>
              <div class="agent-info">
                <h3>Visualization Agent</h3>
                <p>Create intelligent plots and visualizations with automatic analysis</p>
              </div>
              <div class="agent-arrow">→</div>
            </div>
            
            <div class="agent-card" onclick="selectAgent('modeling')">
              <div class="agent-icon">🤖</div>
              <div class="agent-info">
                <h3>Modeling Agent</h3>
                <p>Build ML models with interpretability and AI-powered insights</p>
              </div>
              <div class="agent-arrow">→</div>
            </div>
            
            <div class="agent-card" onclick="selectAgent('statistical')">
              <div class="agent-icon">📊</div>
              <div class="agent-info">
                <h3>Statistical Analysis Agent</h3>
                <p>Perform hypothesis tests, analyze distributions, and calculate effect sizes</p>
              </div>
              <div class="agent-arrow">→</div>
            </div>
          </div>
          
          <!-- Cleaning Agent Configuration -->
          <div id="cleaning-config" class="agent-config" style="display: none;">

            
            <div class="config-form">
              <div class="form-group">
                <label for="dataframe-select-main">📊 Select DataFrame</label>
                <select id="dataframe-select-main">
                  <option value="">-- Choose a DataFrame --</option>
                </select>
                <div id="dataframe-info-main" class="dataframe-info" style="display: none;"></div>
              </div>
              
              <div id="cleaning-checklist" class="cleaning-checklist" style="display: none;">
                <h4>🧹 Select Cleaning Operations</h4>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-data-types" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      📊 Data Type Check & Conversion
                      <small>Identify and fix data type issues</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="data-type-options" style="display: none;">
                    <label for="data-type-method-select">Conversion method:</label>
                    <select id="data-type-method-select" class="sub-select">
                      <option value="automatic" selected>Automatic detection</option>
                      <option value="other">Other (specify below)</option>
                    </select>
                    <div id="data-type-other-input" style="display: none; margin-top: 8px;">
                      <label for="data-type-custom-input">Custom method:</label>
                      <textarea id="data-type-custom-input" class="sub-textarea" 
                                placeholder="e.g., 'Force all text to factor', 'Convert dates to POSIXct', 'Handle mixed types'"
                                rows="2"></textarea>
                    </div>
                    
                    <!-- Variable Selection for Data Types -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('data-types')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('data-types')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('data-types')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('data-types')">None</button>
                      </div>
                      <div id="data-types-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group" id="missing-values-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-missing-values" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      ⚠️ Missing Values Analysis
                      <small>Detect % missing per column</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="missing-handling-options" style="display: none;">
                    <label for="na-handling-select">Handle missing values:</label>
                    <select id="na-handling-select" class="sub-select">
                      <option value="median" selected>Replace with median (numeric)</option>
                      <option value="mean">Replace with mean (numeric)</option>
                      <option value="mode">Replace with mode (text)</option>
                      <option value="remove">Remove rows with missing values</option>
                      <option value="dont">Just analyze, don't fix</option>
                      <option value="other">Other (specify below)</option>
                    </select>
                    <div id="missing-values-other-input" style="display: none; margin-top: 8px;">
                      <label for="missing-values-custom-input">Custom method:</label>
                      <textarea id="missing-values-custom-input" class="sub-textarea" 
                                placeholder="e.g., 'KNN imputation', 'Forward fill', 'Interpolation', 'Multiple imputation'"
                                rows="2"></textarea>
                    </div>
                    
                    <!-- Variable Selection for Missing Values -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('missing-values')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('missing-values')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('missing-values')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('missing-values')">None</button>
                      </div>
                      <div id="missing-values-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-duplicates" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      🔄 Duplicate Detection
                      <small>Count and identify duplicate rows</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="duplicates-options" style="display: none;">
                    <!-- Variable Selection for Duplicates -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('duplicates')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('duplicates')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('duplicates')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('duplicates')">None</button>
                      </div>
                      <div id="duplicates-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-outliers" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      📈 Outlier Analysis
                      <small>Detect outliers using selected method</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="outlier-method-options" style="display: none;">
                    <label for="outlier-method-select">Detection method:</label>
                    <select id="outlier-method-select" class="sub-select">
                      <option value="iqr" selected>IQR (1.5x multiplier)</option>
                      <option value="zscore">Z-Score (3σ threshold)</option>
                      <option value="modified_zscore">Modified Z-Score (3.5 MAD)</option>
                      <option value="other">Other (specify below)</option>
                    </select>
                    <div id="outlier-other-input" style="display: none; margin-top: 8px;">
                      <label for="outlier-custom-input">Custom method:</label>
                      <textarea id="outlier-custom-input" class="sub-textarea" 
                                placeholder="e.g., 'Custom threshold', 'Percentile-based', 'Domain-specific rules'"
                                rows="2"></textarea>
                    </div>
                    
                    <!-- Variable Selection for Outliers -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('outliers')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('outliers')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('outliers')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('outliers')">None</button>
                      </div>
                      <div id="outliers-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-column-names" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      🏷️ Standardize Column Names
                      <small>Convert to selected naming convention</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="column-naming-options" style="display: none;">
                    <label for="column-naming-select">Naming convention:</label>
                    <select id="column-naming-select" class="sub-select">
                      <option value="snake_case" selected>snake_case (default)</option>
                      <option value="camelCase">camelCase</option>
                      <option value="PascalCase">PascalCase</option>
                      <option value="lowercase">lowercase</option>
                      <option value="UPPERCASE">UPPERCASE</option>
                      <option value="other">Other (specify below)</option>
                    </select>
                    <div id="column-naming-other-input" style="display: none; margin-top: 8px;">
                      <label for="column-naming-custom-input">Custom convention:</label>
                      <textarea id="column-naming-custom-input" class="sub-textarea" 
                                placeholder="e.g., 'Use dots instead of underscores', 'Keep original case', 'Custom separator'"
                                rows="2"></textarea>
                    </div>
                    
                    <!-- Variable Selection for Column Names -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('column-names')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('column-names')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('column-names')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('column-names')">None</button>
                      </div>
                      <div id="column-names-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-other">
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      🔧 Other Custom Operations
                      <small>Specify your own cleaning needs</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="other-options" style="display: none;">
                    <label for="other-operations-input">Describe what you want:</label>
                    <textarea id="other-operations-input" class="sub-textarea" 
                              placeholder="e.g., 'Convert all text to lowercase', 'Remove rows where age < 0', 'Create new column from existing ones'"
                              rows="3"></textarea>
                  </div>
                </div>
              </div>
              
              <button class="start-agent-btn" id="start-agent-btn" onclick="startCleaningAgentSimple()" disabled>
                Select a DataFrame
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Transformation Agent Configuration -->
      <div id="transformation-config" class="agent-config" style="display: none;">

        
        <div class="config-form">
          <div class="form-group">
            <label for="transformation-dataframe-select">📊 Select DataFrame</label>
            <select id="transformation-dataframe-select" onchange="updateTransformationDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
            <div id="transformation-dataframe-info" class="dataframe-info" style="display: none;"></div>
          </div>
          
          <div id="transformation-checklist" class="transformation-checklist" style="display: none;">
            <h4>🔄 Select Transformation Operations</h4>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-distribution-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📊 Distribution Analysis
                  <small>Analyze variable distributions and identify transformation needs</small>
                </div>
              </label>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-mathematical-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🧮 Mathematical Transformations
                  <small>Apply log, sqrt, power transformations to skewed variables</small>
                </div>
              </label>
              <div class="sub-options" id="math-transformations-options" style="display: none;">
                <label for="math-transformations-select">Transformation type:</label>
                <select id="math-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic (based on skewness)</option>
                  <option value="log">Log transformation</option>
                  <option value="sqrt">Square root</option>
                  <option value="power">Power transformation</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="math-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="math-transformations-custom-input">Custom transformation:</label>
                  <textarea id="math-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'x^2', '1/x', 'exp(x)'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Mathematical Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('math-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('math-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('math-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('math-transformations')">None</button>
                  </div>
                  <div id="math-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-new-variables">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  ➕ New Variables
                  <small>Create new variables from combinations of existing ones</small>
                </div>
              </label>
              <div class="sub-options" id="new-variables-options" style="display: none;">
                <label for="new-variables-select">Variable creation type:</label>
                <select id="new-variables-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="arithmetic">Arithmetic combinations</option>
                  <option value="ratio">Ratio variables</option>
                  <option value="interaction">Interaction terms</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="new-variables-other-input" style="display: none; margin-top: 8px;">
                  <label for="new-variables-custom-input">Custom variable creation:</label>
                  <textarea id="new-variables-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'age_group = cut(age, breaks=c(0,25,50,75,100))', 'bmi = weight/height^2'"
                            rows="3"></textarea>
                </div>
                
                <!-- Variable Selection for New Variables -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('new-variables')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('new-variables')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('new-variables')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('new-variables')">None</button>
                  </div>
                  <div id="new-variables-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-categorical-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🏷️ Categorical Transformations
                  <small>Recode categories, combine levels, create dummy variables</small>
                </div>
              </label>
              <div class="sub-options" id="categorical-transformations-options" style="display: none;">
                <label for="categorical-transformations-select">Transformation type:</label>
                <select id="categorical-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="recode">Recode categories</option>
                  <option value="combine">Combine small categories</option>
                  <option value="dummy">Create dummy variables</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="categorical-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="categorical-transformations-custom-input">Custom categorical transformation:</label>
                  <textarea id="categorical-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Combine categories A,B,C into "Group1"', 'Recode 1,2,3 to "Low","Medium","High"'"
                            rows="3"></textarea>
                </div>
                
                <!-- Variable Selection for Categorical Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('categorical-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('categorical-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('categorical-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('categorical-transformations')">None</button>
                  </div>
                  <div id="categorical-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-datetime-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📅 Date/Time Transformations
                  <small>Extract components, create time variables, handle periods</small>
                </div>
              </label>
              <div class="sub-options" id="datetime-transformations-options" style="display: none;">
                <label for="datetime-transformations-select">Transformation type:</label>
                <select id="datetime-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="components">Extract components (year, month, day)</option>
                  <option value="periods">Create time periods</option>
                  <option value="differences">Calculate time differences</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="datetime-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="datetime-transformations-custom-input">Custom datetime transformation:</label>
                  <textarea id="datetime-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Create quarter variable', 'Extract hour from timestamp'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Date/Time Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('datetime-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('datetime-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('datetime-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('datetime-transformations')">None</button>
                  </div>
                  <div id="datetime-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-merging-combining">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🔗 Merging & Combining
                  <small>Merge variables, reshape data structure, combine columns</small>
                </div>
              </label>
              <div class="sub-options" id="merging-combining-options" style="display: none;">
                <label for="merging-combining-select">Operation type:</label>
                <select id="merging-combining-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="combine">Combine text columns</option>
                  <option value="split">Split text columns</option>
                  <option value="reshape">Reshape data (wide/long)</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="merging-combining-other-input" style="display: none; margin-top: 8px;">
                  <label for="merging-combining-custom-input">Custom merging operation:</label>
                  <textarea id="merging-combining-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Combine first_name and last_name into full_name', 'Split address into street, city, zip'"
                            rows="3"></textarea>
                </div>
                
                <!-- Variable Selection for Merging & Combining -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('merging-combining')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('merging-combining')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('merging-combining')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('merging-combining')">None</button>
                  </div>
                  <div id="merging-combining-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-aggregation-grouping">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📊 Aggregation & Grouping
                  <small>Create group summaries, rolling statistics, cumulative measures</small>
                </div>
              </label>
              <div class="sub-options" id="aggregation-grouping-options" style="display: none;">
                <label for="aggregation-grouping-select">Aggregation type:</label>
                <select id="aggregation-grouping-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="summary">Group summaries</option>
                  <option value="rolling">Rolling statistics</option>
                  <option value="cumulative">Cumulative measures</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="aggregation-grouping-other-input" style="display: none; margin-top: 8px;">
                  <label for="aggregation-grouping-custom-input">Custom aggregation:</label>
                  <textarea id="aggregation-grouping-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Calculate mean by department', 'Create 7-day rolling average'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Aggregation & Grouping -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('aggregation-grouping')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('aggregation-grouping')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('aggregation-grouping')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('aggregation-grouping')">None</button>
                  </div>
                  <div id="aggregation-grouping-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-statistical-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📈 Statistical Transformations
                  <small>Z-scores, normalization, ranking, scaling</small>
                </div>
              </label>
              <div class="sub-options" id="statistical-transformations-options" style="display: none;">
                <label for="statistical-transformations-select">Transformation type:</label>
                <select id="statistical-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="zscore">Z-score standardization</option>
                  <option value="minmax">Min-max normalization</option>
                  <option value="robust">Robust scaling</option>
                  <option value="rank">Rank transformation</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="statistical-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="statistical-transformations-custom-input">Custom statistical transformation:</label>
                  <textarea id="statistical-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Apply Box-Cox transformation', 'Use robust scaling with MAD'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Statistical Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('statistical-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('statistical-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('statistical-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('statistical-transformations')">None</button>
                  </div>
                  <div id="statistical-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-text-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📝 Text Transformations
                  <small>Case changes, pattern replacement, text extraction</small>
                </div>
              </label>
              <div class="sub-options" id="text-transformations-options" style="display: none;">
                <label for="text-transformations-select">Transformation type:</label>
                <select id="text-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="case">Case changes</option>
                  <option value="pattern">Pattern replacement</option>
                  <option value="extraction">Text extraction</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="text-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="text-transformations-custom-input">Custom text transformation:</label>
                  <textarea id="text-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Remove special characters', 'Extract first word', 'Replace "NA" with empty string'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Text Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('text-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('text-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('text-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('text-transformations')">None</button>
                  </div>
                  <div id="text-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-spatial-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🗺️ Spatial Transformations
                  <small>Coordinate systems, distance calculations, spatial joins</small>
                </div>
              </label>
              <div class="sub-options" id="spatial-transformations-options" style="display: none;">
                <label for="spatial-transformations-select">Transformation type:</label>
                <select id="spatial-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="coordinates">Coordinate transformations</option>
                  <option value="distance">Distance calculations</option>
                  <option value="spatial">Spatial operations</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="spatial-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="spatial-transformations-custom-input">Custom spatial transformation:</label>
                  <textarea id="spatial-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Convert WGS84 to UTM', 'Calculate distance to nearest point'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Spatial Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('spatial-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('spatial-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('spatial-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('spatial-transformations')">None</button>
                  </div>
                  <div id="spatial-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-custom-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  ⚙️ Custom Transformations
                  <small>Specify your own transformation logic</small>
                </div>
              </label>
              <div class="sub-options" id="custom-transformations-options" style="display: none;">
                <label for="custom-transformations-custom-input">Custom transformation code:</label>
                <textarea id="custom-transformations-custom-input" class="sub-textarea" 
                          placeholder="e.g., 'Create age groups: ifelse(age < 30, "Young", ifelse(age < 60, "Middle", "Senior"))', 'Calculate compound growth rate: (final/initial)^(1/years) - 1'"
                          rows="4"></textarea>
                
                <!-- Variable Selection for Custom Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('custom-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('custom-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('custom-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('custom-transformations')">None</button>
                  </div>
                  <div id="custom-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <button class="start-agent-btn" id="start-transformation-btn" onclick="startTransformationAgent()" disabled>
              🚀 Start Transformation Agent
            </button>
          </div>
        </div>
      </div>
      
      <!-- Statistical Agent Configuration -->
      <div id="statistical-config" class="agent-config" style="display: none;">

        
        <div class="config-form">
          <div class="form-group">
            <label for="statistical-dataframe-select">📊 Select DataFrame</label>
            <select id="statistical-dataframe-select" onchange="updateStatisticalDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
            <div id="statistical-dataframe-info" class="dataframe-info" style="display: none;"></div>
          </div>
          
          <div id="statistical-checklist" class="statistical-checklist" style="display: none;">
            <h4>📊 Select Statistical Analysis Types</h4>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-basic-statistics">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📈 Basic Statistics & Distributions
                  <small>Summary statistics, normality tests, outlier detection</small>
                </div>
              </label>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-group-comparisons">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🆚 Group Comparisons
                  <small>T-tests, Z-tests, ANOVA, non-parametric alternatives</small>
                </div>
              </label>
              <div class="sub-options" id="group-comparisons-options" style="display: none;">
                <label for="group-comparisons-select">Test type:</label>
                <select id="group-comparisons-select" class="sub-select" onchange="updateGroupComparisonGuidance()">
                  <option value="automatic" selected>Automatic (based on data assumptions)</option>
                  <option value="independent_ttest">Independent t-test (2 groups, parametric)</option>
                  <option value="welch_ttest">Welch's t-test (2 groups, unequal variance)</option>
                  <option value="paired_ttest">Paired t-test (before/after, parametric)</option>
                  <option value="one_way_anova">One-way ANOVA (3+ groups, parametric)</option>
                  <option value="mann_whitney">Mann-Whitney U (2 groups, non-parametric)</option>
                  <option value="kruskal_wallis">Kruskal-Wallis (3+ groups, non-parametric)</option>
                  <option value="wilcoxon_signed">Wilcoxon signed-rank (paired, non-parametric)</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="group-comparison-guidance" class="test-guidance" style="margin-top: 8px; padding: 8px; background: #f0f8ff; border-radius: 4px; font-size: 12px; color: #666; display: none;">
                  💡 <span id="guidance-text">Select variables to see test recommendations</span>
                </div>
                <textarea id="group-comparisons-custom-input" class="sub-textarea" 
                          placeholder="Specify custom group comparison test..." 
                          rows="2" style="display: none;"></textarea>
                <div class="variable-selection" style="margin-top: 15px;">
                  <label for="statistical-continuous-var">📊 Continuous Variable:</label>
                  <select id="statistical-continuous-var" class="sub-select" onchange="updateGroupComparisonGuidance()">
                    <option value="">-- Select Variable --</option>
                  </select>
                  
                  <label for="statistical-grouping-var" style="margin-top: 10px;">🏷️ Grouping Variable:</label>
                  <select id="statistical-grouping-var" class="sub-select" onchange="updateGroupComparisonGuidance()">
                    <option value="">-- Select Variable --</option>
                  </select>
                </div>
              </div>
            </div>
            

            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-categorical-tests">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📊 Categorical Data Tests
                  <small>Chi-squared, Fisher's exact, McNemar's test</small>
                </div>
              </label>
              <div class="sub-options" id="categorical-tests-options" style="display: none;">
                <label for="categorical-tests-select">Test type:</label>
                <select id="categorical-tests-select" class="sub-select">
                  <option value="automatic" selected>Automatic (based on data)</option>
                  <option value="chi_squared_goodness">Chi-squared Goodness-of-Fit</option>
                  <option value="chi_squared_independence">Chi-squared Test of Independence</option>
                  <option value="fishers_exact">Fisher's Exact Test</option>
                  <option value="mcnemar">McNemar's Test</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="categorical-tests-custom-input" class="sub-textarea" 
                          placeholder="Specify custom categorical test..." 
                          rows="2" style="display: none;"></textarea>
                <div class="variable-selection" style="margin-top: 15px;">
                  <label for="categorical-var1">📊 Categorical Variable 1:</label>
                  <select id="categorical-var1" class="sub-select">
                    <option value="">-- Select Variable --</option>
                  </select>
                  
                  <label for="categorical-var2" style="margin-top: 10px;">📊 Categorical Variable 2:</label>
                  <select id="categorical-var2" class="sub-select">
                    <option value="">-- Select Variable --</option>
                  </select>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-before-after-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📈 Before/After Analysis
                  <small>Paired t-tests, repeated measures ANOVA</small>
                </div>
              </label>
              <div class="sub-options" id="before-after-options" style="display: none;">
                <label for="before-after-select">Analysis type:</label>
                <select id="before-after-select" class="sub-select">
                  <option value="automatic" selected>Automatic (based on data)</option>
                  <option value="paired_ttest">Paired t-test</option>
                  <option value="repeated_anova">Repeated measures ANOVA</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="before-after-custom-input" class="sub-textarea" 
                          placeholder="Specify custom before/after analysis..." 
                          rows="2" style="display: none;"></textarea>
                <div class="variable-selection" style="margin-top: 15px;">
                  <label for="statistical-before-var">📊 Before Variable:</label>
                  <select id="statistical-before-var" class="sub-select">
                    <option value="">-- Select Variable --</option>
                  </select>
                  
                  <label for="statistical-after-var" style="margin-top: 10px;">📊 After Variable:</label>
                  <select id="statistical-after-var" class="sub-select">
                    <option value="">-- Select Variable --</option>
                  </select>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-effect-size-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📏 Effect Size Analysis
                  <small>Cohen's d, eta-squared, odds ratios, confidence intervals</small>
                </div>
              </label>
              <div class="sub-options" id="effect-size-options" style="display: none;">
                <label for="effect-size-select">Effect size type:</label>
                <select id="effect-size-select" class="sub-select">
                  <option value="automatic" selected>Automatic (based on test type)</option>
                  <option value="cohens_d">Cohen's d (mean differences)</option>
                  <option value="eta_squared">Eta-squared (ANOVA)</option>
                  <option value="odds_ratio">Odds ratios (categorical)</option>
                  <option value="confidence_intervals">Confidence intervals</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="effect-size-custom-input" class="sub-textarea" 
                          placeholder="Specify custom effect size calculation..." 
                          rows="2" style="display: none;"></textarea>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-power-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  ⚡ Power Analysis
                  <small>Sample size calculations, effect size estimation</small>
                </div>
              </label>
              <div class="sub-options" id="power-analysis-options" style="display: none;">
                <label for="power-analysis-select">Power level:</label>
                <select id="power-analysis-select" class="sub-select">
                  <option value="0.8" selected>80% (Standard)</option>
                  <option value="0.9">90% (High)</option>
                  <option value="0.95">95% (Very High)</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="power-analysis-custom-input" class="sub-textarea" 
                          placeholder="Specify custom power level (e.g., 0.85, 0.99)..." 
                          rows="2" style="display: none;"></textarea>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-multiple-testing-correction">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🔄 Multiple Testing Correction
                  <small>Bonferroni, FDR, Holm's method</small>
                </div>
              </label>
              <div class="sub-options" id="multiple-testing-options" style="display: none;">
                <label for="multiple-testing-select">Correction method:</label>
                <select id="multiple-testing-select" class="sub-select">
                  <option value="bonferroni" selected>Bonferroni (Conservative)</option>
                  <option value="fdr">False Discovery Rate (Less Conservative)</option>
                  <option value="holm">Holm's Method (Step-down)</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="multiple-testing-custom-input" class="sub-textarea" 
                          placeholder="Specify custom multiple testing correction method..." 
                          rows="2" style="display: none;"></textarea>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-custom-statistical-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🔬 Custom Statistical Analysis
                  <small>Specify your own statistical analysis requirements</small>
                </div>
              </label>
              <div class="sub-options" id="custom-statistical-analysis-options" style="display: none;">
                <label for="custom-statistical-analysis-input">Custom analysis description:</label>
                <textarea id="custom-statistical-analysis-input" class="sub-textarea" 
                          placeholder="e.g., 'Perform Bayesian analysis with MCMC', 'Run multilevel mixed-effects model', 'Custom survival analysis with time-varying covariates'"
                          rows="4"></textarea>
              </div>
            </div>
            
            <button class="start-agent-btn" id="start-statistical-btn" onclick="startStatisticalAgent()" disabled>
              🚀 Start Statistical Analysis Agent
            </button>
          </div>
        </div>
      </div>
      
      <!-- Modeling Agent Configuration -->
      <div id="modeling-config" class="agent-config" style="display: none;">

        
        <div class="config-content">
          <div class="config-section">
            <label for="modeling-dataframe-select">📊 Select DataFrame</label>
            <select id="modeling-dataframe-select" onchange="updateModelingDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
          </div>
          

          
          <div class="config-section" id="target-variable-section" style="display: none;">
            <label for="modeling-target-variable">🎯 Target Variable</label>
            <select id="modeling-target-variable" onchange="updateAlgorithmOptions()">
              <option value="">-- Select Target Variable --</option>
            </select>
          </div>
          
          <div id="modeling-checklist" class="modeling-checklist" style="display: none;">
            <h4>🤖 Select Machine Learning Algorithms</h4>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-dimensionality-reduction">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📉 Dimensionality Reduction
                  <small>PCA, t-SNE, UMAP for feature reduction</small>
                </div>
              </label>
              <div class="sub-options" id="dimensionality-reduction-options" style="display: none;">
                <label for="dimensionality-reduction-select">Method:</label>
                <select id="dimensionality-reduction-select" class="sub-select">
                  <option value="automatic" selected>Automatic (best method)</option>
                  <option value="pca">Principal Component Analysis (PCA)</option>
                  <option value="tsne">t-SNE (t-Distributed Stochastic Neighbor Embedding)</option>
                  <option value="umap">UMAP (Uniform Manifold Approximation and Projection)</option>
                </select>
                
                <!-- Variable Selection for Dimensionality Reduction -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('dimensionality-reduction')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('dimensionality-reduction')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('dimensionality-reduction')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('dimensionality-reduction')">None</button>
                  </div>
                  <div id="dimensionality-reduction-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group" id="linear-regression-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-linear-regression">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  📈 Linear Regression
                  <small>Linear regression with interpretability</small>
                </div>
              </label>
              <div class="sub-options" id="linear-regression-options" style="display: none;">
                <!-- Variable Selection for Linear Regression -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('linear-regression')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('linear-regression')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('linear-regression')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('linear-regression')">None</button>
                  </div>
                  <div id="linear-regression-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group" id="logistic-regression-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-logistic-regression">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🔗 Logistic Regression
                  <small>Binary classification with interpretability</small>
                </div>
              </label>
              <div class="sub-options" id="logistic-regression-options" style="display: none;">
                <!-- Variable Selection for Logistic Regression -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('logistic-regression')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('logistic-regression')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('logistic-regression')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('logistic-regression')">None</button>
                  </div>
                  <div id="logistic-regression-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group" id="multinomial-regression-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-multinomial-regression">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🔗 Multinomial Regression
                  <small>Multi-class classification with interpretability</small>
                </div>
              </label>
              <div class="sub-options" id="multinomial-regression-options" style="display: none;">
                <!-- Variable Selection for Multinomial Regression -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('multinomial-regression')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('multinomial-regression')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('multinomial-regression')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('multinomial-regression')">None</button>
                  </div>
                  <div id="multinomial-regression-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-random-forest">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🌲 Random Forest
                  <small>Ensemble method with feature importance</small>
                </div>
              </label>
              <div class="sub-options" id="random-forest-options" style="display: none;">
                <!-- Variable Selection for Random Forest -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('random-forest')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('random-forest')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('random-forest')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('random-forest')">None</button>
                  </div>
                  <div id="random-forest-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-xgboost">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🚀 XGBoost
                  <small>Gradient boosting with interpretability</small>
                </div>
              </label>
              <div class="sub-options" id="xgboost-options" style="display: none;">
                <!-- Variable Selection for XGBoost -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('xgboost')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('xgboost')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('xgboost')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('xgboost')">None</button>
                  </div>
                  <div id="xgboost-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-feature-engineering">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  ⚙️ Feature Engineering
                  <small>Create interaction terms and polynomial features</small>
                </div>
              </label>
              <div class="sub-options" id="feature-engineering-options" style="display: none;">
                <!-- Variable Selection for Feature Engineering -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('feature-engineering')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('feature-engineering')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('feature-engineering')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('feature-engineering')">None</button>
                  </div>
                  <div id="feature-engineering-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-model-interpretability" checked>
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🔍 Model Interpretability
                  <small>SHAP values, feature importance, partial dependence plots</small>
                </div>
              </label>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-claude-plots" checked>
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🎨 Claude-Powered Plots
                  <small>AI-suggested visualizations based on results</small>
                </div>
              </label>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-custom-modeling">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  🎯 Custom Modeling
                  <small>Specify your own modeling requirements and custom algorithms</small>
                </div>
              </label>
              <div class="sub-options" id="custom-modeling-options" style="display: none;">
                <label for="custom-modeling-input">Custom modeling description:</label>
                <textarea id="custom-modeling-input" class="sub-textarea" 
                          placeholder="e.g., 'Train custom neural network with specific architecture', 'Use ensemble of SVMs with custom kernels', 'Implement domain-specific algorithm'"
                          rows="4"></textarea>
                
                <!-- Variable Selection for Custom Modeling -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('custom-modeling')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('custom-modeling')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('custom-modeling')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('custom-modeling')">None</button>
                  </div>
                  <div id="custom-modeling-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <button class="start-agent-btn" id="start-modeling-btn" onclick="startModelingAgent()" disabled>
            🚀 Start Modeling Agent
          </button>
        </div>
      </div>
      
      <!-- Visualization Agent Configuration -->
      <div id="visualization-config" class="agent-config" style="display: none;">
        <div class="config-content">
          <div class="config-section">
            <label for="viz-dataframe-select">📊 Select DataFrame</label>
            <select id="viz-dataframe-select" onchange="updateVizDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
            <div id="viz-dataframe-info" class="dataframe-info" style="display: none;"></div>
          </div>
          
                       <div id="viz-checklist" class="viz-checklist" style="display: none;">
               <h4>🎨 Select Visualization Categories</h4>
               <p>Choose the types of visualizations you want to generate. Each category will create appropriate plots for your data.</p>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-distributions" onchange="toggleVizCategory('distributions')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     📊 Distributions
                     <small>Histograms, density plots, and distribution analysis</small>
                   </div>
                 </label>
                 <div id="viz-distributions-options" class="sub-options" style="display: none;">
                   <div id="viz-dist-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('distributions')">
                       ➕ Add Plot
                     </button>
                   </div>
                 </div>
               </div>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-comparisons" onchange="toggleVizCategory('comparisons')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     📈 Comparisons
                     <small>Box plots, violin plots, and group comparisons</small>
                   </div>
                 </label>
                 <div id="viz-comparisons-options" class="sub-options" style="display: none;">
                   <div id="viz-comp-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('comparisons')">
                       ➕ Add Plot
                     </button>
                   </div>
                 </div>
               </div>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-relationships" onchange="toggleVizCategory('relationships')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     🔗 Relationships
                     <small>Scatter plots, line plots, and correlation analysis</small>
                   </div>
                 </label>
                 <div id="viz-relationships-options" class="sub-options" style="display: none;">
                   <div id="viz-rel-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('relationships')">
                       ➕ Add Plot
                     </button>
                   </div>
                 </div>
               </div>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-categorical" onchange="toggleVizCategory('categorical')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     📊 Categorical
                     <small>Bar charts, pie charts, and frequency analysis</small>
                   </div>
                 </label>
                 <div id="viz-categorical-options" class="sub-options" style="display: none;">
                   <div id="viz-cat-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('categorical')">
                       ➕ Add Plot
                     </button>
                   </div>
                 </div>
               </div>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-time-series" onchange="toggleVizCategory('time-series')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     📈 Time Series
                     <small>Line plots, trend analysis, and temporal patterns</small>
                   </div>
                 </label>
                 <div id="viz-time-series-options" class="sub-options" style="display: none;">
                   <div id="viz-ts-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('timeseries')">
                       ➕ Add Plot
                     </button>
                   </div>
                 </div>
               </div>
               
               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-statistical" onchange="toggleVizCategory('statistical')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     📊 Statistical Plots
                     <small>Q-Q plots, residual plots, and statistical diagnostics</small>
                   </div>
                 </label>
                 <div id="viz-statistical-options" class="sub-options" style="display: none;">
                   <div id="viz-stat-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('statistical')">
                       ➕ Add Plot
                     </button>
                   </div>
                 </div>
               </div>
             </div>
          
          
          <button class="start-agent-btn" id="start-viz-btn" onclick="startVisualizationAgent()" disabled>
            🎨 Start Visualization Agent
          </button>
        </div>
      </div>
      
      <!-- Guide Tab -->
      <div id="guide-tab" class="tab-content">
        <div class="guide-container">
          <div class="guide-section">
            <h3>🚀 Getting Started</h3>
            <div class="guide-card">
              <h4>Be Specific</h4>
              <ul>
                <li>✅ "Create a function to calculate mean by group"</li>
                <li>❌ "help me with data"</li>
                <li>✅ "Debug this ggplot error: object not found"</li>
                <li>❌ "it's not working"</li>
              </ul>
            </div>
          </div>
          
          <div class="guide-section">
            <h3>🔧 Key Features</h3>
            <div class="guide-card">
              <h4>Smart Context Capture</h4>
              <p>Automatically captures your entire R environment - data frames, functions, variables, plots, and active code.</p>
            </div>
            <div class="guide-card">
              <h4>Real-time Streaming</h4>
              <p>Watch AI responses stream in real-time. No waiting for complete responses.</p>
            </div>
            <div class="guide-card">
              <h4>Code Insertion</h4>
              <p>Click "Insert at Cursor" to add code directly into your R scripts. No copy-paste needed.</p>
            </div>
            <div class="guide-card">
              <h4>Error Debugging</h4>
              <p>Click "Debug Last Error" for instant analysis and step-by-step fixes.</p>
            </div>
            <div class="guide-card">
              <h4>Plot Analysis</h4>
              <p>Click "Analyze Last Plot" for statistical insights and improvement suggestions.</p>
            </div>
          </div>
          
          <div class="guide-section">
            <h3>🤖 AI Agents</h3>
            
            <div class="guide-card">
              <h4>What are Agents?</h4>
              <p>Specialized AI workflows that guide you through complete data analysis tasks step-by-step.</p>
            </div>
            
            <div class="guide-card">
              <h4>🧹 Data Cleaning Agent</h4>
              <ul>
                <li>Automatically detects missing values, outliers, duplicates</li>
                <li>Provides intelligent imputation suggestions</li>
                <li>Standardizes column names and data types</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>🔄 Transformation Agent</h4>
              <ul>
                <li>Smart mathematical transformations (log, sqrt)</li>
                <li>Automatic new variable creation</li>
                <li>Data reshaping and categorical encoding</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>📊 Statistical Analysis Agent</h4>
              <ul>
                <li>Intelligent test selection (t-test, ANOVA, chi-square)</li>
                <li>Effect size calculations (Cohen's d, eta-squared)</li>
                <li>Distribution analysis with assumption checking</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>🤖 Modeling Agent</h4>
              <ul>
                <li>Smart algorithm recommendations by target type</li>
                <li>Automatic feature engineering</li>
                <li>Model comparison and interpretation</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>🎨 Visualization Agent</h4>
              <ul>
                <li>Intelligent plot type recommendations</li>
                <li>Automatic statistical analysis of plots</li>
                <li>Smart variable filtering and validation</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>Getting Started with Agents</h4>
              <ol>
                <li>Click the <strong>🤖 Agents</strong> tab</li>
                <li>Select your data frame</li>
                <li>Choose your analysis type</li>
                <li>Follow the guided workflow</li>
                <li>Get AI analysis + executable code</li>
              </ol>
            </div>
          </div>
          
          <div class="guide-section">
            <h3>⚡ Performance Tips</h3>
            <div class="guide-card">
              <h4>Keep Environment Clean</h4>
              <p>This will save tokens and cost:</p>
              <ul>
                <li>Remove unused variables: <code>rm(unused_var)</code></li>
                <li>Clear large objects: <code>rm(large_dataframe)</code></li>
                <li>Restart R session: "Session > Restart R"</li>
                <li>Use <code>rm(list = ls())</code> for fresh start</li>
              </ul>
            </div>
          </div>
          

          
          <div class="guide-section">
            <h3>🔍 Troubleshooting</h3>
            <div class="guide-card">
              <h4>Slow Responses?</h4>
              <ul>
                <li>Your environment might be too large</li>
                <li>Try <code>rm(list = ls())</code> to clear workspace</li>
                <li>Restart R session for fresh start</li>
              </ul>
            </div>
            <div class="guide-card">
              <h4>Connection Issues?</h4>
              <ul>
                <li>Check your internet connection</li>
                <li>Verify your access code is valid</li>
                <li>Try refreshing the page</li>
                <li>Restart the addin if needed</li>
              </ul>
            </div>
            <div class="guide-card">
              <h4>Need Anything?</h4>
              <p>Contact us at <a href="mailto:founders@rgentai.com">founders@rgentai.com</a></p>
            </div>
          </div>
        </div>
      </div>
    </div>
    

    <div id="agent-config-modal" class="modal" style="display: none;">
      <div class="modal-content">
        <div class="modal-header">
          <h3>🧹 Configure Data Cleaning Agent</h3>
          <span class="modal-close" onclick="closeAgentConfigModal()">&times;</span>
        </div>
        
        <div class="modal-body">
          <div class="config-section">
            <label for="dataframe-select">📊 Select DataFrame *</label>
            <select id="dataframe-select" onchange="updateDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
            <div id="dataframe-info" class="dataframe-info" style="display: none;"></div>
          </div>
          
          <div class="config-section">
            <label>🔧 Handle Missing Values (NAs)</label>
            <div class="radio-group">
              <label class="radio-option">
                <input type="radio" name="na-handling" value="dont" checked>
                <span>Don't touch missing values</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="na-handling" value="mean">
                <span>Replace with mean (numeric columns)</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="na-handling" value="median">
                <span>Replace with median (numeric columns)</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="na-handling" value="mode">
                <span>Replace with mode (text columns)</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="na-handling" value="remove">
                <span>Remove rows with missing values</span>
              </label>
            </div>
          </div>
          
          <div class="config-section">
            <h4>📋 Cleaning Workflow</h4>
            <ol class="workflow-steps">
              <li>Examine data structure and types</li>
              <li>Identify missing values and patterns</li>
              <li>Handle missing values using selected method</li>
              <li>Fix data type conversions</li>
              <li>Remove outliers using IQR method</li>
            </ol>
          </div>
        </div>
        
        <div class="modal-footer">
          <div class="modal-actions">
            <button class="btn-secondary" onclick="closeAgentConfigModal()">Cancel</button>
            <button class="btn-primary" id="start-cleaning-btn" onclick="startCleaningAgent()" disabled>
              Start Cleaning Agent
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <script>
      let ws = null;
      let isConnected = false;
      let isAccessValid = false;
      let accessCode = '';
      let currentStreamingMessage = null;
      let streamingTimeout = null;
      let currentAgentWorkflow = null;
      let agentResults = [];
      let agentCodes = [];
      let currentStepCode = null;
      
      // Stop response state management
      let isAIResponding = false;
      let currentRequestId = null;
      let pendingTimeouts = [];
      
      // Access validation
      async function validateAccess() {
        const code = document.getElementById('access-code').value.trim();
        if (!code) {
          showAccessStatus('Please enter an access code', 'error');
          return;
        }
        
        showAccessStatus('Validating access...', 'info');
        
        try {
          const response = await fetch('https://rgent.onrender.com/validate', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ access_code: code })
          });
          
          const data = await response.json();
          
          if (response.ok && data.valid) {
            isAccessValid = true;
            accessCode = code;
            showAccessStatus('Access validated successfully!', 'success');
            document.getElementById('access-section').style.display = 'none';
            document.getElementById('main-interface').style.display = 'block';
            connectWebSocket();
            
            // Send access code to R backend once WebSocket is connected
            setTimeout(() => {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                  action: 'set_access_code',
                  access_code: code
                }));
              }
            }, 1000);
          } else {
            // Show the specific error message from the backend
            const errorMessage = data.detail || 'Invalid access code';
            showAccessStatus(errorMessage, 'error');
          }
        } catch (error) {
          console.error('Validation error:', error);
          showAccessStatus('Failed to validate access code', 'error');
        }
      }
      
      function showAccessStatus(message, type) {
        const statusDiv = document.getElementById('access-status');
        statusDiv.textContent = message;
        statusDiv.className = 'status ' + type;
        statusDiv.style.display = 'block';
      }
      
      // Tab switching - REMOVED DUPLICATE FUNCTION
      // The working switchTab function is defined later in the file
      
      // Load usage statistics
      async function loadStats() {
        if (!isAccessValid) return;

        try {
          const response = await fetch(`https://rgent.onrender.com/usage?access_code=${accessCode}`);
          const data = await response.json();

          console.log('Stats response:', data);

          if (response.ok) {
            // Get plan type and basic stats
            const planType = data.plan_type || 'free_trial';
            const monthRequests = data.month_requests || 0;
            const requestsRemaining = data.requests_remaining || 0;
            
            // Get subscription information
            const subscriptionStatus = data.subscription_status || 'inactive';
            const subscriptionEndDate = data.subscription_end_date || null;
            const subscriptionId = data.subscription_id || null;
            
            console.log('Usage stats:', { 
              planType, monthRequests, requestsRemaining, subscriptionStatus, subscriptionEndDate, subscriptionId
            });
            
            // Update plan type display
            const planTypeDisplay = document.getElementById('plan-type-display');
            if (planTypeDisplay) {
              const planNames = {
                'free_trial': '🎁 Free Trial',
                'pro_haiku': '🚀 Pro Haiku',
                'pro_sonnet': '🚀 Pro Sonnet'
              };
              planTypeDisplay.textContent = planNames[planType] || planType;
            }
            
            // Update subscription information
            const subscriptionStatusElement = document.getElementById('subscription-status');
            const subscriptionEndDateElement = document.getElementById('subscription-end-date');
            const subscriptionIdElement = document.getElementById('subscription-id');
            
            if (subscriptionStatusElement) {
              const statusDisplay = subscriptionStatus === 'active' ? '✅ Active' : '❌ Inactive';
              subscriptionStatusElement.textContent = statusDisplay;
            }
            
            if (subscriptionEndDateElement) {
              if (subscriptionEndDate) {
                const endDate = new Date(subscriptionEndDate);
                const formattedDate = endDate.toLocaleDateString('en-US', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                });
                subscriptionEndDateElement.textContent = `${formattedDate} UTC`;
              } else {
                subscriptionEndDateElement.textContent = 'N/A';
              }
            }
            

            

            

            
            // Update monthly usage
            const monthlyRequestsElement = document.getElementById('monthly-requests');
            const monthlyRequestsLimitElement = document.getElementById('monthly-requests-limit');
            const requestsRemainingElement = document.getElementById('requests-remaining');
            const monthlyProgressBar = document.getElementById('monthly-progress-bar');
            const monthlyProgressFill = document.getElementById('monthly-progress-fill');
            
            if (monthlyRequestsElement && monthlyRequestsLimitElement && requestsRemainingElement && monthlyProgressBar && monthlyProgressFill) {
              monthlyRequestsElement.textContent = monthRequests;
              
              // Set limit based on plan type
              let monthlyLimit;
              if (planType === 'free_trial') {
                monthlyLimit = 25;
              } else if (planType === 'pro_haiku' || planType === 'pro_sonnet') {
                monthlyLimit = 500;
              } else {
                monthlyLimit = 100; // fallback
              }
              
              monthlyRequestsLimitElement.textContent = `of ${monthlyLimit} requests`;
              requestsRemainingElement.textContent = requestsRemaining;
              
              // Update progress bar
              const progressPercent = Math.min(100, (monthRequests / monthlyLimit) * 100);
              monthlyProgressFill.style.width = `${progressPercent}%`;
              monthlyProgressFill.textContent = `${Math.round(progressPercent)}%`;
            }
            
            // Show/hide sections based on plan type
            const isFreeTrial = planType === 'free_trial';
            const paidUsageSection = document.getElementById('paid-usage-section');

            const monthlyUsageSection = document.getElementById('monthly-usage-section');
            const freeTrialSection = document.getElementById('free-trial-section');
            
            if (isFreeTrial) {
              // Hide paid usage sections, show free trial section
              paidUsageSection.style.display = 'none';

              monthlyUsageSection.style.display = 'none';
              freeTrialSection.style.display = 'block';
              
              // Update free trial stats
              const requestsUsed = data.monthly_requests || 0;
              const requestsRemaining = Math.max(0, 25 - requestsUsed);
              const progressPercent = Math.min(100, (requestsUsed / 25) * 100);
              
              document.getElementById('free-requests-used').textContent = requestsUsed;
              document.getElementById('free-requests-remaining').textContent = requestsRemaining;
              document.getElementById('free-progress-fill').style.width = `${progressPercent}%`;
              document.getElementById('free-progress-fill').textContent = `${Math.round(progressPercent)}%`;
            } else {
              // Show paid usage sections, hide free trial section
              paidUsageSection.style.display = 'block';

              monthlyUsageSection.style.display = 'block';
              freeTrialSection.style.display = 'none';
              



            }
            
            // Show success status
            const statusDiv = document.getElementById('usage-status');
            statusDiv.className = 'status success';
            statusDiv.textContent = 'Stats updated successfully';
            statusDiv.style.display = 'block';
            setTimeout(() => {
              statusDiv.style.display = 'none';
            }, 3000);
          }
        } catch (error) {
          console.error('Failed to load stats:', error);
          const statusDiv = document.getElementById('usage-status');
          statusDiv.className = 'status error';
          statusDiv.textContent = 'Failed to load stats';
          statusDiv.style.display = 'block';
        }
      }
      
      // Copy code to clipboard with fallback for restricted environments
      function copyToClipboard(text, button) {
        // Check if we're in a restricted environment (like RStudio viewer pane)
        const isRestricted = window.location.href.includes('viewer_pane') || 
                           window.location.href.includes('capabilities') ||
                           !navigator.clipboard;
        
        if (!isRestricted && navigator.clipboard && navigator.clipboard.writeText) {
          // Try modern clipboard API only in non-restricted environments
          navigator.clipboard.writeText(text).then(function() {
            button.textContent = "Copied!";
            button.classList.add("copied");
            setTimeout(function() {
              button.textContent = "Copy";
              button.classList.remove("copied");
            }, 2000);
          }).catch(function(err) {
            console.error('Failed to copy: ', err);
            // Fallback to old method
            fallbackCopyToClipboard(text, button);
          });
        } else {
          // Use fallback method for restricted environments
          fallbackCopyToClipboard(text, button);
        }
      }
      
      function fallbackCopyToClipboard(text, button) {
        // Create a temporary textarea element
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        textArea.style.opacity = "0";
        document.body.appendChild(textArea);
        
        // Select and copy
        textArea.focus();
        textArea.select();
        
        try {
          const successful = document.execCommand('copy');
          if (successful) {
            button.textContent = "Copied!";
            button.classList.add("copied");
            setTimeout(function() {
              button.textContent = "Copy";
              button.classList.remove("copied");
            }, 2000);
          } else {
            button.textContent = "Failed";
            setTimeout(function() {
              button.textContent = "Copy";
            }, 2000);
          }
        } catch (err) {
          console.error('Fallback copy failed: ', err);
          button.textContent = "Failed";
          setTimeout(function() {
            button.textContent = "Copy";
          }, 2000);
        }
        
        // Clean up
        document.body.removeChild(textArea);
      }
      
               // Connect to WebSocket
         function connectWebSocket() {
           // Try port 8888 first, then 8889 if that fails
           let wsUrl;
           
           if (window.location.protocol === 'https:') {
             // If we're on HTTPS, use secure WebSocket
             const host = window.location.hostname || 'localhost';
             wsUrl = `wss://${host}/ws`;
           } else {
             // If we're on HTTP, use regular WebSocket
             const host = window.location.hostname || '127.0.0.1';
             wsUrl = `ws://${host}:8888`;
           }
           
           console.log("Connecting to WebSocket:", wsUrl);
           ws = new WebSocket(wsUrl);
           
           ws.onerror = function(event) {
             console.log("WebSocket connection failed on port 8888, trying 8889...");
             // Try port 8889 if 8888 fails
             wsUrl = `ws://${window.location.hostname || '127.0.0.1'}:8889`;
             console.log("Connecting to WebSocket:", wsUrl);
             ws = new WebSocket(wsUrl);
             
             ws.onopen = function() {
               console.log("WebSocket connected on port 8889");
               isConnected = true;
               document.getElementById("user-input").disabled = false;
               document.getElementById("send-button").disabled = false;
               document.getElementById("new-conversation-button").disabled = false;
               document.getElementById("debug-error-button").disabled = false;
               document.getElementById("analyze-plot-button").disabled = false;
               addMessage("Connected! Ask me anything about your R code.", "ai");
             };
             
             ws.onmessage = function(event) {
               console.log("Message received:", event.data);
               // FIXED: Remove call to non-existent handleMessage function
               // The main WebSocket handler below will handle all messages
             };
             
             ws.onclose = function() {
               console.log("WebSocket disconnected");
               isConnected = false;
               document.getElementById("user-input").disabled = true;
               document.getElementById("send-button").disabled = true;
               document.getElementById("new-conversation-button").disabled = true;
               document.getElementById("debug-error-button").disabled = true;
               document.getElementById("analyze-plot-button").disabled = true;
             };
             
             ws.onerror = function(event) {
               console.log("WebSocket error on port 8889:", event);
             };
           };
        
        ws.onopen = function() {
          console.log("WebSocket connected");
          isConnected = true;
          document.getElementById("user-input").disabled = false;
          document.getElementById("send-button").disabled = false;
          document.getElementById("new-conversation-button").disabled = false;
          document.getElementById("debug-error-button").disabled = false;
          document.getElementById("analyze-plot-button").disabled = false;
          addMessage("Connected! Ask me anything about your R code.", "ai");
        };
        
        ws.onmessage = function(event) {
          const data = JSON.parse(event.data);
          console.log("Received:", data);
          
          // FIXED: Add debugging for transformation agent messages
          if (data.action === 'transformation_agent_started') {
            console.log('🔍 Transformation agent message received:', data);
          }
          
          switch(data.action) {
            case "ai_response":
              // Check if agent was stopped before processing AI response
              if (currentAgentWorkflow && currentAgentWorkflow.stopped) {
                console.log('🛑 Agent was stopped, ignoring AI response');
                return;
              }
              
              if (data.streaming) {
                // Handle streaming response
                if (data.chunk) {
                  addStreamingChunk(data.chunk);
                } else if (data.finished) {
                  finishStreaming();
                }
              } else {
                // Handle regular response
                addMessage(data.message, "ai");
                
                // Transform stop button back to send button for non-streaming responses
                if (isAIResponding) {
                  transformToSendButton();
                }
              }
              break;
            case "stop_response":
              // Handle stop response confirmation
              console.log('🛑 Stop response confirmed by backend');
              break;
            case "inserted":
              addMessage("Code inserted successfully!", "ai");
              break;
            case "transformation_agent_started":
              console.log('🔍 Transformation agent started message received');
              handleTransformationAgentStarted(data.data || data);
              break;
            case "statistical_agent_started":
              console.log('🔍 Statistical agent started message received');
              handleStatisticalAgentStarted(data.data || data);
              break;
            case "statistical_step_result":
              console.log('🔍 Statistical step result received');
              handleStatisticalStepResult(data.data || data);
              break;
            case "visualization_agent_started":
              console.log('🎨 Visualization agent started message received');
              handleVisualizationAgentStarted(data.data || data);
              break;
            case "visualization_step_result":
              console.log('🎨 Visualization step result received');
              handleVisualizationStepResult(data.data || data);
              break;
            case "visualization_plot_analysis":
              console.log('🎨 Visualization plot analysis received');
              if (data.success) {
                console.log('🎨 Plot analysis completed successfully');
              } else {
                console.log('🎨 Plot analysis failed:', data.message);
                addMessage(`❌ **Plot Analysis Error:** ${data.message}`, 'ai');
              }
              break;
            case "executed":
              // Check if agent was stopped before processing execution results
              if (currentAgentWorkflow && currentAgentWorkflow.stopped) {
                console.log('🛑 Agent was stopped, ignoring execution result');
                return;
              }
              
              if (data.status === "success") {
                // Format the output nicely for agent steps
                let outputText = "";
                if (data.output && Array.isArray(data.output)) {
                  outputText = data.output.join('\n');
                } else if (data.output) {
                  outputText = data.output;
                } else {
                  outputText = "No output";
                }
                
                // Check if this is a custom transformation request (before checking agent output)
                if (outputText.includes('🔧 Custom Transformation Request') && outputText.includes('🤖 Sending custom transformation request to Claude')) {
                  console.log('🔍 Detected custom transformation request in executed output, sending to Claude');
                  
                  // Display the custom transformation request in chat with formatting
                  const formattedOutput = outputText
                    .replace(/🔧 Custom Transformation Request/g, '**🔧 Custom Transformation Request**')
                    .replace(/Request: (.+?)(?=\n|$)/g, '**Request:** $1')
                    .replace(/Dataset: (.+?)(?=\n|$)/g, '**Dataset:** $1')
                    .replace(/Variables: (.+?)(?=\n|$)/g, '**Variables:** $1')
                    .replace(/🤖 Sending custom transformation request to Claude\.\.\./g, '**🤖 Sending custom transformation request to Claude...**')
                    .replace(/Claude will provide the transformation code based on your request\./g, '**Claude will provide the transformation code based on your request.**');
                  
                  addMessage(formattedOutput, 'ai');
                  
                  // Set flag to prevent duplicate requests
                  window.customTransformationInProgress = true;
                  
                  // Send custom transformation request to Claude
                  if (ws && ws.readyState === WebSocket.OPEN) {
                    // Extract the custom request from the output
                    const requestMatch = outputText.match(/Request: (.+?)\n/);
                    const customRequest = requestMatch ? requestMatch[1] : 'Custom transformation requested';
                    
                    // Create Claude prompt for custom transformation
                    const claudePrompt = `I need you to perform a custom data transformation based on the following request:

**Custom Transformation Request:**
${customRequest}

**Dataset Information:**
- Dataset: ${currentAgentWorkflow?.dataframe || 'Unknown'}
- Variables: ${currentAgentWorkflow?.dataframe ? 'Available in workspace' : 'Unknown'}

Please provide:
1. A detailed transformation plan
2. Executable R code to perform the transformations
3. Data quality checks and validation
4. Summary of changes made

Code only. Minimal chat. Provide executable R code that can be run directly.`;

                    // Send to Claude
                    ws.send(JSON.stringify({
                      action: 'chat_with_ai',
                      message: claudePrompt,
                      conversation_context: 'custom_transformation'
                    }));
                  }
                  break;
                }
                
                // Check for plot data in the output (for visualization agent)
                // This will detect multiple plots since we use global matching
                const plotMatches = outputText.match(/PLOT_DATA:\s*([A-Za-z0-9+/=]+)/g);
                const analyzeMatch = outputText.match(/ANALYZE_PLOT:TRUE/);
                
                if (plotMatches && plotMatches.length > 0) {
                  console.log('🎨 Detected', plotMatches.length, 'plot(s) in execution output');
                  
                  // Display each plot found
                  plotMatches.forEach((match, index) => {
                    // Extract just the base64 data part
                    const plotDataMatch = match.match(/PLOT_DATA:\s*([A-Za-z0-9+/=]+)/);
                    const plotData = plotDataMatch ? plotDataMatch[1] : '';
                    const plotNumber = plotMatches.length > 1 ? ` (${index + 1}/${plotMatches.length})` : '';
                    
                    console.log('🎨 Extracted plot data length:', plotData.length);
                    console.log('🎨 Plot data preview:', plotData.substring(0, 50) + '...');
                    
                    const message = `**🎨 Generated Plot${plotNumber}**\n\n` +
                                   `Plot from visualization agent:\n\n` +
                                   `data:image/png;base64,${plotData}`;
                    addVisualizationMessage(message, 'ai');
                  });
                  
                  // Note: Analysis will be triggered after all plots are complete
                  // to provide better multi-plot analysis
                  
                  // Handle visualization step completion for workflow progression
                  if (currentAgentWorkflow && currentAgentWorkflow.type === 'visualization') {
                    console.log('🎨 Processing visualization step completion for workflow progression');
                    
                    // Store result for final summary (without displaying again)
                    agentResults.push({
                      description: 'Generated Plot',
                      output: `Generated plot ${currentAgentWorkflow.currentStep - 1} of ${currentAgentWorkflow.totalSteps}`,
                      step: currentAgentWorkflow.currentStep - 1
                    });
                    
                    // Analyze this specific plot
                    analyzeCurrentVisualizationPlot();
                    
                    // Move to next step after a short delay to allow analysis to start
                    setTimeout(() => {
                      requestNextVisualizationStep();
                    }, 1000);
                  }
                  
                  break;
                }
                
                // Check if this is agent output
                if (currentAgentWorkflow && outputText.length > 0) {
                  // Store the result and code for final summary
                  const currentStepInfo = currentAgentWorkflow.workflowSteps[currentAgentWorkflow.currentStep - 1];
                  agentResults.push({
                    step: currentAgentWorkflow.currentStep,
                    operation: currentStepInfo?.operation,
                    description: currentStepInfo?.description,
                    output: outputText
                  });
                  
                  // Store the code that was executed
                  agentCodes.push({
                    step: currentAgentWorkflow.currentStep,
                    operation: currentStepInfo?.operation,
                    description: currentStepInfo?.description,
                    code: currentStepCode
                  });
                  
                  console.log('🔍 Agent step completed. Current workflow state:', currentAgentWorkflow);
                  console.log('🔍 Step comparison:', {
                    currentStep: currentAgentWorkflow.currentStep,
                    totalSteps: currentAgentWorkflow.totalSteps,
                    comparison: currentAgentWorkflow.currentStep < currentAgentWorkflow.totalSteps,
                    shouldContinue: currentAgentWorkflow.currentStep < currentAgentWorkflow.totalSteps
                  });
                  
                  if (currentAgentWorkflow.currentStep < currentAgentWorkflow.totalSteps) {
                    console.log('🔍 Moving to next step in 1.5 seconds...');
                    // Move to next step after a brief delay
                    setTimeout(() => {
                      console.log('🔍 Executing next step now!');
                      executeNextAgentStep();
                    }, 1000);
                  } else {
                    console.log('🔍 Workflow steps complete!');
                    console.log('🔍 Final workflow state:', {
                      currentStep: currentAgentWorkflow.currentStep,
                      totalSteps: currentAgentWorkflow.totalSteps,
                      agentType: currentAgentWorkflow.algorithms ? 'Modeling' : 
                                currentAgentWorkflow.transformationOptions ? 'Transformation' : 'Cleaning'
                    });
                    
                    // All agents end workflow normally
                    console.log('🔍 Workflow complete!');
                    
                    // Store agent type before clearing workflow for final messaging
                    window.completedAgentType = currentAgentWorkflow.algorithms ? 'Modeling' : 
                                               currentAgentWorkflow.transformationOptions ? 'Transformation' : 
                                               currentAgentWorkflow.analysisOptions ? 'Statistical' : 'Cleaning';
                    
                    // All agents end workflow normally using unified function
                    finishAgentWorkflow();
                    
                    // Don't reset button yet - wait for AI response streaming to complete
                    // The button will be reset in finishStreaming() when streaming is done
                  }
                } else if (!currentAgentWorkflow) {
                  // Check if this is cleaning code execution
                  if (cleaningCodeExecuting) {
                    console.log('🔍 Cleaning code executed successfully!');
                    // Code executed successfully, no need to check for errors
                    
                    // Determine agent type for appropriate messaging
                    let agentType = window.currentActiveAgentType || window.completedAgentType || 'Cleaning';
                    let operationType, nextSteps;
                    
                    switch (agentType) {
                      case 'Modeling':
                      operationType = 'modeled';
                      nextSteps = 'Check your environment for the trained models and results';
                        break;
                      case 'Transformation':
                        operationType = 'transformed';
                        nextSteps = 'Check your environment for the transformed dataset';
                        break;
                      case 'Statistical':
                      operationType = 'analyzed';
                      nextSteps = 'Check your environment for the statistical analysis results';
                        break;
                      case 'Cleaning':
                      default:
                        operationType = 'cleaned';
                        nextSteps = 'Check your environment for the cleaned dataset';
                        break;
                    }
                    
                    // Check if this is a normal chat auto-execute (not an agent workflow)
                    if (window.currentActiveAgentType === null && window.completedAgentType === null) {
                      // Normal chat auto-execute
                      addMessage(`✅ **Code Executed Successfully!**`, 'ai');
                      addMessage(`🎯 **Next Steps:**\n- Check your environment for the results\n- Verify the output meets your expectations\n- Continue with your analysis`, 'ai');
                    } else {
                      // Agent workflow auto-execute
                      addMessage(`✅ **${agentType} Code Executed Successfully!**\n\nThe data has been ${operationType} according to Claude's recommendations.`, 'ai');
                      addMessage(`🎯 **Next Steps:**\n- ${nextSteps}\n- Verify the results meet your expectations\n- The ${agentType.toLowerCase()} agent workflow is now complete!`, 'ai');
                    }
                    
                    // Reset cleaning code state
                    cleaningCodeIterationCount = 0;
                    cleaningCodeExecuting = false;
                    console.log(`🔍 ${agentType} code succeeded, resetting state`);
                    
                    // Clear the stored agent type
                    window.completedAgentType = null;
                    window.currentActiveAgentType = null;
                    
                    // Don't reset button yet - wait for AI response streaming to complete
                    // The button will be reset in finishStreaming() when streaming is done
                  } else {
                    // Regular code execution, not agent
                    addMessage("Code executed successfully! Output: " + outputText, "ai");
                  }
                }
              } else {
                // Code execution failed
                if (cleaningCodeExecuting) {
                  // This is cleaning code that failed - trigger iteration
                  console.log('🔍 Cleaning code execution failed, triggering error handling...');
                  // Pass the current step code that failed
                  handleCleaningCodeError(data.error, currentStepCode || "");
                } else {
                  // Regular code execution failed
                  addMessage("Code execution failed: " + data.error, "ai");
                }
              }
              break;
            case "execute_and_fix":
              if (data.status === "success") {
                addMessage("Code executed successfully! Output: " + (data.output || "No output"), "ai");
              } else if (data.status === "error_fixed") {
                addMessage("Code failed but AI provided a fix:\n\nOriginal error: " + data.original_error + "\n\nFixed code:\n```r\n" + data.fixed_code + "\n```", "ai");
              } else {
                addMessage("Code execution failed: " + data.error, "ai");
              }
              break;
            case "error":
              addMessage("Error: " + data.message, "ai");
              break;
            case "get_last_error":
              if (data.message) {
                addMessage(data.message, "ai");
              }
              break;
            case "debug_info":
              // Skip the verbose progress updates - just show the AI fix directly
              break;
            case "debug_ai_response":
              if (data.streaming) {
                addStreamingChunk(data.chunk);
              } else {
                console.log("DEBUG: Finishing debug streaming");
                finishStreaming();
                // No buttons - just show the debug analysis
              }
              break;
            case "chat_with_ai":
              // Handle messages sent to the chat interface
              if (data.message) {
                addMessage(data.message, "ai");
              }
              break;
            case "plot_analysis":
              if (data.success) {
                // Process plot analysis response properly
                const fullMessage = "✅ **Plot Analysis Complete!**\n\n" + data.ai_interpretation;
                addPlotAnalysisMessage(fullMessage);
              } else {
                addMessage("❌ **Plot Analysis Failed:** " + data.message, "ai");
              }
              break;

            case "theme_info":
              // Apply RStudio theme with actual colors
              if (data.is_dark !== undefined) {
                applyTheme(data.is_dark, data.theme_name, data.colors);
              }
              break;

            // Agent-related cases
            case "dataframes":
              console.log('Handling dataframes action');
              // Populate all agents' dataframes to ensure consistency
              populateDataFrameSelect(data.data);
              populateTransformationDataFrameSelect(data.data);
              populateStatisticalDataFrameSelect(data.data);
              populateVizDataFrameSelect(data.data);
              populateModelingDataFrameSelect(data.data);
              break;
            case "dataframe_info":
              console.log('Handling dataframe_info action');
              displayDataFrameInfo(data.data);
              // Also handle for modeling agent if that's the current context
              if (window.currentModelingDataframe) {
                handleModelingDataframeInfo(data.data);
              }
              // Also handle for statistical agent if that's the current context
              if (window.currentStatisticalDataframe) {
                handleStatisticalDataframeInfo(data.data);
              }
              // Also handle for visualization agent if that's the current context
              if (window.currentVisualizationDataframe) {
                handleVisualizationDataframeInfo(data.data);
              }
              break;
            case "dataframe_variables":
              console.log('Handling dataframe_variables action');
              renderVariableSelection(data.data);
              break;
            case "agent_started":
              console.log('Handling agent_started action');
              handleAgentStarted(data.data);
              break;
            case "agent_step":
              console.log('Handling agent_step action');
              handleAgentStep(data.data);
              break;
            case "transformation_agent_started":
              console.log('Handling transformation_agent_started action');
              handleTransformationAgentStarted(data.data);
              break;
            case "statistical_agent_started":
              console.log('Handling statistical_agent_started action');
              handleStatisticalAgentStarted(data.data);
              break;
            case "modeling_agent_started":
              console.log('Handling modeling_agent_started action');
              handleModelingAgentStarted(data.data);
              break;
            case "execute_code_response":
              console.log('🔍 Received execute_code_response');
              console.log('🔍 Code to execute:', data.code);
              
              // Store the code for later display
              currentStepCode = data.code;
              
              // Check if this is a custom transformation request
              if (data.code.includes('🔧 Custom Transformation Request') && data.code.includes('🤖 Sending custom transformation request to Claude')) {
                console.log('🔍 Detected custom transformation request, sending to Claude');
                
                // Set flag to prevent duplicate requests
                window.customTransformationInProgress = true;
                
                // Send custom transformation request to Claude
                if (ws && ws.readyState === WebSocket.OPEN) {
                  // Extract the custom request from the code
                  const requestMatch = data.code.match(/Request: (.+?)\\n/);
                  const customRequest = requestMatch ? requestMatch[1] : 'Custom transformation requested';
                  
                  // Create Claude prompt for custom transformation
                  const claudePrompt = `I need you to perform a custom data transformation based on the following request:

**Custom Transformation Request:**
${customRequest}

**Dataset Information:**
- Dataset: ${currentAgentWorkflow?.dataframe || 'current dataset'}
- Variables: Available in the current workspace

Please provide:
1. **Transformation Plan**: What data transformations should be performed?
2. **R Code**: Complete, executable R code to perform the transformations
3. **Data Quality Checks**: How to verify the transformations worked correctly
4. **New Variables**: What new variables will be created?

**IMPORTANT**: This is a transformation agent request. Please provide complete, executable R code that can be run immediately. Focus on practical data transformations that address the custom request. Include all necessary libraries and error handling.

Code only. Minimal chat. Provide executable R code that performs the requested data transformations.`;

                  ws.send(JSON.stringify({
                    action: 'chat_with_ai',
                    message: claudePrompt,
                    conversation_context: 'custom_transformation',
                    agentType: 'transformation'
                  }));
                }
              } else {
                // Automatically execute the next step's code
                if (ws && ws.readyState === WebSocket.OPEN) {
                  console.log('🔍 Sending execute_code request');
                  ws.send(JSON.stringify({
                    action: 'execute_code',
                    code: data.code
                  }));
                } else {
                  console.log('🔍 WebSocket not available for execute_code');
                }
              }
              break;
              
            case "claude_response":
              console.log('🔍 Received Claude response:', data.conversation_context);
                            if (data.conversation_context === 'data_cleaning_agent_code') {
                handleCleaningCodeResponse(data.message, data.conversation_context);
              }
              break;
              
            case "ai_response":
              console.log('🔍 Received AI response:', data);
              console.log('🔍 Data structure:', JSON.stringify(data, null, 2));
              
              // Check if this is Claude's response to our cleaning code request
              if (data.message && data.message.includes('```r')) {
                console.log('🔍 Detected R code in AI response message, handling automatically');
                handleCleaningCodeResponse(data.message, data.conversation_context);
              } else if (data.chunk && data.chunk.includes('```r')) {
                console.log('🔍 Detected R code in AI response chunk, handling automatically');
                handleCleaningCodeResponse(data.chunk, data.conversation_context);
              } else if (data.finished && data.chunk && data.chunk.includes('```r')) {
                console.log('🔍 Detected R code in finished AI response, handling automatically');
                handleCleaningCodeResponse(data.chunk, data.conversation_context);
              } else {
                console.log('🔍 No R code detected in AI response');
              }
              break;
              
            case "last_error":
              console.log('🔍 Received last error:', data.error);
              if (data.error && data.error !== 'No error') {
                handleCleaningCodeError(data.error, data.code);
              }
              break;
              
            case "claude_fixed_code":
              console.log('🔍 Received Claude fixed code response');
              handleCleaningCodeResponse(data.message, 'data_cleaning_agent_code_fix');
              break;
              
            case "streaming_complete":
              console.log('🔍 Streaming complete, checking for R code in final message');
              // Check if we have a complete message with R code
              if (window.lastCompleteMessage && window.lastCompleteMessage.includes('```r')) {
                console.log('🔍 Detected R code in complete streaming message, handling automatically');
                
                if (currentAgentWorkflow) {
                  console.log('🔍 Agent workflow is running, not handling as cleaning code');
                  // For agent workflows, the code execution is handled by the workflow system
                } else {
                  console.log('🔍 No agent workflow running, handling as cleaning code');
                  handleCleaningCodeResponse(window.lastCompleteMessage, 'data_cleaning_agent_code');
                }
              }
              break;
            case "stop_response":
              // Handle stop response confirmation
              console.log('🛑 Stop response confirmed by backend');
              break;

          }
        };
        
        ws.onclose = function() {
          console.log("WebSocket disconnected");
          isConnected = false;
          document.getElementById("user-input").disabled = true;
          document.getElementById("send-button").disabled = true;
          document.getElementById("debug-error-button").disabled = true;
          addMessage("Connection lost. Please restart the addin.", "ai");
        };
        
        ws.onerror = function(error) {
          console.error("WebSocket error:", error);
          addMessage("Failed to connect to RStudio. Please check if the server is running.", "ai");
        };
      }
      
      function debugLastError() {
        if (!isConnected) return;
        
        console.log("Requesting last error...");
        const message = {
          action: "get_last_error"
        };
        
        ws.send(JSON.stringify(message));
        

      }
      
      function sendMessage() {
        const input = document.getElementById("user-input");
        const message = input.value.trim();
        if (!message || !isConnected) return;
        
        // Add user message
        addMessage(message, "user");
        input.value = "";
        
        // Insert AI placeholder while thinking
        const thinking = document.createElement("div");
        thinking.className = "message ai-message";
        thinking.id = "ai-thinking";
        thinking.textContent = "Thinking...";
        document.getElementById("chat-container").appendChild(thinking);
        
        // Set AI responding flag when sending message
        isAIResponding = true;
        
        // Send to R via WebSocket
        ws.send(JSON.stringify({
          action: "chat_with_ai",
          message: message
        }));
        

      }
      

      
      // Transform stop button back to send button
      function transformToSendButton() {
        const sendBtn = document.getElementById('send-button');
        sendBtn.textContent = 'Send';
        sendBtn.className = 'send-button';
        sendBtn.onclick = sendMessage;
        isAIResponding = false;
        currentRequestId = null;
      }
      
      // Transform send button to agent stop button
      function transformToAgentStopButton() {
        console.log('🔄 Transforming send button to agent stop button...');
        const sendBtn = document.getElementById('send-button');
        console.log('🔍 Send button found:', sendBtn);
        
        if (sendBtn) {
          sendBtn.textContent = '🛑 Stop Agent';
          sendBtn.className = 'send-button stop-mode';
          sendBtn.onclick = stopAgentWorkflow;
          console.log('✅ Button transformed to agent stop button');
          
          // Set AI responding flag when agent workflow starts
          isAIResponding = true;
        } else {
          console.error('❌ Send button not found!');
        }
      }
      
      // Stop agent workflow and reset everything
      function stopAgentWorkflow() {
        console.log('🛑 Stopping agent workflow...');
        
        // Clear all pending timeouts
        pendingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
        pendingTimeouts = [];
        
        // Set stop flag before clearing workflow
        if (currentAgentWorkflow) {
          currentAgentWorkflow.stopped = true;
          
          // Send stop message to backend
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              action: 'stop_agent',
              message: 'User requested to stop the agent workflow'
            }));
          }
          
          currentAgentWorkflow = null;
          agentResults = [];
          agentCodes = [];
          currentStepCode = null;
        }
        
        // Reset cleaning code state
        cleaningCodeExecuting = false;
        cleaningCodeIterationCount = 0;
        
        // Show stopped message
        addMessage('🛑 **Agent Stopped** - Workflow interrupted by user.', 'ai');
        
        // Reset AI responding flag
        isAIResponding = false;
        
        // Transform back to send button
        transformToSendButton();
      }
      
      function addStreamingChunk(chunk) {
        if (!currentStreamingMessage) {
          // Remove thinking placeholder if present
          const placeholder = document.getElementById("ai-thinking");
          if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
          
          // Start new streaming message
          currentStreamingMessage = document.createElement("div");
          currentStreamingMessage.className = "message ai-message";
          currentStreamingMessage.innerHTML = "";
          document.getElementById("chat-container").appendChild(currentStreamingMessage);
          
          // Set AI responding flag when streaming starts
          isAIResponding = true;
        }
        
        // Add chunk to current message
        currentStreamingMessage.innerHTML += chunk;
        
        // Don't apply any formatting during streaming - wait until complete
        // This prevents breaking lines in the middle of words
        
        // Scroll to bottom
        const container = document.getElementById("chat-container");
        container.scrollTop = container.scrollHeight;
        
        // Clear any existing timeout
        if (streamingTimeout) {
          clearTimeout(streamingTimeout);
        }
        
        // Set timeout to finish streaming if no more chunks
        streamingTimeout = setTimeout(() => {
          finishStreaming();
        }, 1000);
      }
      
      function applyBasicFormatting(messageDiv) {
        let content = messageDiv.innerHTML;
        
        // Only apply basic formatting during streaming (no code blocks)
        // Bold text
        content = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // Italic text
        content = content.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        // Numbered lists
        content = content.replace(/^(\d+\.\s+)(.*)$/gm, '<div style="margin-left: 20px; white-space: normal; word-wrap: break-word; word-break: normal; hyphens: none;"><strong>$1</strong>$2</div>');
        
        // Bullet points
        content = content.replace(/^[-*]\s+(.*)$/gm, '<div style="margin-left: 20px; white-space: normal; word-wrap: break-word; word-break: normal; hyphens: none;">• $1</div>');
        
        messageDiv.innerHTML = content;
      }
      
      function processMarkdownFormatting(messageDiv) {
        let content = messageDiv.innerHTML;
        
        // Process markdown formatting
        // Bold text
        content = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // Italic text
        content = content.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        // Numbered lists
        content = content.replace(/^(\d+\.\s+)(.*)$/gm, '<div style="margin-left: 20px; white-space: normal; word-wrap: break-word; word-break: normal; hyphens: none;"><strong>$1</strong>$2</div>');
        
        // Bullet points
        content = content.replace(/^[-*]\s+(.*)$/gm, '<div style="margin-left: 20px; white-space: normal; word-wrap: break-word; word-break: normal; hyphens: none;">• $1</div>');
        
        // Inline code (but not code blocks) - only single backticks
        // Make sure we don't match triple backticks (```)
        content = content.replace(/(?<!`)`([^`]+)`(?!`)/g, '<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">$1</code>');
        
        messageDiv.innerHTML = content;
      }
      
      function finishStreaming() {
        console.log("DEBUG: finishStreaming called");
        if (currentStreamingMessage) {
          console.log("DEBUG: Processing final message for formatting");
          
          // Store the complete message for potential R code detection
          const content = currentStreamingMessage.innerHTML;
          window.lastCompleteMessage = content;
          console.log("DEBUG: Stored complete message:", content.substring(0, 100) + "...");
          
          // Check if this is a plot analysis message (has plot analysis content)
          const isPlotAnalysis = content.includes("plot") || content.includes("histogram") || 
                                content.includes("scatter") || content.includes("boxplot") ||
                                content.includes("density") || content.includes("violin") ||
                                content.includes("correlation") || content.includes("outlier");
          
          if (isPlotAnalysis) {
            // Use plot analysis specific processing (no Execute & Fix button)
            processPlotAnalysisContent(currentStreamingMessage);
          } else {
            // Use regular processing for code blocks and buttons
            processMessageContent(currentStreamingMessage);
          }
          
          currentStreamingMessage = null;
        }
        
        // Clear custom analysis flags if they were set
        if (window.customStatisticalAnalysisInProgress) {
          console.log('🔍 Custom statistical analysis completed, clearing flag');
          window.customStatisticalAnalysisInProgress = false;
        }
        if (window.customTransformationInProgress) {
          console.log('🔍 Custom transformation completed, clearing flag');
          window.customTransformationInProgress = false;
        }
        
        if (streamingTimeout) {
          clearTimeout(streamingTimeout);
          streamingTimeout = null;
        }
        
        // Check if there's a pending agent code request and send it
        if (window.pendingAgentCodeRequest) {
          console.log('🔍 Sending pending agent code request...');
          const request = window.pendingAgentCodeRequest;
          
          // Add informative message to let user know code generation is starting
          const agentTypeDisplay = request.agentType.charAt(0).toUpperCase() + request.agentType.slice(1);
          addMessage(`🔄 **Generating ${agentTypeDisplay} Code...** Now requesting executable R code based on the analysis above.`, 'ai');
          
          // Add a small delay to let user read the message before sending the code request
          setTimeout(() => {
            let codeText = `Data ${request.operationType} steps output:
${request.agentResults.map(result => `
${result.description}:
${result.output}
`).join('\n')}

Previous Claude chat summary:
[Your analysis above]

IMPORTANT: Use the EXACT methods selected by the user:`;

          if (request.agentType === 'modeling') {
            // Modeling agent specific instructions
            codeText += `\n\nModeling Configuration:
- Target Variable: ${request.currentAgentWorkflow?.targetVariable}
- Selected Algorithms: ${Object.entries(request.currentAgentWorkflow?.algorithms || {})
  .filter(([key, value]) => value)
  .map(([key, value]) => key)
  .join(', ')}

Provide R code to:
1. Train the selected models
2. Evaluate model performance
3. Generate predictions
4. Create visualizations for model interpretation

Code only. Minimal chat.`;
          } else if (request.agentType === 'statistical') {
            // Statistical agent specific instructions
            const selectedOps = [];
            if (request.currentAgentWorkflow?.analysisOptions?.basicStatistics) selectedOps.push('Basic Statistics & Distributions');
            if (request.currentAgentWorkflow?.analysisOptions?.groupComparisons) selectedOps.push('Group Comparisons');
            if (request.currentAgentWorkflow?.analysisOptions?.categoricalTests) selectedOps.push('Categorical Tests');
            if (request.currentAgentWorkflow?.analysisOptions?.beforeAfterAnalysis) selectedOps.push('Before/After Analysis');
            if (request.currentAgentWorkflow?.analysisOptions?.effectSizeAnalysis) selectedOps.push('Effect Size Analysis');
            if (request.currentAgentWorkflow?.analysisOptions?.powerAnalysis) selectedOps.push('Power Analysis');
            if (request.currentAgentWorkflow?.analysisOptions?.multipleTestingCorrection) selectedOps.push('Multiple Testing Correction');
            
            codeText += `\n\nStatistical Analysis Configuration:
- Dataset: ${request.currentAgentWorkflow?.dataframe}
- Selected Operations: ${selectedOps.join(', ')}

Provide R code to:
1. Reproduce the statistical analyses shown above
2. Create informative visualizations (histograms, boxplots, qq-plots, etc.)
3. Generate summary tables and reports
4. Save key results as variables for further use

Include comments explaining each step. Code only. Minimal chat.`;
          } else if (request.agentType === 'transformation') {
            // Transformation agent specific instructions
            const selectedOps = [];
            if (request.currentAgentWorkflow?.transformationOptions?.dataTypes) selectedOps.push('Data Types');
            if (request.currentAgentWorkflow?.transformationOptions?.missingValues) selectedOps.push('Missing Values');
            if (request.currentAgentWorkflow?.transformationOptions?.duplicates) selectedOps.push('Duplicates');
            if (request.currentAgentWorkflow?.transformationOptions?.outliers) selectedOps.push('Outliers');
            if (request.currentAgentWorkflow?.transformationOptions?.columnNames) selectedOps.push('Column Names');
            if (request.currentAgentWorkflow?.transformationOptions?.mathematicalTransformations) selectedOps.push('Mathematical Transformations');
            if (request.currentAgentWorkflow?.transformationOptions?.mergingCombining) selectedOps.push('Merging & Combining');
            if (request.currentAgentWorkflow?.transformationOptions?.aggregationGrouping) selectedOps.push('Aggregation & Grouping');
            if (request.currentAgentWorkflow?.transformationOptions?.statisticalTransformations) selectedOps.push('Statistical Transformations');
            if (request.currentAgentWorkflow?.transformationOptions?.textTransformations) selectedOps.push('Text Transformations');
            if (request.currentAgentWorkflow?.transformationOptions?.spatialTransformations) selectedOps.push('Spatial Transformations');
            if (request.currentAgentWorkflow?.transformationOptions?.customTransformations) selectedOps.push('Custom Transformations');
            
            codeText += `\n\nData Transformation Configuration:
- Dataset: ${request.currentAgentWorkflow?.dataframe}
- Selected Operations: ${selectedOps.join(', ')}

Provide R code to:
1. Apply the data transformations shown above
2. Create a cleaned/transformed version of the dataset
3. Generate data quality reports and summaries
4. Save the transformed dataset with a clear name (e.g., ${request.currentAgentWorkflow?.dataframe}_transformed)

Include comments explaining each transformation step. Code only. Minimal chat.`;
          } else {
            // Cleaning/transformation agent instructions
            codeText += `\n\n${request.currentAgentWorkflow?.methodOptions?.outliers === 'zscore' ? '- Handle outliers using Z-Score method (3σ threshold)\n' : ''}${request.currentAgentWorkflow?.methodOptions?.outliers === 'modified_zscore' ? '- Handle outliers using Modified Z-Score method (3.5 MAD)\n' : ''}${request.currentAgentWorkflow?.methodOptions?.outliers === 'iqr' ? '- Handle outliers using IQR method (1.5x multiplier)\n' : ''}${request.currentAgentWorkflow?.methodOptions?.outliers === 'other' ? `- Handle outliers using custom method: ${request.currentAgentWorkflow?.customInputs?.outliers || 'user specified'}\n` : ''}

${request.currentAgentWorkflow?.methodOptions?.columnNames === 'camelCase' ? '- Convert column names to camelCase format\n' : ''}${request.currentAgentWorkflow?.methodOptions?.columnNames === 'PascalCase' ? '- Convert column names to PascalCase format\n' : ''}${request.currentAgentWorkflow?.methodOptions?.columnNames === 'lowercase' ? '- Convert column names to lowercase format\n' : ''}${request.currentAgentWorkflow?.methodOptions?.columnNames === 'UPPERCASE' ? '- Convert column names to UPPERCASE format\n' : ''}${request.currentAgentWorkflow?.methodOptions?.columnNames === 'snake_case' ? '- Convert column names to snake_case format\n' : ''}${request.currentAgentWorkflow?.columnNames === 'other' ? `- Convert column names using custom convention: ${request.currentAgentWorkflow?.customInputs?.columnNames || 'user specified'}\n` : ''}

${request.agentResults.some(r => r.output.includes('duplicate')) ? '- Remove duplicate records\n' : ''}
- Create cleaned version: ${request.currentAgentWorkflow?.dataframe}_cleaned

Code only. Minimal chat.`;
          }
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            // Set AI responding flag for the second message
            isAIResponding = true;
            
            ws.send(JSON.stringify({
              action: 'chat_with_ai',
              message: codeText,
              conversation_context: `data_${request.agentType}_agent_code`
            }));
          }
          
            // Clear the pending request
            window.pendingAgentCodeRequest = null;
            
            // Don't reset the button yet - wait for the second response to complete
          }, 1500); // Wait 1.5 seconds for user to read the message
          
          return;
        }
        
        // Transform stop button back to send button when streaming finishes
        if (isAIResponding) {
          transformToSendButton();
        }
      }
      
      // Dynamic resize function for chat container
      function resizeChatContainer() {
        const chatContainer = document.getElementById("chat-container");
        if (chatContainer) {
          const viewportHeight = window.innerHeight;
          const availableHeight = viewportHeight - 250; // Account for header, input, margins
          chatContainer.style.height = Math.max(250, Math.min(availableHeight, viewportHeight * 0.6)) + "px";
        }
      }
      
      // Add resize listener
      window.addEventListener('resize', resizeChatContainer);
      
      // Initial resize
      document.addEventListener('DOMContentLoaded', resizeChatContainer);
      

      
      function processMessageContent(messageDiv) {
        const content = messageDiv.innerHTML;
        
        console.log("DEBUG: Processing content for code blocks:", content.substring(0, 200) + "...");
        
        // More precise code block detection - only create blocks for actual code blocks, not inline code
        const hasMarkdownCodeBlock = /```[rR]\n[\s\S]*?```/.test(content) || /```[rR][\s\S]*?```/.test(content) || /```R\n[\s\S]*?```/.test(content) || /```R[\s\S]*?```/.test(content);
        
        console.log("DEBUG: hasMarkdownCodeBlock:", hasMarkdownCodeBlock);
        // Only detect HTML code blocks that are actual blocks, not inline code
        const hasHTMLCodeBlock = /<code[^>]*>[\s\S]*?<\/code>/.test(content) && 
                                !content.includes('<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">');
        
        if (hasMarkdownCodeBlock || hasHTMLCodeBlock) {
          // Clear the message div
          messageDiv.innerHTML = "";
          
          // Try to split by markdown code blocks first
          let parts = content.split(/(```[rR]\n[\s\S]*?```)/g);
          
          // If no markdown blocks found, try HTML code blocks
          if (parts.length === 1) {
            parts = content.split(/(<code[^>]*>[\s\S]*?<\/code>)/g);
          }
          
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            
            if ((part.startsWith("```r\n") && part.endsWith("```")) || 
                (part.startsWith("```R\n") && part.endsWith("```")) ||
                (part.includes("<code") && part.includes("</code>"))) {
              // This is a code block - style it
              const codeDiv = document.createElement("div");
              codeDiv.className = "code-block";
              
              // Create header with copy button
              const headerDiv = document.createElement("div");
              headerDiv.className = "code-block-header";
              
              const languageLabel = document.createElement("span");
              languageLabel.textContent = "R Code";
              
              const actionsDiv = document.createElement("div");
              actionsDiv.className = "code-block-actions";
              
              const copyButton = document.createElement("button");
              copyButton.className = "copy-button";
              copyButton.textContent = "Copy";
              copyButton.onclick = function() {
                // Use the cleaned code for copying, not the original HTML
                copyToClipboard(cleanCode, copyButton);
              };
              
              const insertButton = document.createElement("button");
              insertButton.className = "copy-button";
              insertButton.textContent = "Insert at Cursor";
              insertButton.onclick = function() {
                insertCode(cleanCode);
              };
              
              headerDiv.appendChild(languageLabel);
              actionsDiv.appendChild(copyButton);
              actionsDiv.appendChild(insertButton);
              headerDiv.appendChild(actionsDiv);
              codeDiv.appendChild(headerDiv);
              
              // Create code content div - extract just the code
              const codeContent = document.createElement("div");
              let cleanCode;
              if (part.startsWith("```r\n")) {
                // Markdown format - remove ```r\n at start and ``` at end
                cleanCode = part.replace(/^```r\n/, "").replace(/```$/, "");
              } else if (part.startsWith("```R\n")) {
                // Markdown format - remove ```R\n at start and ``` at end
                cleanCode = part.replace(/^```R\n/, "").replace(/```$/, "");
              } else if (part.startsWith("```r") && part.endsWith("```")) {
                // Markdown format without newline after r
                cleanCode = part.replace(/^```r/, "").replace(/```$/, "");
              } else if (part.startsWith("```R") && part.endsWith("```")) {
                // Markdown format without newline after R
                cleanCode = part.replace(/^```R/, "").replace(/```$/, "");
              } else {
                // HTML format - extract clean text from nested HTML
                // Create a temporary div to parse HTML and extract text
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = part;
                cleanCode = tempDiv.textContent || tempDiv.innerText || '';
                
                // If that didn't work, try manual removal
                if (!cleanCode || cleanCode.trim() === '') {
                  cleanCode = part.replace(/<code[^>]*>/g, "").replace(/<\/code>/g, "");
                  cleanCode = cleanCode.replace(/<[^>]*>/g, "");
                  cleanCode = cleanCode.replace(/style="[^"]*"/g, "");
                }
              }
              
              // Remove any remaining artifacts like single quotes or language identifiers
              cleanCode = cleanCode.replace(/^['"]?r['"]?\s*/, ""); // Remove 'r', "r", or r at start
              cleanCode = cleanCode.replace(/^\s*['"]?r['"]?\s*/, ""); // Remove with whitespace
              
              // Remove any remaining "R" at the start
              cleanCode = cleanCode.replace(/^R\s*/, "");
              cleanCode = cleanCode.replace(/^r\s*/, "");
              
              // Decode HTML entities
              cleanCode = cleanCode.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
              
              codeContent.textContent = cleanCode;
              codeDiv.appendChild(codeContent);
              
              messageDiv.appendChild(codeDiv);
            } else if (part.trim()) {
              // This is regular text - clean up any leftover backticks and add it
              const textDiv = document.createElement("div");
              let cleanText = part;
              
              // Remove any leftover backticks from markdown processing
              cleanText = cleanText.replace(/^``\s*/, ""); // Remove leading backticks
              cleanText = cleanText.replace(/\s*``$/, ""); // Remove trailing backticks
              cleanText = cleanText.replace(/``/g, ""); // Remove any remaining backticks
              
              textDiv.innerHTML = cleanText;
              // Apply markdown formatting to the text part
              processMarkdownFormatting(textDiv);
              messageDiv.appendChild(textDiv);
            }
          }
          
          return;
        }
        
        console.log("DEBUG: No code blocks found, processing markdown");
        // If no code blocks, just process markdown formatting
        processMarkdownFormatting(messageDiv);
      }
      
      function addMessage(content, role) {
        const container = document.getElementById("chat-container");
        const messageDiv = document.createElement("div");
        messageDiv.className = "message " + role + "-message";
        
        if (role === "ai") {
          // More precise code block detection - only for actual R code blocks
          if (content.includes("```r") || content.includes("```R")) {
            const start = content.indexOf("```");
            const end = content.lastIndexOf("```");
            if (start !== -1 && end !== -1 && end > start) {
              const beforeCode = content.substring(0, start);
              const codeBlock = content.substring(start + 3, end);
              const afterCode = content.substring(end + 3);
              
              // Add text before code
              if (beforeCode.trim()) {
                const textDiv = document.createElement("div");
                textDiv.textContent = beforeCode;
                messageDiv.appendChild(textDiv);
              }
              
              // Add code block
              const codeDiv = document.createElement("div");
              codeDiv.className = "code-block";
              
              // Create header with copy button
              const headerDiv = document.createElement("div");
              headerDiv.className = "code-block-header";
              
              const languageLabel = document.createElement("span");
              languageLabel.textContent = "R Code";
              
              // Clean up the code block - remove {r} and other prefixes
              let cleanCode = codeBlock;
              // Remove common prefixes
              if (cleanCode.startsWith("{r}")) {
                cleanCode = cleanCode.substring(3);
              } else if (cleanCode.startsWith("r}")) {
                cleanCode = cleanCode.substring(2);
              } else if (cleanCode.startsWith("r")) {
                cleanCode = cleanCode.substring(1);
              } else if (cleanCode.startsWith("```r")) {
                cleanCode = cleanCode.substring(4);
              } else if (cleanCode.startsWith("```")) {
                cleanCode = cleanCode.substring(3);
              }
              
              // Remove any remaining "R" at the start
              cleanCode = cleanCode.replace(/^R\s*/, "");
              cleanCode = cleanCode.replace(/^r\s*/, "");
              
              // Decode HTML entities
              cleanCode = cleanCode.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
              cleanCode = cleanCode.trim();
              
              const copyButton = document.createElement("button");
              copyButton.className = "copy-button";
              copyButton.textContent = "Copy";
              copyButton.onclick = function() {
                copyToClipboard(cleanCode, copyButton);
              };
              
              headerDiv.appendChild(languageLabel);
              headerDiv.appendChild(copyButton);
              codeDiv.appendChild(headerDiv);
              
              codeDiv.textContent = cleanCode;
              
              // Add buttons
              const buttonContainer = document.createElement("div");
              buttonContainer.style.marginTop = "10px";
              
              const insertButton = document.createElement("button");
              insertButton.className = "insert-button";
              insertButton.textContent = "Insert";
              insertButton.onclick = function() {
                insertCode(cleanCode);
              };
              
              const executeButton = document.createElement("button");
              executeButton.className = "insert-button";
              executeButton.style.backgroundColor = "#17a2b8";
              executeButton.textContent = "Execute & Fix";
              executeButton.onclick = function() {
                executeAndFix(cleanCode);
              };
              
              buttonContainer.appendChild(insertButton);
              buttonContainer.appendChild(executeButton);
              
              messageDiv.appendChild(codeDiv);
              messageDiv.appendChild(buttonContainer);
              
              // Add text after code
              if (afterCode.trim()) {
                const textDiv = document.createElement("div");
                let cleanText = afterCode;
                
                // Remove any leftover backticks from markdown processing
                cleanText = cleanText.replace(/^``\s*/, ""); // Remove leading backticks
                cleanText = cleanText.replace(/\s*``$/, ""); // Remove trailing backticks
                cleanText = cleanText.replace(/``/g, ""); // Remove any remaining backticks
                
                textDiv.textContent = cleanText;
                messageDiv.appendChild(textDiv);
              }
            } else {
              messageDiv.innerHTML = content;
              processMarkdownFormatting(messageDiv);
            }
          } else {
            messageDiv.innerHTML = content;
            processMarkdownFormatting(messageDiv);
          }
        } else {
          messageDiv.innerHTML = content;
          processMarkdownFormatting(messageDiv);
        }
        
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
      }
      
      // Specialized function for visualization agent messages with image support
      function addVisualizationMessage(content, role) {
        const container = document.getElementById("chat-container");
        const messageDiv = document.createElement("div");
        messageDiv.className = "message " + role + "-message";
        
        if (content.includes("data:image/png;base64,")) {
          // Handle mixed content (text + images)
          const parts = content.split(/(data:image\/png;base64,[A-Za-z0-9+/=]+)/);
          
          parts.forEach(part => {
            if (part.startsWith('data:image/png;base64,')) {
              // Create image element
              const img = document.createElement('img');
              console.log('🎨 Creating image with data URL length:', part.length);
              console.log('🎨 Data URL preview:', part.substring(0, 100) + '...');
              img.src = part;
              img.style.maxWidth = '100%';
              img.style.height = 'auto';
              img.style.borderRadius = '8px';
              img.style.margin = '10px 0';
              img.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
              img.style.border = '1px solid #e0e0e0';
              messageDiv.appendChild(img);
            } else if (part.trim()) {
              // Add text content with markdown support
              const textDiv = document.createElement('div');
              textDiv.innerHTML = part.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
              messageDiv.appendChild(textDiv);
            }
          });
        } else {
          // Use original addMessage logic for non-image content
          return addMessage(content, role);
        }
        
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
      }
      
      function insertCode(code) {
        if (!isConnected) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Send insert request via WebSocket
        ws.send(JSON.stringify({
          action: "insert_code",
          code: code
        }));
      }
      
      function executeAndFix(code) {
        if (!isConnected) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Send execute and fix request via WebSocket
        ws.send(JSON.stringify({
          action: "execute_and_fix",
          code: code
        }));
      }
      
      function newConversation() {
        if (!isConnected) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Clear the chat container
        const container = document.getElementById("chat-container");
        container.innerHTML = '<div class="message ai-message">🔄 New conversation started. Your R workspace context is still available!</div>';
        
        // Send new conversation request to clear history on backend
        ws.send(JSON.stringify({
          action: "new_conversation"
        }));
        
        // Clear the input field
        document.getElementById("user-input").value = "";
        
        // Scroll to bottom
        container.scrollTop = container.scrollHeight;
        
        // Switch back to chat tab if not already there
        const chatTab = document.getElementById("chat-tab");
        if (!chatTab.classList.contains("active")) {
          // Hide all tab contents
          document.querySelectorAll('.tab-content').forEach(tab => {
            tab.classList.remove('active');
          });
          
          // Remove active class from all tab buttons
          document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
          });
          
          // Show chat tab content
          document.getElementById("chat-tab").classList.add("active");
          
          // Add active class to chat button
          document.querySelector('.tab-btn[onclick="switchTab(\'chat\')"]').classList.add('active');
        }
      }
      
      function applyDebugFix(lineNumber, newCode) {
        if (!isConnected) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Send the fix to be applied
        ws.send(JSON.stringify({
          action: "apply_debug_fix",
          line_number: lineNumber,
          new_code: newCode
        }));
        
        addMessage(`✅ Applying fix to line ${lineNumber}...`, "user");
      }
      
      function declineDebugFix() {
        addMessage("❌ Fix declined", "user");
      }
      
      // Handle Enter key
      document.getElementById("user-input").addEventListener("keypress", function(e) {
        if (e.key === "Enter") {
          sendMessage();
        }
      });
      
      // Handle Enter key for access code
      document.getElementById("access-code").addEventListener("keypress", function(e) {
        if (e.key === "Enter") {
          validateAccess();
        }
      });
      
      // Add password toggle functionality for access code
      document.getElementById('toggleAccessCode').addEventListener('click', function() {
        const accessCodeInput = document.getElementById('access-code');
        const toggleButton = this;
        
        if (accessCodeInput.type === 'password') {
          accessCodeInput.type = 'text';
          toggleButton.textContent = 'Hide';
          toggleButton.title = 'Hide access code';
        } else {
          accessCodeInput.type = 'password';
          toggleButton.textContent = 'Show';
          toggleButton.title = 'Show access code';
        }
      });
      
      // Apply RStudio theme with actual colors
      function applyTheme(isDark, themeName, colors = {}) {
        console.log("Applying theme:", isDark ? "dark" : "light", "Theme:", themeName);
        console.log("RStudio colors:", colors);
        
        const root = document.documentElement;
        
        if (colors && Object.keys(colors).length > 0) {
          // Use actual RStudio colors
          root.style.setProperty('--bg-primary', colors.background || (isDark ? '#1e1e1e' : '#ffffff'));
          root.style.setProperty('--bg-secondary', colors.console_background || (isDark ? '#2d2d2d' : '#f8f9fa'));
          root.style.setProperty('--bg-card', colors.console_background || (isDark ? '#3c3c3c' : '#ffffff'));
          root.style.setProperty('--text-primary', colors.foreground || (isDark ? '#ffffff' : '#2c3e50'));
          root.style.setProperty('--text-secondary', colors.console_foreground || (isDark ? '#cccccc' : '#6c757d'));
          root.style.setProperty('--border-color', isDark ? '#555555' : '#dee2e6');
          root.style.setProperty('--input-bg', colors.console_background || (isDark ? '#2d2d2d' : '#ffffff'));
          root.style.setProperty('--code-bg', colors.background || (isDark ? '#1e1e1e' : '#f8f9fa'));
          root.style.setProperty('--rgent-primary', isDark ? '#ff8c42' : '#ff6b35');
          root.style.setProperty('--rgent-accent', isDark ? '#5dade2' : '#3498db');
        } else {
          // Fallback to basic theme detection
          if (isDark) {
            // Dark theme
            root.style.setProperty('--bg-primary', '#1e1e1e');
            root.style.setProperty('--bg-secondary', '#2d2d2d');
            root.style.setProperty('--bg-card', '#3c3c3c');
            root.style.setProperty('--text-primary', '#ffffff');
            root.style.setProperty('--text-secondary', '#cccccc');
            root.style.setProperty('--border-color', '#555555');
            root.style.setProperty('--input-bg', '#2d2d2d');
            root.style.setProperty('--code-bg', '#1e1e1e');
            root.style.setProperty('--rgent-primary', '#ff8c42');
            root.style.setProperty('--rgent-accent', '#5dade2');
          } else {
            // Light theme
            root.style.setProperty('--bg-primary', '#ffffff');
            root.style.setProperty('--bg-secondary', '#f8f9fa');
            root.style.setProperty('--bg-card', '#ffffff');
            root.style.setProperty('--text-primary', '#2c3e50');
            root.style.setProperty('--text-secondary', '#6c757d');
            root.style.setProperty('--border-color', '#dee2e6');
            root.style.setProperty('--input-bg', '#ffffff');
            root.style.setProperty('--code-bg', '#f8f9fa');
            root.style.setProperty('--rgent-primary', '#ff6b35');
            root.style.setProperty('--rgent-accent', '#3498db');
          }
        }
        
        // Apply theme to body
        document.body.classList.toggle('dark-theme', isDark);
        document.body.classList.toggle('light-theme', !isDark);
      }
      
      // Early theme detection on page load
      function detectInitialTheme() {
        // Check if user prefers dark mode
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        console.log("Initial theme detection:", prefersDark ? "dark" : "light");
        
        // Apply basic theme immediately
        applyTheme(prefersDark, "System Theme");
      }
      
      // Call early theme detection when page loads
      document.addEventListener('DOMContentLoaded', detectInitialTheme);
      
      // Analyze Last Plot functionality
      function analyzeLastPlot() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Add initial message showing we're starting analysis
        addMessage("**Starting Plot Analysis:**\n\nStep 1: Scanning R history for plot commands:", "ai");
        
        // Send the analyze request
        ws.send(JSON.stringify({
          action: "analyze_last_plot"
        }));
        

      }
      
      // Special function for plot analysis messages
      function addPlotAnalysisMessage(content) {
        const container = document.getElementById("chat-container");
        const messageDiv = document.createElement("div");
        messageDiv.className = "message ai-message";
        
        // Set the content and process it properly
        messageDiv.innerHTML = content;
        
        // Process markdown formatting first
        processMarkdownFormatting(messageDiv);
        
        // Then process for code blocks with only Copy/Insert buttons
        processPlotAnalysisContent(messageDiv);
        
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
      }
      
      // Special processing for plot analysis content (no Execute & Fix)
      function processPlotAnalysisContent(messageDiv) {
        const content = messageDiv.innerHTML;
        
        // More precise code block detection - only create blocks for actual code blocks
        const hasMarkdownCodeBlock = /```[rR]\n[\s\S]*?```/.test(content) || /```[rR][\s\S]*?```/.test(content) || /```R\n[\s\S]*?```/.test(content) || /```R[\s\S]*?```/.test(content);
        
        // Only detect HTML code blocks that are actual blocks, not inline code
        const hasHTMLCodeBlock = /<code[^>]*>[\s\S]*?<\/code>/.test(content) && 
                                !content.includes('<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">');
        
        if (hasMarkdownCodeBlock || hasHTMLCodeBlock) {
          // Clear the message div
          messageDiv.innerHTML = "";
          
          // Try to split by markdown code blocks first
          let parts = content.split(/(```[rR]\n[\s\S]*?```)/g);
          
          // If no markdown blocks found, try HTML code blocks
          if (parts.length === 1) {
            parts = content.split(/(<code[^>]*>[\s\S]*?<\/code>)/g);
          }
          
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            
            if ((part.startsWith("```r\n") && part.endsWith("```")) || 
                (part.startsWith("```R\n") && part.endsWith("```")) ||
                (part.includes("<code") && part.includes("</code>"))) {
              // This is a code block - style it with only Copy/Insert buttons
              const codeDiv = document.createElement("div");
              codeDiv.className = "code-block";
              
              // Create header with copy button
              const headerDiv = document.createElement("div");
              headerDiv.className = "code-block-header";
              
              const languageLabel = document.createElement("span");
              languageLabel.textContent = "R Code";
              
              const actionsDiv = document.createElement("div");
              actionsDiv.className = "code-block-actions";
              
              const copyButton = document.createElement("button");
              copyButton.className = "copy-button";
              copyButton.textContent = "Copy";
              copyButton.onclick = function() {
                copyToClipboard(cleanCode, copyButton);
              };
              
              const insertButton = document.createElement("button");
              insertButton.className = "copy-button";
              insertButton.textContent = "Insert at Cursor";
              insertButton.onclick = function() {
                insertCode(cleanCode);
              };
              
              headerDiv.appendChild(languageLabel);
              actionsDiv.appendChild(copyButton);
              actionsDiv.appendChild(insertButton);
              headerDiv.appendChild(actionsDiv);
              codeDiv.appendChild(headerDiv);
              
              // Create code content div - extract just the code
              const codeContent = document.createElement("div");
              let cleanCode;
              if (part.startsWith("```r\n")) {
                // Markdown format - remove ```r\n at start and ``` at end
                cleanCode = part.replace(/^```r\n/, "").replace(/```$/, "");
              } else if (part.startsWith("```R\n")) {
                // Markdown format - remove ```R\n at start and ``` at end
                cleanCode = part.replace(/^```R\n/, "").replace(/```$/, "");
              } else if (part.startsWith("```r") && part.endsWith("```")) {
                // Markdown format without newline after r
                cleanCode = part.replace(/^```r/, "").replace(/```$/, "");
              } else if (part.startsWith("```R") && part.endsWith("```")) {
                // Markdown format without newline after R
                cleanCode = part.replace(/^```R/, "").replace(/```$/, "");
              } else {
                // HTML format - extract clean text from nested HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = part;
                cleanCode = tempDiv.textContent || tempDiv.innerText || '';
                
                // If that didn't work, try manual removal
                if (!cleanCode || cleanCode.trim() === '') {
                  cleanCode = part.replace(/<code[^>]*>/g, "").replace(/<\/code>/g, "");
                  cleanCode = cleanCode.replace(/<[^>]*>/g, "");
                  cleanCode = cleanCode.replace(/style="[^"]*"/g, "");
                }
              }
              
              // Remove any remaining artifacts
              cleanCode = cleanCode.replace(/^['"]?r['"]?\s*/, "");
              cleanCode = cleanCode.replace(/^\s*['"]?r['"]?\s*/, "");
              cleanCode = cleanCode.replace(/^R\s*/, "");
              cleanCode = cleanCode.replace(/^r\s*/, "");
              cleanCode = cleanCode.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
              
              codeContent.textContent = cleanCode;
              codeDiv.appendChild(codeContent);
              
              messageDiv.appendChild(codeDiv);
            } else if (part.trim()) {
              // This is regular text - clean up any leftover backticks and add it
              const textDiv = document.createElement("div");
              let cleanText = part;
              
              // Remove any leftover backticks from markdown processing
              cleanText = cleanText.replace(/^``\s*/, "");
              cleanText = cleanText.replace(/\s*``$/, "");
              cleanText = cleanText.replace(/``/g, "");
              
              textDiv.innerHTML = cleanText;
              processMarkdownFormatting(textDiv);
              messageDiv.appendChild(textDiv);
            }
          }
        } else {
          // If no code blocks, just process markdown formatting
          processMarkdownFormatting(messageDiv);
        }
      }
      
      // ===== AGENT FUNCTIONS =====
      
      // Enable agents tab when connected
      function enableAgentsTab() {
        const agentsTabBtn = document.getElementById('agents-tab-btn');
        if (agentsTabBtn) {
          agentsTabBtn.style.display = 'block';
        }
      }
      
      // Switch tabs (including agents)
      function switchTab(tabName) {
        // Hide all tabs
        const tabs = document.querySelectorAll('.tab-content');
        const buttons = document.querySelectorAll('.tab-btn');
        
        tabs.forEach(tab => tab.classList.remove('active'));
        buttons.forEach(btn => btn.classList.remove('active'));
        
        // Show selected tab
        const selectedTab = document.getElementById(tabName + '-tab');
        const selectedButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
        
        if (selectedTab) selectedTab.classList.add('active');
        if (selectedButton) selectedButton.classList.add('active');
        
        // Special handling for agents tab
        if (tabName === 'agents') {
          showAgentSelection();
        }
        
        // Special handling for usage tab
        if (tabName === 'usage') {
          loadStats();
        }
      }
      
      // Show agent selection view
      function showAgentSelection() {
        document.getElementById('agent-selection').style.display = 'flex';
        document.getElementById('cleaning-config').style.display = 'none';
        document.getElementById('transformation-config').style.display = 'none';
        document.getElementById('statistical-config').style.display = 'none';
        document.getElementById('modeling-config').style.display = 'none';
        
        // Reset the header and prompt to default
        const header = document.getElementById('agents-main-header');
        const prompt = document.getElementById('agent-selection-prompt');
        const backBtn = document.getElementById('back-to-agents-btn');
        if (header) {
          header.textContent = '🤖 AI Agents';
        }
        if (prompt) {
          prompt.textContent = 'Select an agent to get started';
          prompt.style.display = 'block';
        }
        if (backBtn) {
          backBtn.style.display = 'none';
        }
      }
      
      // Select an agent
      function selectAgent(agentType) {
        // Update the main header with the selected agent name
        const header = document.getElementById('agents-main-header');
        const prompt = document.getElementById('agent-selection-prompt');
        const backBtn = document.getElementById('back-to-agents-btn');
        
        if (agentType === 'cleaning') {
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('cleaning-config').style.display = 'block';
          header.textContent = '🧹 Data Cleaning Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          loadDataFramesMain();
        } else if (agentType === 'transformation') {
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('transformation-config').style.display = 'block';
          header.textContent = '🔄 Data Transformation Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          loadTransformationDataFrames();
          
          // Set up transformation agent checkbox interactions
          setupTransformationCheckboxInteractions();
          // FIXED: Add missing event listener setup
          addTransformationOptionListeners();
        } else if (agentType === 'statistical') {
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('statistical-config').style.display = 'block';
          header.textContent = '📊 Statistical Analysis Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          loadStatisticalDataFrames();
          
          // Set up statistical agent checkbox interactions
          setupStatisticalCheckboxInteractions();
          // Add event listener setup
          addStatisticalOptionListeners();
        } else if (agentType === 'modeling') {
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('modeling-config').style.display = 'block';
          header.textContent = '🤖 Modeling Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          loadModelingDataFrames();
          
          // Set up modeling agent checkbox interactions
          setupModelingCheckboxInteractions();
          // Add event listener setup
          addModelingOptionListeners();
        } else if (agentType === 'visualization') {
          console.log('🎨 Setting up visualization agent...');
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('visualization-config').style.display = 'block';
          header.textContent = '🎨 Visualization Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          
          // Load dataframes for visualization
          loadVisualizationDataFrames();
        }
      }
      
      // Load available DataFrames for main config
      function loadDataFramesMain() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Load available DataFrames for transformation config
      function loadTransformationDataFrames() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Load available DataFrames for statistical config
      function loadStatisticalDataFrames() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Load available DataFrames for modeling config
      function loadModelingDataFrames() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Update DataFrame info when selection changes
      function updateDataFrameInfo() {
        const select = document.getElementById('dataframe-select');
        const selectedDF = select.value;
        const infoDiv = document.getElementById('dataframe-info');
        const startBtn = document.getElementById('start-cleaning-btn');
        
        if (selectedDF) {
          // Request DataFrame info from R
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: selectedDF
            }));
          }
          startBtn.disabled = false;
        } else {
          infoDiv.style.display = 'none';
          startBtn.disabled = true;
        }
      }
      
      // Start cleaning agent
      function startCleaningAgent() {
        const dataframe = document.getElementById('dataframe-select').value;
        const naHandling = document.querySelector('input[name="na-handling"]:checked').value;
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        // Close modal
        closeAgentConfigModal();
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // Send agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_cleaning_agent',
            dataframe: dataframe,
            na_handling: naHandling
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
        }
      }
      
      // Start statistical analysis agent
      function startStatisticalAgent() {
        console.log('📊 Starting statistical analysis agent...');
        const dataframe = document.getElementById('statistical-dataframe-select').value;
        
        console.log('🔍 Selected dataframe:', dataframe);
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        // Collect statistical analysis options
        const analysisOptions = {
          basicStatistics: document.getElementById('check-basic-statistics').checked,
          groupComparisons: document.getElementById('check-group-comparisons').checked,
          categoricalTests: document.getElementById('check-categorical-tests').checked,
          beforeAfterAnalysis: document.getElementById('check-before-after-analysis').checked,
          effectSizeAnalysis: document.getElementById('check-effect-size-analysis').checked,
          powerAnalysis: document.getElementById('check-power-analysis').checked,
          multipleTestingCorrection: document.getElementById('check-multiple-testing-correction').checked,
          customStatisticalAnalysis: document.getElementById('check-custom-statistical-analysis').checked
        };
        
        // Check if at least one option is selected
        if (!Object.values(analysisOptions).some(option => option)) {
          alert('Please select at least one statistical analysis type');
          return;
        }
        
        // Collect method options and variables
        const methodOptions = {};
        const variables = {};
        const customInputs = {};
        
        // Group comparisons
        if (analysisOptions.groupComparisons) {
          const groupCompSelect = document.getElementById('group-comparisons-select');
          methodOptions.groupComparisons = groupCompSelect.value;
          
          if (groupCompSelect.value === 'other') {
            customInputs.groupComparisons = document.getElementById('group-comparisons-custom-input').value.trim();
            if (!customInputs.groupComparisons) {
              alert('Please specify custom group comparison test');
              return;
            }
          }
          
          const continuousVar = document.getElementById('statistical-continuous-var').value;
          const groupingVar = document.getElementById('statistical-grouping-var').value;
          
          if (!continuousVar || !groupingVar) {
            alert('Please select both continuous and grouping variables for group comparisons');
            return;
          }
          
          variables.continuous_variable = continuousVar;
          variables.grouping_variable = groupingVar;
        }
        
        // Before/after analysis
        if (analysisOptions.beforeAfterAnalysis) {
          const beforeAfterSelect = document.getElementById('before-after-select');
          methodOptions.beforeAfterAnalysis = beforeAfterSelect.value;
          
          if (beforeAfterSelect.value === 'other') {
            customInputs.beforeAfterAnalysis = document.getElementById('before-after-custom-input').value.trim();
            if (!customInputs.beforeAfterAnalysis) {
              alert('Please specify custom before/after analysis');
              return;
            }
          }
          
          const beforeVar = document.getElementById('statistical-before-var').value;
          const afterVar = document.getElementById('statistical-after-var').value;
          
          if (!beforeVar || !afterVar) {
            alert('Please select both before and after variables for before/after analysis');
            return;
          }
          
          variables.before_variable = beforeVar;
          variables.after_variable = afterVar;
        }
        
        // Power analysis
        if (analysisOptions.powerAnalysis) {
          const powerSelect = document.getElementById('power-analysis-select');
          methodOptions.powerAnalysis = powerSelect.value;
          
          if (powerSelect.value === 'other') {
            customInputs.powerAnalysis = document.getElementById('power-analysis-custom-input').value.trim();
            if (!customInputs.powerAnalysis) {
              alert('Please specify custom power level');
              return;
            }
          }
        }
        

        
        // Categorical tests
        if (analysisOptions.categoricalTests) {
          const categoricalSelect = document.getElementById('categorical-tests-select');
          methodOptions.categoricalTests = categoricalSelect.value;
          
          if (categoricalSelect.value === 'other') {
            customInputs.categoricalTests = document.getElementById('categorical-tests-custom-input').value.trim();
            if (!customInputs.categoricalTests) {
              alert('Please specify custom categorical test');
              return;
            }
          }
          
          const catVar1 = document.getElementById('categorical-var1').value;
          const catVar2 = document.getElementById('categorical-var2').value;
          
          if (!catVar1 || !catVar2) {
            alert('Please select both categorical variables for categorical tests');
            return;
          }
          
          variables.categorical_variable1 = catVar1;
          variables.categorical_variable2 = catVar2;
        }
        
        // Effect size analysis
        if (analysisOptions.effectSizeAnalysis) {
          const effectSizeSelect = document.getElementById('effect-size-select');
          methodOptions.effectSizeAnalysis = effectSizeSelect.value;
          
          if (effectSizeSelect.value === 'other') {
            customInputs.effectSizeAnalysis = document.getElementById('effect-size-custom-input').value.trim();
            if (!customInputs.effectSizeAnalysis) {
              alert('Please specify custom effect size calculation');
              return;
            }
          }
        }
        
        // Multiple testing correction
        if (analysisOptions.multipleTestingCorrection) {
          const multipleTestingSelect = document.getElementById('multiple-testing-select');
          methodOptions.multipleTestingCorrection = multipleTestingSelect.value;
          
          if (multipleTestingSelect.value === 'other') {
            customInputs.multipleTestingCorrection = document.getElementById('multiple-testing-custom-input').value.trim();
            if (!customInputs.multipleTestingCorrection) {
              alert('Please specify custom multiple testing correction method');
              return;
            }
          }
        }
        
        // Custom statistical analysis
        if (analysisOptions.customStatisticalAnalysis) {
          customInputs.customStatisticalAnalysis = document.getElementById('custom-statistical-analysis-input').value.trim();
          if (!customInputs.customStatisticalAnalysis) {
            alert('Please describe your custom statistical analysis requirements');
            return;
          }
        }
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // FIXED: Hide statistical config when switching to chat
        const statisticalConfig = document.getElementById('statistical-config');
        if (statisticalConfig) {
          statisticalConfig.style.display = 'none';
        }
        
        // Send statistical analysis agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_statistical_agent',
            dataframe: dataframe,
            analysis_options: analysisOptions,
            method_options: methodOptions,
            variables: variables,
            custom_inputs: customInputs
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          // Switch to chat tab to show the statistical analysis workflow
          switchTab('chat');
        }
      }
      
      // Start modeling agent
      function startModelingAgent() {
        console.log('🤖 Starting modeling agent...');
        const dataframe = document.getElementById('modeling-dataframe-select').value;
        const targetVariable = document.getElementById('modeling-target-variable').value;
        
        console.log('🔍 Selected dataframe:', dataframe);
        console.log('🔍 Target variable:', targetVariable);
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        if (!targetVariable) {
          alert('Please select a target variable for supervised learning');
          return;
        }
        
        // Collect modeling algorithms
        const algorithms = {
          dimensionalityReduction: document.getElementById('check-dimensionality-reduction').checked,
          linearRegression: document.getElementById('check-linear-regression').checked,
          logisticRegression: document.getElementById('check-logistic-regression').checked,
          multinomialRegression: document.getElementById('check-multinomial-regression').checked,
          randomForest: document.getElementById('check-random-forest').checked,
          xgboost: document.getElementById('check-xgboost').checked
        };
        
        // Collect additional options
        const options = {
          featureEngineering: document.getElementById('check-feature-engineering').checked,
          modelInterpretability: document.getElementById('check-model-interpretability').checked,
          claudePlots: document.getElementById('check-claude-plots').checked,
          customModeling: document.getElementById('check-custom-modeling').checked
        };
        
        // Check if at least one algorithm is selected (including custom modeling)
        const hasStandardAlgorithm = Object.values(algorithms).some(algorithm => algorithm);
        const hasCustomModeling = options.customModeling;
        
        if (!hasStandardAlgorithm && !hasCustomModeling) {
          alert('Please select at least one machine learning algorithm');
          return;
        }
        
        // Collect method options for dimensionality reduction
        if (algorithms.dimensionalityReduction) {
          const drSelect = document.getElementById('dimensionality-reduction-select');
          options.dimensionalityReductionMethod = drSelect.value;
        }
        
        // Collect custom modeling inputs
        const customInputs = {};
        if (options.customModeling) {
          customInputs.customModeling = document.getElementById('custom-modeling-input').value.trim();
          if (!customInputs.customModeling) {
            alert('Please describe your custom modeling requirements');
            return;
          }
        }
        
        // Collect selected variables
        const selectedVariables = getSelectedVariables();
        console.log('🔍 Selected variables being sent:', selectedVariables);
        
        // Send modeling agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_modeling_agent',
            dataframe: dataframe,
            target_variable: targetVariable,
            algorithms: algorithms,
            options: options,
            custom_inputs: customInputs,
            selected_variables: selectedVariables
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          // Switch to chat tab to show the modeling workflow
          switchTab('chat');
          
          // Hide modeling config when switching to chat
          const modelingConfig = document.getElementById('modeling-config');
          if (modelingConfig) {
            modelingConfig.style.display = 'none';
          }
        }
      }
      
      // Start transformation agent
      function startTransformationAgent() {
        console.log('🚀 Starting transformation agent...');
        const dataframe = document.getElementById('transformation-dataframe-select').value;
        
        console.log('🔍 Selected dataframe:', dataframe);
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        // Collect transformation options
        const transformationOptions = {
          distributionAnalysis: document.getElementById('check-distribution-analysis').checked,
          mathematicalTransformations: document.getElementById('check-mathematical-transformations').checked,
          newVariables: document.getElementById('check-new-variables').checked,
          categoricalTransformations: document.getElementById('check-categorical-transformations').checked,
          dateTimeTransformations: document.getElementById('check-datetime-transformations').checked,
          mergingCombining: document.getElementById('check-merging-combining').checked,
          aggregationGrouping: document.getElementById('check-aggregation-grouping').checked,
          statisticalTransformations: document.getElementById('check-statistical-transformations').checked,
          textTransformations: document.getElementById('check-text-transformations').checked,
          spatialTransformations: document.getElementById('check-spatial-transformations').checked,
          customTransformations: document.getElementById('check-custom-transformations').checked
        };
        
        // Check if at least one option is selected
        if (!Object.values(transformationOptions).some(option => option)) {
          alert('Please select at least one transformation operation');
          return;
        }
        
        // Collect method options and custom inputs
        const methodOptions = {};
        const customInputs = {};
        
        // Mathematical transformations
        if (transformationOptions.mathematicalTransformations) {
          const mathSelect = document.getElementById('math-transformations-select');
          methodOptions.mathematicalTransformations = mathSelect.value;
          if (mathSelect.value === 'other') {
            customInputs.mathematicalTransformations = document.getElementById('math-transformations-custom-input').value.trim();
            if (!customInputs.mathematicalTransformations) {
              alert('Please specify custom mathematical transformation');
              return;
            }
          }
        }
        
        // New variables
        if (transformationOptions.newVariables) {
          const newVarSelect = document.getElementById('new-variables-select');
          methodOptions.newVariables = newVarSelect.value;
          if (newVarSelect.value === 'other') {
            customInputs.newVariables = document.getElementById('new-variables-custom-input').value.trim();
            if (!customInputs.newVariables) {
              alert('Please specify custom variable creation');
              return;
            }
          }
        }
        
        // Categorical transformations
        if (transformationOptions.categoricalTransformations) {
          const catSelect = document.getElementById('categorical-transformations-select');
          methodOptions.categoricalTransformations = catSelect.value;
          if (catSelect.value === 'other') {
            customInputs.categoricalTransformations = document.getElementById('categorical-transformations-custom-input').value.trim();
            if (!customInputs.categoricalTransformations) {
              alert('Please specify custom categorical transformation');
              return;
            }
          }
        }
        
        // Date/time transformations
        if (transformationOptions.dateTimeTransformations) {
          const dateSelect = document.getElementById('datetime-transformations-select');
          methodOptions.dateTimeTransformations = dateSelect.value;
          if (dateSelect.value === 'other') {
            customInputs.dateTimeTransformations = document.getElementById('datetime-transformations-custom-input').value.trim();
            if (!customInputs.dateTimeTransformations) {
              alert('Please specify custom date/time transformation');
              return;
            }
          }
        }
        
        // Merging & combining
        if (transformationOptions.mergingCombining) {
          const mergeSelect = document.getElementById('merging-combining-select');
          methodOptions.mergingCombining = mergeSelect.value;
          if (mergeSelect.value === 'other') {
            customInputs.mergingCombining = document.getElementById('merging-combining-custom-input').value.trim();
            if (!customInputs.mergingCombining) {
              alert('Please specify custom merging operation');
              return;
            }
          }
        }
        
        // Aggregation & grouping
        if (transformationOptions.aggregationGrouping) {
          const aggSelect = document.getElementById('aggregation-grouping-select');
          methodOptions.aggregationGrouping = aggSelect.value;
          if (aggSelect.value === 'other') {
            customInputs.aggregationGrouping = document.getElementById('aggregation-grouping-custom-input').value.trim();
            if (!customInputs.aggregationGrouping) {
              alert('Please specify custom aggregation');
              return;
            }
          }
        }
        
        // Statistical transformations
        if (transformationOptions.statisticalTransformations) {
          const statSelect = document.getElementById('statistical-transformations-select');
          methodOptions.statisticalTransformations = statSelect.value;
          if (statSelect.value === 'other') {
            customInputs.statisticalTransformations = document.getElementById('statistical-transformations-custom-input').value.trim();
            if (!customInputs.statisticalTransformations) {
              alert('Please specify custom statistical transformation');
              return;
            }
          }
        }
        
        // Text transformations
        if (transformationOptions.textTransformations) {
          const textSelect = document.getElementById('text-transformations-select');
          methodOptions.textTransformations = textSelect.value;
          if (textSelect.value === 'other') {
            customInputs.textTransformations = document.getElementById('text-transformations-custom-input').value.trim();
            if (!customInputs.textTransformations) {
              alert('Please specify custom text transformation');
              return;
            }
          }
        }
        
        // Spatial transformations
        if (transformationOptions.spatialTransformations) {
          const spatialSelect = document.getElementById('spatial-transformations-select');
          methodOptions.spatialTransformations = spatialSelect.value;
          if (spatialSelect.value === 'other') {
            customInputs.spatialTransformations = document.getElementById('spatial-transformations-custom-input').value.trim();
            if (!customInputs.spatialTransformations) {
              alert('Please specify custom spatial transformation');
              return;
            }
          }
        }
        
        // Custom transformations
        if (transformationOptions.customTransformations) {
          customInputs.customTransformations = document.getElementById('custom-transformations-custom-input').value.trim();
          if (!customInputs.customTransformations) {
            alert('Please specify custom transformation code');
            return;
          }
        }
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // FIXED: Hide transformation config when switching to chat
        const transformationConfig = document.getElementById('transformation-config');
        if (transformationConfig) {
          transformationConfig.style.display = 'none';
        }
        
        // Collect selected variables
        const selectedVariables = getSelectedVariables();
        
        // Send transformation agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_transformation_agent',
            dataframe: dataframe,
            transformation_options: transformationOptions,
            method_options: methodOptions,
            custom_inputs: customInputs,
            selected_variables: selectedVariables
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          // Switch to chat tab to show the transformation workflow
          switchTab('chat');
        }
      }
      
      // Handle agent-related WebSocket messages - COMPLETELY NEW FUNCTION NAME
      function handleAgentMessageNEW(data) {
        console.log('🆕 NEW FUNCTION: handleAgentMessageNEW called!');
        console.log('Handling agent message:', data);
        console.log('🔍 DEBUG: handleAgentMessageNEW called with action:', data.action);
        console.log('🔄 CACHE BUST: This is the COMPLETELY NEW version!');
        console.log('🚨 FORCE REFRESH: If you see this, the new code is running!');
        switch(data.action) {
                    case 'dataframes':
            console.log('Populating dataframes:', data.data);
            // Always populate all agents to avoid race conditions with tab switching
            try {
              console.log('🔍 Populating cleaning agent...');
              populateDataFrameSelect(data.data);
              console.log('✅ populateDataFrameSelect completed successfully');
              
              console.log('🔍 Populating transformation agent...');
              populateTransformationDataFrameSelect(data.data);
              console.log('✅ populateTransformationDataFrameSelect completed successfully');
              
              console.log('🔍 Populating statistical agent...');
              populateStatisticalDataFrameSelect(data.data);
              console.log('✅ populateStatisticalDataFrameSelect completed successfully');
              
              console.log('🔍 Populating modeling agent...');
              populateModelingDataFrameSelect(data.data);
              console.log('✅ populateModelingDataFrameSelect completed successfully');
              
              console.log('✅ All agents populated successfully');
            } catch (error) {
              console.error('❌ Error populating all agents:', error);
              console.error('❌ Error details:', error.message);
            }
            break;
          case 'dataframe_info':
            displayDataFrameInfo(data.data);
            // Also handle for modeling agent if that's the current context
            if (window.currentModelingDataframe) {
              handleModelingDataframeInfo(data.data);
            }
            // Also handle for statistical agent if that's the current context
            if (window.currentStatisticalDataframe) {
              handleStatisticalDataframeInfo(data.data);
            }
            break;
          case 'agent_started':
            handleAgentStarted(data.data);
            break;
          case 'transformation_agent_started':
            handleTransformationAgentStarted(data.data);
            break;
          case 'statistical_agent_started':
            handleStatisticalAgentStarted(data.data);
            break;
          case 'modeling_agent_started':
            handleModelingAgentStarted(data.data);
            break;
          case 'agent_step':
            handleAgentStep(data.data);
            break;
          case 'execute_code_response':
            console.log('🔍 Received execute_code_response');
            console.log('🔍 Code to execute:', data.code);
            
            // Store the code for later display
            currentStepCode = data.code;
            
            // Check if this is a custom transformation request
            if (data.code.includes('🔧 Custom Transformation Request') && data.code.includes('🤖 Sending custom transformation request to Claude')) {
              console.log('🔍 Detected custom transformation request, sending to Claude');
              
              // Set flag to prevent duplicate requests
              window.customTransformationInProgress = true;
              
              // Send custom transformation request to Claude
              if (ws && ws.readyState === WebSocket.OPEN) {
                // Extract the custom request from the code
                const requestMatch = data.code.match(/Request: (.+?)\\n/);
                const customRequest = requestMatch ? requestMatch[1] : 'Custom transformation requested';
                
                // Create Claude prompt for custom transformation
                const claudePrompt = `I need you to perform a custom data transformation based on the following request:

**Custom Transformation Request:**
${customRequest}

**Dataset Information:**
- Dataset: ${currentAgentWorkflow?.dataframe || 'Unknown'}
- Variables: ${currentAgentWorkflow?.dataframe ? 'Available in workspace' : 'Unknown'}

Please provide:
1. A detailed transformation plan
2. Executable R code to perform the transformations
3. Data quality checks and validation
4. Summary of changes made

Code only. Minimal chat. Provide executable R code that can be run directly.`;

                // Send to Claude
                ws.send(JSON.stringify({
                  action: 'chat_with_ai',
                  message: claudePrompt,
                  conversation_context: 'custom_transformation'
                }));
              }
              break;
            }
            
            // Automatically execute the next step's code
            if (ws && ws.readyState === WebSocket.OPEN) {
              console.log('🔍 Sending execute_code request');
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: data.code
              }));
            } else {
              console.log('🔍 WebSocket not available for execute_code');
            }
            break;
        }
      }
      
      // Populate DataFrame dropdown for main config
      function populateDataFrameSelect(dataframes) {
        console.log('populateDataFrameSelect called with:', dataframes);
        const select = document.getElementById('dataframe-select-main');
        const startBtn = document.getElementById('start-agent-btn');
        
        console.log('Select element found:', select);
        console.log('Start button found:', startBtn);
        
        if (!select) {
          console.error('dataframe-select-main element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log('Adding dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
          console.log('Final select innerHTML:', select.innerHTML);
        } else {
          console.error('dataframes is not an array:', dataframes);
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (startBtn) {
            startBtn.disabled = !this.value;
          }
          if (this.value) {
            // Uncheck all cleaning options when new dataframe is selected
            uncheckAllCleaningOptions();
            updateDataFrameInfoMain(this.value);
            // Populate variable selection
            populateVariableSelection(this.value);
          } else {
            const infoDiv = document.getElementById('dataframe-info-main');
            if (infoDiv) {
              infoDiv.style.display = 'none';
            }
            // Clear variable selection
            clearVariableSelection();
            // Reset button text
            const startBtn = document.getElementById('start-agent-btn');
            if (startBtn) {
              startBtn.textContent = 'Select a DataFrame';
              startBtn.disabled = true;
            }
          }
        };
        
      }
      
      // Variable Selection Functions
      function populateVariableSelection(dataframe, excludeTargetVariable = null) {
        console.log('Populating variable selection for:', dataframe);
        if (excludeTargetVariable) {
          console.log('Excluding target variable:', excludeTargetVariable);
        }
        
        // Request variable information from backend
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframe_variables',
            dataframe: dataframe,
            exclude_target_variable: excludeTargetVariable
          }));
        }
      }
      
      function clearVariableSelection() {
        const containers = document.querySelectorAll('[id$="-variable-container"]');
        containers.forEach(container => {
          container.innerHTML = '';
        });
      }
      
      function selectAllVariablesForOperation(operation) {
        const container = document.getElementById(`${operation}-variable-container`);
        if (container) {
          const checkboxes = container.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            checkbox.checked = true;
          });
        }
      }
      
      function selectNumericVariablesForOperation(operation) {
        const container = document.getElementById(`${operation}-variable-container`);
        if (container) {
          const checkboxes = container.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            const variableItem = checkbox.closest('.variable-checkbox-item');
            const typeSpan = variableItem.querySelector('.variable-type');
            if (typeSpan && typeSpan.textContent.includes('numeric')) {
              checkbox.checked = true;
            } else {
              checkbox.checked = false;
            }
          });
        }
      }
      
      function selectCategoricalVariablesForOperation(operation) {
        const container = document.getElementById(`${operation}-variable-container`);
        if (container) {
          const checkboxes = container.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            const variableItem = checkbox.closest('.variable-checkbox-item');
            const typeSpan = variableItem.querySelector('.variable-type');
            if (typeSpan && typeSpan.textContent.includes('categorical')) {
              checkbox.checked = true;
            } else {
              checkbox.checked = false;
            }
          });
        }
      }
      
      function selectNoneVariablesForOperation(operation) {
        const container = document.getElementById(`${operation}-variable-container`);
        if (container) {
          const checkboxes = container.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            checkbox.checked = false;
          });
        }
      }
      
      function renderVariableSelection(variables) {
        console.log('Rendering variable selection with variables:', variables);
        const containers = document.querySelectorAll('[id$="-variable-container"]');
        
        containers.forEach(container => {
          container.innerHTML = '';
          
          if (!variables || variables.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No variables found</div>';
            return;
          }
          
          variables.forEach(variable => {
            const item = document.createElement('div');
            item.className = 'variable-checkbox-item';
            
            const typeClass = variable.type === 'numeric' ? 'numeric' : 'categorical';
            
            item.innerHTML = `
              <input type="checkbox" id="var-${variable.name}" checked>
              <div class="variable-info">
                <span class="variable-name">${variable.name}</span>
                <span class="variable-type ${typeClass}">(${variable.type})</span>
              </div>
            `;
            
            container.appendChild(item);
          });
        });
      }
      
      function getSelectedVariables() {
        const selectedVars = {};
        
        // Get variables for cleaning operations
        const cleaningOperations = ['data-types', 'missing-values', 'duplicates', 'outliers', 'column-names'];
        
        cleaningOperations.forEach(operation => {
          const container = document.getElementById(`${operation}-variable-container`);
          if (container) {
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const vars = [];
            
            checkboxes.forEach(checkbox => {
              const varName = checkbox.id.replace('var-', '');
              const typeSpan = checkbox.parentElement.querySelector('.variable-type');
              const varType = typeSpan ? typeSpan.textContent.replace(/[()]/g, '') : 'unknown';
              
              vars.push({
                name: varName,
                type: varType
              });
            });
            
            selectedVars[operation] = vars;
          }
        });
        
        // Get variables for transformation operations
        const transformationOperations = ['mathematical', 'new-variables', 'categorical', 'datetime', 'merging', 'aggregation', 'statistical', 'text', 'spatial', 'custom'];
        
        transformationOperations.forEach(operation => {
          const container = document.getElementById(`${operation}-variable-container`);
          if (container) {
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const vars = [];
            
            checkboxes.forEach(checkbox => {
              const varName = checkbox.id.replace('var-', '');
              const typeSpan = checkbox.parentElement.querySelector('.variable-type');
              const varType = typeSpan ? typeSpan.textContent.replace(/[()]/g, '') : 'unknown';
              
              vars.push({
                name: varName,
                type: varType
              });
            });
            
            selectedVars[operation] = vars;
          }
        });
        
        // Get variables for modeling operations
        const modelingOperations = ['dimensionality-reduction', 'linear-regression', 'logistic-regression', 'multinomial-regression', 'random-forest', 'xgboost', 'feature-engineering', 'custom-modeling'];
        
        modelingOperations.forEach(operation => {
          const container = document.getElementById(`${operation}-variable-container`);
          if (container) {
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const vars = [];
            
            checkboxes.forEach(checkbox => {
              const varName = checkbox.id.replace('var-', '');
              const typeSpan = checkbox.parentElement.querySelector('.variable-type');
              const varType = typeSpan ? typeSpan.textContent.replace(/[()]/g, '') : 'unknown';
              
              vars.push({
                name: varName,
                type: varType
              });
            });
            
            selectedVars[operation] = vars;
          }
        });
        
        return selectedVars;
      }
      

      
      // Populate DataFrame dropdown for transformation config
      function populateTransformationDataFrameSelect(dataframes) {
        console.log('🔍 populateTransformationDataFrameSelect called with:', dataframes);
        const select = document.getElementById('transformation-dataframe-select');
        const startBtn = document.getElementById('start-transformation-btn');
        
        console.log('🔍 Transformation select found:', select);
        console.log('🔍 Transformation start button found:', startBtn);
        
        if (!select) {
          console.error('transformation-dataframe-select element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log('🔍 Adding transformation dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
          console.log('🔍 Final transformation select innerHTML:', select.innerHTML);
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (this.value) {
            updateTransformationDataFrameInfo();
            // FIXED: Update start button state after dataframe info is loaded
            setTimeout(() => updateTransformationStartButton(), 100);
          } else {
            const checklist = document.getElementById('transformation-checklist');
            if (checklist) {
              checklist.style.display = 'none';
            }
            // FIXED: Disable start button when no dataframe selected
            if (startBtn) {
              startBtn.disabled = true;
              startBtn.textContent = 'Select a DataFrame first';
              startBtn.title = 'Please select a DataFrame to continue';
            }
          }
        };
      }
      
      // Populate DataFrame dropdown for statistical config
      function populateStatisticalDataFrameSelect(dataframes) {
        console.log('🔍 populateStatisticalDataFrameSelect called with:', dataframes);
        const select = document.getElementById('statistical-dataframe-select');
        const startBtn = document.getElementById('start-statistical-btn');
        
        console.log('🔍 Statistical select found:', select);
        console.log('🔍 Statistical start button found:', startBtn);
        
        if (!select) {
          console.error('statistical-dataframe-select element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log('🔍 Adding statistical dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
          console.log('🔍 Final statistical select innerHTML:', select.innerHTML);
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (this.value) {
            updateStatisticalDataFrameInfo();
            // FIXED: Update start button state after dataframe info is loaded
            setTimeout(() => updateStatisticalStartButton(), 100);
          } else {
            const checklist = document.getElementById('statistical-checklist');
            if (checklist) {
              checklist.style.display = 'none';
            }
            // FIXED: Disable start button when no dataframe selected
            if (startBtn) {
              startBtn.disabled = true;
              startBtn.textContent = 'Select a DataFrame first';
              startBtn.title = 'Please select a DataFrame to continue';
            }
          }
        };
      }
      
      // Populate DataFrame dropdown for modeling config
      function populateModelingDataFrameSelect(dataframes) {
        console.log('🔍 populateModelingDataFrameSelect called with:', dataframes);
        const select = document.getElementById('modeling-dataframe-select');
        const startBtn = document.getElementById('start-modeling-btn');
        
        console.log('🔍 Modeling select found:', select);
        console.log('🔍 Modeling start button found:', startBtn);
        
        if (!select) {
          console.error('modeling-dataframe-select element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log('🔍 Adding modeling dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
          console.log('🔍 Final modeling select innerHTML:', select.innerHTML);
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (this.value) {
            updateModelingDataFrameInfo();
            // Update start button state after dataframe info is loaded
            setTimeout(() => updateModelingStartButton(), 100);
          } else {
            const checklist = document.getElementById('modeling-checklist');
            if (checklist) {
              checklist.style.display = 'none';
            }
            // Disable start button when no dataframe selected
            if (startBtn) {
              startBtn.disabled = true;
              startBtn.textContent = 'Select a DataFrame first';
              startBtn.title = 'Please select a DataFrame to continue';
            }
          }
        };
      }
      
      // Populate variable dropdowns for modeling analysis
      function populateModelingVariableDropdowns(dataframeName) {
        if (!dataframeName) return;
        
        try {
          // Store the current dataframe name for when we receive the info
          window.currentModelingDataframe = dataframeName;
          
          // Get dataframe info from R
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: dataframeName
            }));
          }
          
          // Provide immediate fallback with placeholder variables while we wait for real data
          // This ensures the UI is functional even if dataframe info doesn't arrive
          const continuousVars = ['Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width'];
          const categoricalVars = ['Species'];
          
          // Store variable types globally for algorithm filtering (will be updated when real data arrives)
          window.modelingVariableTypes = {};
          continuousVars.forEach(varName => {
            window.modelingVariableTypes[varName] = {
              type: 'numeric'
            };
          });
          categoricalVars.forEach(varName => {
            window.modelingVariableTypes[varName] = {
              type: 'categorical',
              categories: 3 // Placeholder
            };
          });
          
          // Populate target variable dropdown immediately
          const targetDropdown = document.getElementById('modeling-target-variable');
          if (targetDropdown) {
            targetDropdown.innerHTML = '<option value="">-- Select Target Variable --</option>';
            
            // Add continuous variables
            continuousVars.forEach(varName => {
              const option = document.createElement('option');
              option.value = varName;
              option.textContent = `${varName} (numeric)`;
              targetDropdown.appendChild(option);
            });
            
            // Add categorical variables
            categoricalVars.forEach(varName => {
              const option = document.createElement('option');
              option.value = varName;
              option.textContent = `${varName} (categorical)`;
              targetDropdown.appendChild(option);
            });
          }
          
        } catch (error) {
          console.error('Error populating modeling variable dropdowns:', error);
        }
      }
      
      // Handle dataframe info specifically for modeling agent
      function handleModelingDataframeInfo(dataframeInfo) {
        try {
          if (!dataframeInfo || !window.currentModelingDataframe) return;
          
          console.log('🔍 Processing dataframe info for modeling:', dataframeInfo);
          
          // Check if we have proper column info to update the variables
          const hasColumns = dataframeInfo.columns || dataframeInfo.column_info;
          if (!hasColumns) {
            console.log('⚠️ No column info in dataframe response, keeping placeholder variables');
            return; // Keep the placeholder variables that were already populated
          }
          
          // Store variable types and category counts globally for algorithm filtering
          const newVariableTypes = {};
          
          const targetDropdown = document.getElementById('modeling-target-variable');
          if (targetDropdown) {
            // Clear existing options except the first
            targetDropdown.innerHTML = '<option value="">-- Select Target Variable --</option>';
            
            // Process each column from the dataframe info
            const columns = dataframeInfo.columns || dataframeInfo.column_info || {};
            Object.entries(columns).forEach(([varName, colInfo]) => {
              const colType = colInfo.type || colInfo.class || 'unknown';
              
              if (colType === 'numeric' || colType === 'integer' || colType === 'double') {
                // Store as numeric
                newVariableTypes[varName] = {
                  type: 'numeric',
                  min: colInfo.min,
                  max: colInfo.max,
                  mean: colInfo.mean
                };
                
                // Add to dropdown
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = `${varName} (numeric)`;
                targetDropdown.appendChild(option);
                
              } else if (colType === 'factor' || colType === 'character' || colType === 'categorical') {
                // Count unique categories
                const uniqueCount = colInfo.unique_count || colInfo.unique || colInfo.levels?.length || 2;
                
                // Store as categorical with category count
                newVariableTypes[varName] = {
                  type: 'categorical',
                  categories: uniqueCount,
                  levels: colInfo.levels || []
                };
                
                // Add to dropdown with category count
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = `${varName} (categorical, ${uniqueCount} categories)`;
                targetDropdown.appendChild(option);
                
              } else {
                // Unknown type - treat as categorical with unknown count
                newVariableTypes[varName] = {
                  type: 'categorical',
                  categories: 2 // Default fallback
                };
                
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = `${varName} (${colType})`;
                targetDropdown.appendChild(option);
              }
            });
            
            // Only update if we successfully processed some variables
            if (Object.keys(newVariableTypes).length > 0) {
              window.modelingVariableTypes = newVariableTypes;
              console.log('✅ Updated modeling variable types with real data:', window.modelingVariableTypes);
            } else {
              console.log('⚠️ No variables processed from dataframe info, keeping placeholders');
            }
          }
          
        } catch (error) {
          console.error('Error handling modeling dataframe info:', error);
          console.log('⚠️ Keeping placeholder variables due to error');
        }
      }
      
      // Update algorithm options based on target variable type
      function updateAlgorithmOptions() {
        const targetVariable = document.getElementById('modeling-target-variable').value;
        
        if (!targetVariable || !window.modelingVariableTypes) {
          // Hide all algorithms if no target selected
          showAllAlgorithms();
          return;
        }
        
        const targetInfo = window.modelingVariableTypes[targetVariable];
        const targetType = typeof targetInfo === 'string' ? targetInfo : targetInfo.type;
        
        // Algorithm groups to show/hide based on target type
        const regressionOnlyGroups = ['linear-regression-group'];
        const binaryClassificationGroups = ['logistic-regression-group'];
        const multiClassificationGroups = ['multinomial-regression-group'];
        // Random Forest and XGBoost work for both regression and classification
        
        if (targetType === 'numeric') {
          // For numeric targets: show regression algorithms, hide classification-only
          showAlgorithmGroups(regressionOnlyGroups);
          hideAlgorithmGroups([...binaryClassificationGroups, ...multiClassificationGroups]);
          console.log('🔢 Numeric target selected - showing regression algorithms');
          
        } else if (targetType === 'categorical') {
          // Hide regression algorithms for categorical targets
          hideAlgorithmGroups(regressionOnlyGroups);
          
          // Check number of categories for intelligent algorithm suggestions
          const categoryCount = targetInfo.categories || 2; // Default to 2 if unknown
          
          if (categoryCount === 2) {
            // Binary classification: show logistic regression, hide multinomial
            showAlgorithmGroups(binaryClassificationGroups);
            hideAlgorithmGroups(multiClassificationGroups);
            console.log('🎯 Binary classification target (2 categories) - showing logistic regression');
            
          } else if (categoryCount > 2) {
            // Multi-class classification: show multinomial, hide logistic regression
            showAlgorithmGroups(multiClassificationGroups);
            hideAlgorithmGroups(binaryClassificationGroups);
            console.log(`🎯 Multi-class classification target (${categoryCount} categories) - showing multinomial regression`);
            
          } else {
            // Unknown category count: show both classification algorithms
            showAlgorithmGroups([...binaryClassificationGroups, ...multiClassificationGroups]);
            console.log('🏷️ Categorical target (unknown categories) - showing all classification algorithms');
          }
        }
        
        // Update the start button state since algorithm availability changed
        updateModelingStartButton();
        
        // Refresh variable selection to exclude the new target variable
        const dataframe = document.getElementById('modeling-dataframe-select').value;
        if (dataframe) {
          populateVariableSelection(dataframe, targetVariable);
        }
      }
      
      // Helper function to show algorithm groups
      function showAlgorithmGroups(groupIds) {
        groupIds.forEach(groupId => {
          const group = document.getElementById(groupId);
          if (group) {
            group.style.display = 'block';
          }
        });
      }
      
      // Helper function to hide algorithm groups and uncheck them
      function hideAlgorithmGroups(groupIds) {
        groupIds.forEach(groupId => {
          const group = document.getElementById(groupId);
          if (group) {
            group.style.display = 'none';
            // Uncheck the algorithm if it was selected
            const checkbox = group.querySelector('input[type="checkbox"]');
            if (checkbox) {
              checkbox.checked = false;
            }
          }
        });
      }
      
      // Show all algorithms (when no target is selected)
      function showAllAlgorithms() {
        const allAlgorithmGroups = ['linear-regression-group', 'logistic-regression-group', 'multinomial-regression-group'];
        showAlgorithmGroups(allAlgorithmGroups);
      }
      
      // Populate variable dropdowns for statistical analysis
      function populateStatisticalVariableDropdowns(dataframeName) {
        if (!dataframeName) return;
        
        try {
          // Get dataframe info from R
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: dataframeName
            }));
          }
          
          // Clear dropdowns and show loading state - real data will populate when response arrives
          const allDropdowns = [
            'statistical-continuous-var',
            'statistical-before-var',
            'statistical-after-var',
            'nonparametric-continuous-var',
            'statistical-grouping-var',
            'nonparametric-grouping-var',
            'categorical-var1',
            'categorical-var2'
          ];
          
          allDropdowns.forEach(dropdownId => {
            const dropdown = document.getElementById(dropdownId);
            if (dropdown) {
              dropdown.innerHTML = '<option value="">-- Loading variables... --</option>';
            }
          });
          
        } catch (error) {
          console.error('Error populating statistical variable dropdowns:', error);
        }
      }
      
      // Handle statistical dataframe info response and populate variable dropdowns with real data
      function handleStatisticalDataframeInfo(dataframeInfo) {
        try {
          if (!dataframeInfo || !window.currentStatisticalDataframe) return;
          
          console.log('🔍 Processing dataframe info for statistical agent:', dataframeInfo);
          
          // Check if we have proper column info to update the variables
          const hasColumns = dataframeInfo.columns || dataframeInfo.column_info;
          if (!hasColumns) {
            console.log('⚠️ No column info in dataframe response for statistical agent, keeping loading state');
            return; // Keep the loading state - real column info will come later
          }
          
          // Store detailed variable information globally for guidance system
          window.statisticalVariableInfo = {};
          
          // Separate variables by type with detailed info
          const continuousVars = [];
          const categoricalVars = [];
          
          // Get columns from either structure
          const columns = dataframeInfo.columns || dataframeInfo.column_info || {};
          
          Object.entries(columns).forEach(([varName, colInfo]) => {
            const colType = colInfo.type || colInfo.class || 'unknown';
            
            // Store detailed info for guidance system
            window.statisticalVariableInfo[varName] = {
              type: colType,
              min: colInfo.min,
              max: colInfo.max,
              mean: colInfo.mean,
              levels: colInfo.levels,
              unique_count: colInfo.unique_count,
              na_count: colInfo.na_count
            };
            
            if (colType === 'numeric' || colType === 'integer' || colType === 'double') {
              continuousVars.push({
                name: varName,
                type: colType,
                min: colInfo.min,
                max: colInfo.max,
                mean: colInfo.mean
              });
            } else if (colType === 'categorical' || colType === 'factor' || colType === 'character' || colType === 'logical') {
              categoricalVars.push({
                name: varName,
                type: colType,
                levels: colInfo.levels || [],
                unique_count: colInfo.unique_count
              });
            }
          });
          
          console.log('🔍 Statistical agent variables - Continuous:', continuousVars, 'Categorical:', categoricalVars);
          
          // Populate continuous variable dropdowns
          const continuousDropdowns = [
            'statistical-continuous-var',
            'statistical-before-var',
            'statistical-after-var',
            'nonparametric-continuous-var'
          ];
          
          continuousDropdowns.forEach(dropdownId => {
            const dropdown = document.getElementById(dropdownId);
            if (dropdown) {
              dropdown.innerHTML = '<option value="">-- Select Variable --</option>';
              continuousVars.forEach(varInfo => {
                const option = document.createElement('option');
                option.value = varInfo.name;
                
                // Enhanced display with type indicators
                let displayText = `${varInfo.name} (${varInfo.type})`;
                if (varInfo.min !== undefined && varInfo.max !== undefined) {
                  displayText += ` [${varInfo.min?.toFixed(1)} - ${varInfo.max?.toFixed(1)}]`;
                } else if (varInfo.mean !== undefined) {
                  displayText += ` (mean: ${varInfo.mean?.toFixed(1)})`;
                }
                
                option.textContent = displayText;
                dropdown.appendChild(option);
              });
            }
          });
          
          // Populate categorical variable dropdowns
          const categoricalDropdowns = [
            'statistical-grouping-var',
            'nonparametric-grouping-var',
            'categorical-var1',
            'categorical-var2'
          ];
          
          categoricalDropdowns.forEach(dropdownId => {
            const dropdown = document.getElementById(dropdownId);
            if (dropdown) {
              dropdown.innerHTML = '<option value="">-- Select Variable --</option>';
              categoricalVars.forEach(varInfo => {
                const option = document.createElement('option');
                option.value = varInfo.name;
                
                // Enhanced display with level indicators
                let displayText = `${varInfo.name} (${varInfo.type})`;
                if (varInfo.levels && varInfo.levels.length > 0) {
                  displayText += ` [${varInfo.levels.length} levels: ${varInfo.levels.slice(0, 2).join(', ')}${varInfo.levels.length > 2 ? '...' : ''}]`;
                } else if (varInfo.unique_count !== undefined) {
                  displayText += ` [${varInfo.unique_count} unique values]`;
                }
                
                option.textContent = displayText;
                dropdown.appendChild(option);
              });
            }
          });
          
          console.log('✅ Statistical agent variable dropdowns updated with real data');
          
        } catch (error) {
          console.error('Error handling statistical dataframe info:', error);
        }
      }
      
      // Dynamic guidance system for group comparison test selection
      function updateGroupComparisonGuidance() {
        try {
          const testTypeSelect = document.getElementById('group-comparisons-select');
          const continuousVar = document.getElementById('statistical-continuous-var').value;
          const groupingVar = document.getElementById('statistical-grouping-var').value;
          const guidanceDiv = document.getElementById('group-comparison-guidance');
          const guidanceText = document.getElementById('guidance-text');
          
          if (!continuousVar || !groupingVar || !window.statisticalVariableInfo) {
            guidanceDiv.style.display = 'none';
            return;
          }
          
          const contInfo = window.statisticalVariableInfo[continuousVar];
          const groupInfo = window.statisticalVariableInfo[groupingVar];
          
          if (!contInfo || !groupInfo) {
            guidanceDiv.style.display = 'none';
            return;
          }
          
          // Determine number of groups
          const numGroups = groupInfo.levels ? groupInfo.levels.length : groupInfo.unique_count || 2;
          
          // Generate intelligent recommendations
          let recommendation = '';
          let suggestedTest = '';
          
          if (numGroups === 2) {
            recommendation = `Two groups detected (${groupInfo.levels ? groupInfo.levels.join(' vs ') : 'binary variable'}). `;
            if (testTypeSelect.value === 'automatic') {
              recommendation += 'Recommended: Independent t-test (parametric) or Mann-Whitney U (non-parametric).';
              suggestedTest = 'independent_ttest';
            }
          } else if (numGroups >= 3) {
            recommendation = `${numGroups} groups detected. `;
            if (testTypeSelect.value === 'automatic') {
              recommendation += 'Recommended: One-way ANOVA (parametric) or Kruskal-Wallis (non-parametric).';
              suggestedTest = 'one_way_anova';
            }
          }
          
          // Add data distribution info
          if (contInfo.min !== undefined && contInfo.max !== undefined) {
            recommendation += ` Data range: ${contInfo.min.toFixed(1)} - ${contInfo.max.toFixed(1)}.`;
          }
          
          // Validate current selection
          const currentTest = testTypeSelect.value;
          let validation = '';
          
          if (currentTest === 'independent_ttest' && numGroups !== 2) {
            validation = ' ⚠️ Warning: Independent t-test requires exactly 2 groups.';
          } else if (currentTest === 'welch_ttest' && numGroups !== 2) {
            validation = ' ⚠️ Warning: Welch\'s t-test requires exactly 2 groups.';
          } else if (currentTest === 'mann_whitney' && numGroups !== 2) {
            validation = ' ⚠️ Warning: Mann-Whitney U test requires exactly 2 groups.';
          } else if ((currentTest === 'one_way_anova' || currentTest === 'kruskal_wallis') && numGroups < 3) {
            validation = ' ⚠️ Warning: This test is designed for 3+ groups.';
          }
          
          guidanceText.textContent = recommendation + validation;
          guidanceDiv.style.display = 'block';
          
          // Auto-suggest test if on automatic mode
          if (testTypeSelect.value === 'automatic' && suggestedTest) {
            // Don't change the dropdown, just show the recommendation
          }
          
        } catch (error) {
          console.error('Error updating group comparison guidance:', error);
        }
      }
      
      // Update DataFrame info for main config
      function updateDataFrameInfoMain(dfName) {
        console.log('🔍 updateDataFrameInfoMain called with:', dfName);
        const startBtn = document.getElementById('start-agent-btn');
        const cleaningChecklist = document.getElementById('cleaning-checklist');
        
        console.log('🔍 Start button found:', startBtn);
        console.log('🔍 Cleaning checklist found:', cleaningChecklist);
        
        if (startBtn) {
          startBtn.disabled = false;
          startBtn.textContent = '🚀 Start Cleaning Agent';
          console.log('🔍 Start button enabled');
        }
        
        // Show cleaning checklist
        if (cleaningChecklist) {
          cleaningChecklist.style.display = 'block';
          console.log('🔍 Cleaning checklist shown');
        } else {
          console.error('❌ Cleaning checklist not found!');
        }
        
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframe_info',
            dataframe: dfName
          }));
        }
      }
      
      // Update DataFrame info for transformation config
      function updateTransformationDataFrameInfo() {
        const select = document.getElementById('transformation-dataframe-select');
        const startBtn = document.getElementById('start-transformation-btn');
        const checklist = document.getElementById('transformation-checklist');
        
        if (select.value) {
          // Show transformation checklist
          if (checklist) {
            checklist.style.display = 'block';
          }
          
          // Populate variable selection
          populateVariableSelection(select.value);
          
          // Get dataframe info
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: select.value
            }));
          }
          
          // FIXED: Don't enable start button here - let updateTransformationStartButton handle it
          // This ensures proper validation of checkbox selections
        } else {
          // Disable start button and hide checklist
          if (startBtn) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          }
          if (checklist) {
            checklist.style.display = 'none';
          }
        }
      }
      
      // Update DataFrame info for statistical config
      function updateStatisticalDataFrameInfo() {
        const select = document.getElementById('statistical-dataframe-select');
        const startBtn = document.getElementById('start-statistical-btn');
        const checklist = document.getElementById('statistical-checklist');
        
        if (select.value) {
          // Show statistical checklist
          if (checklist) {
            checklist.style.display = 'block';
          }
          
          // Set current statistical dataframe for response handling
          window.currentStatisticalDataframe = select.value;
          
          // Get dataframe info
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: select.value
            }));
          }
          
          // Populate variable dropdowns for statistical analysis (will show loading state)
          populateStatisticalVariableDropdowns(select.value);
          
          // FIXED: Don't enable start button here - let updateStatisticalStartButton handle it
          // This ensures proper validation of checkbox selections
        } else {
          // Clear current statistical dataframe
          window.currentStatisticalDataframe = null;
          
          // Disable start button and hide checklist
          if (startBtn) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          }
          if (checklist) {
            checklist.style.display = 'none';
          }
          
          // Clear variable selection
          clearVariableSelection();
        }
      }
      
      // Update DataFrame info for modeling config
      function updateModelingDataFrameInfo() {
        const select = document.getElementById('modeling-dataframe-select');
        const startBtn = document.getElementById('start-modeling-btn');
        const checklist = document.getElementById('modeling-checklist');
        const targetSection = document.getElementById('target-variable-section');
        
        if (select.value) {
          // Show modeling checklist
          if (checklist) {
            checklist.style.display = 'block';
          }
          
          // Show target variable section for supervised learning
          if (targetSection) {
            targetSection.style.display = 'block';
          }
          
          // Get dataframe info
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: select.value
            }));
          }
          
          // Populate variable dropdowns for modeling analysis
          populateModelingVariableDropdowns(select.value);
          
          // Populate variable selection (exclude target variable for modeling)
          const targetVariable = document.getElementById('modeling-target-variable').value;
          populateVariableSelection(select.value, targetVariable);
          
          // Don't enable start button here - let updateModelingStartButton handle it
        } else {
          // Disable start button and hide checklist
          if (startBtn) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          }
          if (checklist) {
            checklist.style.display = 'none';
          }
          if (targetSection) {
            targetSection.style.display = 'none';
          }
          
          // Clear variable selection
          clearVariableSelection();
        }
      }
      
      // Update modeling start button state
      function updateModelingStartButton() {
        const startBtn = document.getElementById('start-modeling-btn');
        const targetVariable = document.getElementById('modeling-target-variable').value;
        
        if (!startBtn) return;
        
        // Check if at least one algorithm is selected
        const algorithms = [
          'check-dimensionality-reduction',
          'check-linear-regression',
          'check-logistic-regression',
          'check-multinomial-regression',
          'check-random-forest',
          'check-xgboost',
          'check-custom-modeling'
        ];
        
        const hasAlgorithm = algorithms.some(id => document.getElementById(id).checked);
        
        // Always require target variable for supervised learning
        const hasTarget = targetVariable;
        
        if (hasAlgorithm && hasTarget) {
          startBtn.disabled = false;
          startBtn.textContent = '🚀 Start Modeling Agent';
          startBtn.title = 'Click to start the modeling agent';
        } else {
          startBtn.disabled = true;
          if (!hasAlgorithm) {
            startBtn.textContent = 'Select algorithms first';
            startBtn.title = 'Please select at least one machine learning algorithm';
          } else if (!hasTarget) {
            startBtn.textContent = 'Select target variable first';
            startBtn.title = 'Please select a target variable for supervised learning';
          } else {
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          }
        }
      }
      
      // Start cleaning agent (simplified)
      function startCleaningAgentSimple() {
        const dataframe = document.getElementById('dataframe-select-main').value;
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        // Collect selected cleaning operations
        const cleaningOptions = {
          dataTypes: document.getElementById('check-data-types').checked,
          missingValues: document.getElementById('check-missing-values').checked && !document.getElementById('check-missing-values').disabled,
          duplicates: document.getElementById('check-duplicates').checked,
          outliers: document.getElementById('check-outliers').checked,
          columnNames: document.getElementById('check-column-names').checked,
          other: document.getElementById('check-other').checked
        };
        
        // Collect selected variables
        const selectedVariables = getSelectedVariables();
        
        // Collect method options for each operation
        const methodOptions = {
          dataTypes: document.getElementById('data-type-method-select')?.value || 'automatic',
          missingValues: document.getElementById('na-handling-select')?.value || 'dont',
          outliers: document.getElementById('outlier-method-select')?.value || 'iqr',
          columnNames: document.getElementById('column-naming-select')?.value || 'snake_case'
        };
        
        // Get custom text inputs for "Other" methods
        const customInputs = {
          dataTypes: document.getElementById('data-type-custom-input')?.value.trim() || '',
          missingValues: document.getElementById('missing-values-custom-input')?.value.trim() || '',
          outliers: document.getElementById('outlier-custom-input')?.value.trim() || '',
          columnNames: document.getElementById('column-naming-custom-input')?.value.trim() || ''
        };
        
        // Get other operations text if selected
        const otherOperations = cleaningOptions.other ? 
          document.getElementById('other-operations-input').value.trim() : '';
        
        const naHandling = cleaningOptions.missingValues ? 
          document.getElementById('na-handling-select').value : 'dont';
        
        // Validate that all checked "Other" options have content
        if (!validateOtherInputs()) {
          const invalidOptions = getInvalidOtherOptions();
          alert(`Please fill in the following "Other" options before starting:\n\n${invalidOptions.join('\n')}`);
          return;
        }
        
        console.log('Starting agent with:', { 
          dataframe, 
          naHandling, 
          cleaningOptions,
          selectedVariables
        });
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // Send agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_cleaning_agent',
            dataframe: dataframe,
            na_handling: naHandling,
            cleaning_options: cleaningOptions,
            method_options: methodOptions,
            custom_inputs: customInputs,
            other_operations: otherOperations,
            selected_variables: selectedVariables
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
        }
      }
      
      // Display DataFrame information
      function displayDataFrameInfo(dfInfo) {
        const infoDiv = document.getElementById('dataframe-info-main');
        const cleaningChecklist = document.getElementById('cleaning-checklist');
        const missingValuesGroup = document.getElementById('missing-values-group');
        const missingValuesCheckbox = document.getElementById('check-missing-values');
        const missingHandlingOptions = document.getElementById('missing-handling-options');
        
        if (dfInfo.exists) {
          const missingCounts = Object.entries(dfInfo.column_info)
            .filter(([col, info]) => info.missing > 0)
            .map(([col, info]) => `${col}: ${info.missing}`)
            .join(', ');
          
          const hasMissingValues = missingCounts.length > 0;
          
          infoDiv.innerHTML = `
            <strong>${dfInfo.name}</strong><br>
            📊 ${dfInfo.nrow} rows × ${dfInfo.ncol} columns<br>
            💾 Size: ${dfInfo.size_mb} MB<br>
            ${hasMissingValues ? `⚠️ Missing values: ${missingCounts}` : '✅ No missing values'}
          `;
          infoDiv.style.display = 'block';
          
          // Show cleaning checklist
          cleaningChecklist.style.display = 'block';
          
          // Always enable missing values option - let user decide
            missingValuesGroup.classList.remove('disabled');
            missingValuesCheckbox.disabled = false;
          console.log('Missing values option always enabled - user can check/uncheck as needed');
          
          // Set up checkbox interactions
          setupCheckboxInteractions();
          
          // Add event listeners to enable/disable start button based on selections
          addCleaningOptionListeners();
          

          
        } else {
          infoDiv.innerHTML = `❌ ${dfInfo.error}`;
          infoDiv.style.display = 'block';
          cleaningChecklist.style.display = 'none';
        }
      }
      
      // Get current auto-execute toggle state
      function isAutoExecuteEnabled() {
        const toggle = document.getElementById('auto-execute-toggle');
        return toggle ? toggle.checked : true; // Default to true if toggle not found
      }
      
      // Uncheck all cleaning options when new dataframe is selected
      function uncheckAllCleaningOptions() {
        // Uncheck all checkboxes
        document.getElementById('check-data-types').checked = false;
        document.getElementById('check-missing-values').checked = false;
        document.getElementById('check-duplicates').checked = false;
        document.getElementById('check-outliers').checked = false;
        document.getElementById('check-column-names').checked = false;
        document.getElementById('check-other').checked = false;
        
        // Hide all sub-options
        document.getElementById('missing-handling-options').style.display = 'none';
        document.getElementById('other-options').style.display = 'none';
        document.getElementById('data-type-options').style.display = 'none';
        document.getElementById('outlier-method-options').style.display = 'none';
        document.getElementById('column-naming-options').style.display = 'none';
        
        // Clear all custom input fields
        document.getElementById('other-operations-input').value = '';
        document.getElementById('data-type-custom-input').value = '';
        document.getElementById('missing-values-custom-input').value = '';
        document.getElementById('outlier-custom-input').value = '';
        document.getElementById('column-naming-custom-input').value = '';
        
        // Hide all "Other" input fields
        document.getElementById('data-type-other-input').style.display = 'none';
        document.getElementById('missing-values-other-input').style.display = 'none';
        document.getElementById('outlier-other-input').style.display = 'none';
        document.getElementById('column-naming-other-input').style.display = 'none';
        
        // Disable start button until user selects at least one option
        const startBtn = document.getElementById('start-agent-btn');
        if (startBtn) {
          startBtn.disabled = true;
        }
        
        // Re-validate the start button state
        updateStartButton();
      }
      
      // Function to check if all selected "Other" options have content
      function validateOtherInputs() {
        const otherInputs = [
          { 
            checkbox: 'check-data-types', 
            input: 'data-type-custom-input',
            methodSelect: 'data-type-method-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-missing-values', 
            input: 'missing-values-custom-input',
            methodSelect: 'na-handling-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-outliers', 
            input: 'outlier-custom-input',
            methodSelect: 'outlier-method-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-column-names', 
            input: 'column-naming-custom-input',
            methodSelect: 'column-naming-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-other', 
            input: 'other-operations-input',
            methodSelect: null,
            methodValue: null
          }
        ];
        
        // Check if any "Other" checkbox is checked but has no content
        const hasInvalidOther = otherInputs.some(({ checkbox, input, methodSelect, methodValue }) => {
          const checkboxEl = document.getElementById(checkbox);
          const inputEl = document.getElementById(input);
          
          if (!checkboxEl.checked) return false; // Skip if checkbox not checked
          
          // For the general "other" checkbox, always validate
          if (methodSelect === null) {
            return inputEl && inputEl.value.trim() === '';
          }
          
          // For method-specific "other" options, only validate if method is set to "other"
          const methodSelectEl = document.getElementById(methodSelect);
          if (methodSelectEl && methodSelectEl.value === methodValue) {
            return inputEl && inputEl.value.trim() === '';
          }
          
          return false; // Method is not "other", so no validation needed
        });
        
        return !hasInvalidOther;
      }
      
      // Function to check overall validation and update start button
      function updateStartButton() {
        const checkboxes = [
          'check-data-types',
          'check-missing-values', 
          'check-duplicates',
          'check-outliers',
          'check-column-names',
          'check-other'
        ];
        
        const startBtn = document.getElementById('start-agent-btn');
        
        // Check if at least one option is selected
        const hasSelection = checkboxes.some(cbId => 
          document.getElementById(cbId).checked
        );
        
        // Check if all "Other" inputs have content
        const otherInputsValid = validateOtherInputs();
        
        if (startBtn) {
          // Always enable the button, but show helpful message if validation fails
          startBtn.disabled = false;
          
          if (!hasSelection) {
            // No options selected
            startBtn.textContent = '🚀 Start Cleaning Agent';
            startBtn.title = 'Please select at least one cleaning option';
          } else if (!otherInputsValid) {
            // Some "Other" options are checked but empty
            const invalidOptions = getInvalidOtherOptions();
            startBtn.textContent = '⚠️ Fill in "Other" options';
            startBtn.title = `Please fill in: ${invalidOptions.join(', ')}`;
          } else {
            // All validation passed
            startBtn.textContent = '🚀 Start Cleaning Agent';
            startBtn.title = 'Ready to start cleaning agent';
          }
        }
      }
      
      // Helper function to get which "Other" options need content
      function getInvalidOtherOptions() {
        const otherInputs = [
          { 
            checkbox: 'check-data-types', 
            input: 'data-type-custom-input', 
            label: 'Data Types',
            methodSelect: 'data-type-method-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-missing-values', 
            input: 'missing-values-custom-input', 
            label: 'Missing Values',
            methodSelect: 'na-handling-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-outliers', 
            input: 'outlier-custom-input', 
            label: 'Outliers',
            methodSelect: 'outlier-method-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-column-names', 
            input: 'column-naming-custom-input', 
            label: 'Column Names',
            methodSelect: 'column-naming-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-other', 
            input: 'other-operations-input', 
            label: 'Other Operations',
            methodSelect: null,
            methodValue: null
          }
        ];
        
        const invalidOptions = [];
        otherInputs.forEach(({ checkbox, input, label, methodSelect, methodValue }) => {
          const checkboxEl = document.getElementById(checkbox);
          const inputEl = document.getElementById(input);
          
          if (!checkboxEl.checked) return; // Skip if checkbox not checked
          
          // For the general "other" checkbox, always validate
          if (methodSelect === null) {
            if (inputEl && inputEl.value.trim() === '') {
              invalidOptions.push(label);
            }
            return;
          }
          
          // For method-specific "other" options, only validate if method is set to "other"
          const methodSelectEl = document.getElementById(methodSelect);
          if (methodSelectEl && methodSelectEl.value === methodValue) {
            if (inputEl && inputEl.value.trim() === '') {
              invalidOptions.push(label);
            }
          }
        });
        
        return invalidOptions;
      }
      
      // Add event listeners to enable/disable start button based on checkbox selections
      function addCleaningOptionListeners() {
        const checkboxes = [
          'check-data-types',
          'check-missing-values', 
          'check-duplicates',
          'check-outliers',
          'check-column-names',
          'check-other'
        ];
        
        checkboxes.forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', updateStartButton);
          }
        });
        
        // Add listeners to all "Other" text inputs to validate in real-time
        const otherInputs = [
          'data-type-custom-input',
          'missing-values-custom-input', 
          'outlier-custom-input',
          'column-naming-custom-input',
          'other-operations-input'
        ];
        
        otherInputs.forEach(inputId => {
          const input = document.getElementById(inputId);
          if (input) {
            input.addEventListener('input', updateStartButton);
            input.addEventListener('blur', updateStartButton);
          }
        });
        
        // Add listeners to method select dropdowns to validate when method changes
        const methodSelects = [
          'data-type-method-select',
          'na-handling-select',
          'outlier-method-select',
          'column-naming-select'
        ];
        
        methodSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateStartButton);
          }
        });
      }
      
      // Add event listeners for transformation agent checkboxes and options
      function addTransformationOptionListeners() {
        const checkboxes = [
          'check-distribution-analysis',
          'check-mathematical-transformations',
          'check-new-variables',
          'check-categorical-transformations',
          'check-datetime-transformations',
          'check-merging-combining',
          'check-aggregation-grouping',
          'check-statistical-transformations',
          'check-text-transformations',
          'check-spatial-transformations',
          'check-custom-transformations'
        ];
        
        checkboxes.forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', updateTransformationStartButton);
          }
        });
        
        // Add listeners to all "Other" text inputs to validate in real-time
        const otherInputs = [
          'math-transformations-custom-input',
          'new-variables-custom-input',
          'categorical-transformations-custom-input',
          'datetime-transformations-custom-input',
          'merging-combining-custom-input',
          'aggregation-grouping-custom-input',
          'statistical-transformations-custom-input',
          'text-transformations-custom-input',
          'spatial-transformations-custom-input',
          'custom-transformations-custom-input'
        ];
        
        otherInputs.forEach(inputId => {
          const input = document.getElementById(inputId);
          if (input) {
            input.addEventListener('input', updateTransformationStartButton);
            input.addEventListener('blur', updateTransformationStartButton);
          }
        });
        
        // Add listeners to method select dropdowns to validate when method changes
        const methodSelects = [
          'math-transformations-select',
          'new-variables-select',
          'categorical-transformations-select',
          'datetime-transformations-select',
          'merging-combining-select',
          'aggregation-grouping-select',
          'statistical-transformations-select',
          'text-transformations-select',
          'spatial-transformations-select'
        ];
        
        methodSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateTransformationStartButton);
          }
        });
      }
      
      // Update transformation start button based on selections
      function updateTransformationStartButton() {
        const startBtn = document.getElementById('start-transformation-btn');
        if (!startBtn) return;
        
        // Check if at least one transformation option is selected
        const hasSelection = [
          'check-distribution-analysis',
          'check-mathematical-transformations',
          'check-new-variables',
          'check-categorical-transformations',
          'check-datetime-transformations',
          'check-merging-combining',
          'check-aggregation-grouping',
          'check-statistical-transformations',
          'check-text-transformations',
          'check-spatial-transformations',
          'check-custom-transformations'
        ].some(id => document.getElementById(id)?.checked);
        
        if (!hasSelection) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select at least one transformation';
          startBtn.title = 'Please select at least one transformation operation';
          return;
        }
        
        // Check if all selected "Other" options have content
        const hasInvalidOther = [
          { checkbox: 'check-mathematical-transformations', input: 'math-transformations-custom-input', select: 'math-transformations-select' },
          { checkbox: 'check-new-variables', input: 'new-variables-custom-input', select: 'new-variables-select' },
          { checkbox: 'check-categorical-transformations', input: 'categorical-transformations-custom-input', select: 'categorical-transformations-select' },
          { checkbox: 'check-datetime-transformations', input: 'datetime-transformations-custom-input', select: 'datetime-transformations-select' },
          { checkbox: 'check-merging-combining', input: 'merging-combining-custom-input', select: 'merging-combining-select' },
          { checkbox: 'check-aggregation-grouping', input: 'aggregation-grouping-custom-input', select: 'aggregation-grouping-select' },
          { checkbox: 'check-statistical-transformations', input: 'statistical-transformations-custom-input', select: 'statistical-transformations-select' },
          { checkbox: 'check-text-transformations', input: 'text-transformations-custom-input', select: 'text-transformations-select' },
          { checkbox: 'check-spatial-transformations', input: 'spatial-transformations-custom-input', select: 'spatial-transformations-select' },
          { checkbox: 'check-custom-transformations', input: 'custom-transformations-custom-input', select: null }
        ].some(({ checkbox, input, select }) => {
          const checkboxEl = document.getElementById(checkbox);
          if (!checkboxEl?.checked) return false;
          
          // For custom transformations, always validate
          if (select === null) {
            const inputEl = document.getElementById(input);
            return inputEl && inputEl.value.trim() === '';
          }
          
          // For method-specific "other" options, only validate if method is set to "other"
          const selectEl = document.getElementById(select);
          if (selectEl && selectEl.value === 'other') {
            const inputEl = document.getElementById(input);
            return inputEl && inputEl.value.trim() === '';
          }
          
          return false;
        });
        
        if (hasInvalidOther) {
          startBtn.disabled = true;
          startBtn.textContent = 'Fill in "Other" options';
          startBtn.title = 'Please fill in all selected "Other" options';
          return;
        }
        
        // All validations passed
        startBtn.disabled = false;
        startBtn.textContent = '🚀 Start Transformation Agent';
        startBtn.title = 'Start the transformation agent with selected options';
      }
      
      // Helper function to add execute button to a code block
      function addExecuteButtonToCodeBlock(codeBlock, code) {
        console.log('🔍 Adding execute button to code block');
        console.log('🔍 Code block element:', codeBlock);
        console.log('🔍 Code block classes:', codeBlock.className);
        console.log('🔍 Code block children count:', codeBlock.children.length);
        
        // Add manual mode indicator and execute button
        const manualModeDiv = document.createElement('div');
        manualModeDiv.style.marginTop = '15px';
        manualModeDiv.style.padding = '10px';
        manualModeDiv.style.backgroundColor = '#f8f9fa';
        manualModeDiv.style.borderRadius = '6px';
        manualModeDiv.style.border = '1px solid #e9ecef';
        
        const manualModeText = document.createElement('div');
        manualModeText.innerHTML = '<strong>Auto Execute Off</strong>';
        manualModeText.style.marginBottom = '10px';
        manualModeText.style.color = '#495057';
        
        const executeButton = document.createElement('button');
        executeButton.textContent = 'Execute Cleaning Code';
        executeButton.className = 'execute-cleaning-button';
        executeButton.onclick = () => {
          executeCleaningCodeWithErrorHandling(code);
          // Remove the manual mode section after clicking
          manualModeDiv.remove();
        };
        
        manualModeDiv.appendChild(manualModeText);
        manualModeDiv.appendChild(executeButton);
        codeBlock.appendChild(manualModeDiv);
        
        console.log('✅ Execute button added to code block');
        console.log('🔍 Manual mode div added:', manualModeDiv);
        console.log('🔍 Execute button added:', executeButton);
        console.log('🔍 Code block children count after:', codeBlock.children.length);
        
        // Force a visual update
        manualModeDiv.style.display = 'block';
        executeButton.style.display = 'inline-block';
      }
      
      // Setup checkbox interactions
      function setupCheckboxInteractions() {
        const missingValuesCheckbox = document.getElementById('check-missing-values');
        const missingHandlingOptions = document.getElementById('missing-handling-options');
        
        // Show/hide missing values handling options
        missingValuesCheckbox.addEventListener('change', function() {
          if (this.checked && !this.disabled) {
            missingHandlingOptions.style.display = 'block';
          } else {
            missingHandlingOptions.style.display = 'none';
          }
        });
        
        // Trigger initial state
        if (missingValuesCheckbox.checked && !missingValuesCheckbox.disabled) {
          missingHandlingOptions.style.display = 'block';
        }
        
        // Setup other operations checkbox
        const otherCheckbox = document.getElementById('check-other');
        const otherOptions = document.getElementById('other-options');
        
        if (otherCheckbox && otherOptions) {
          // Show/hide other operations input
          otherCheckbox.addEventListener('change', function() {
            if (this.checked) {
              otherOptions.style.display = 'block';
            } else {
              otherOptions.style.display = 'none';
            }
          });
        }
        
        // Setup data type options
        const dataTypeCheckbox = document.getElementById('check-data-types');
        const dataTypeOptions = document.getElementById('data-type-options');
        const dataTypeMethodSelect = document.getElementById('data-type-method-select');
        const dataTypeOtherInput = document.getElementById('data-type-other-input');
        
        if (dataTypeCheckbox && dataTypeOptions) {
          dataTypeCheckbox.addEventListener('change', function() {
            if (this.checked) {
              dataTypeOptions.style.display = 'block';
            } else {
              dataTypeOptions.style.display = 'none';
            }
          });
          
          // Trigger initial state
          if (dataTypeCheckbox.checked) {
            dataTypeOptions.style.display = 'block';
          }
          
          // Show/hide custom input when "Other" is selected
          if (dataTypeMethodSelect) {
            dataTypeMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                dataTypeOtherInput.style.display = 'block';
              } else {
                dataTypeOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Setup missing values options
        const missingValuesMethodSelect = document.getElementById('na-handling-select');
        const missingValuesOtherInput = document.getElementById('missing-values-other-input');
        
        if (missingValuesMethodSelect) {
          missingValuesMethodSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              missingValuesOtherInput.style.display = 'block';
            } else {
              missingValuesOtherInput.style.display = 'none';
            }
          });
        }
        
        // Setup duplicates options
        const duplicatesCheckbox = document.getElementById('check-duplicates');
        const duplicatesOptions = document.getElementById('duplicates-options');
        
        if (duplicatesCheckbox && duplicatesOptions) {
          duplicatesCheckbox.addEventListener('change', function() {
            if (this.checked) {
              duplicatesOptions.style.display = 'block';
            } else {
              duplicatesOptions.style.display = 'none';
            }
          });
          
          // Trigger initial state
          if (duplicatesCheckbox.checked) {
            duplicatesOptions.style.display = 'block';
          }
        }
        
        // Setup outlier options
        const outlierCheckbox = document.getElementById('check-outliers');
        const outlierOptions = document.getElementById('outlier-method-options');
        const outlierMethodSelect = document.getElementById('outlier-method-select');
        const outlierOtherInput = document.getElementById('outlier-other-input');
        
        if (outlierCheckbox && outlierOptions) {
          outlierCheckbox.addEventListener('change', function() {
            if (this.checked) {
              outlierOptions.style.display = 'block';
            } else {
              outlierOptions.style.display = 'none';
            }
          });
          
          // Trigger initial state
          if (outlierCheckbox.checked) {
            outlierOptions.style.display = 'block';
          }
          
          // Show/hide custom input when "Other" is selected
          if (outlierMethodSelect) {
            outlierMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                outlierOtherInput.style.display = 'block';
              } else {
                outlierOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Setup column names options
        const columnNamesCheckbox = document.getElementById('check-column-names');
        const columnNamesOptions = document.getElementById('column-naming-options');
        const columnNamesMethodSelect = document.getElementById('column-naming-select');
        const columnNamesOtherInput = document.getElementById('column-naming-other-input');
        
        if (columnNamesCheckbox && columnNamesOptions) {
          columnNamesCheckbox.addEventListener('change', function() {
            if (this.checked) {
              columnNamesOptions.style.display = 'block';
            } else {
              columnNamesOptions.style.display = 'none';
            }
          });
          
          // Trigger initial state
          if (columnNamesCheckbox.checked) {
            columnNamesOptions.style.display = 'block';
          }
          
          // Show/hide custom input when "Other" is selected
          if (columnNamesMethodSelect) {
            columnNamesMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                columnNamesOtherInput.style.display = 'block';
              } else {
                columnNamesOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Setup auto-execute toggle
        const autoExecuteToggle = document.getElementById('auto-execute-toggle');
        if (autoExecuteToggle) {
          autoExecuteToggle.addEventListener('change', function() {
            const isEnabled = this.checked;
            console.log('🔧 Auto-execute toggle changed:', isEnabled ? 'ON' : 'OFF');
            
            // Update toggle label color based on state
            const toggleLabel = this.parentElement.querySelector('.toggle-label');
            if (toggleLabel) {
              toggleLabel.style.color = isEnabled ? '#27ae60' : '#666';
            }
          });
        }
        
      }
      
      // Setup transformation agent checkbox interactions
      function setupTransformationCheckboxInteractions() {
        console.log('🔍 Setting up transformation agent checkbox interactions...');
        
        // FIXED: Initialize start button state
        const startBtn = document.getElementById('start-transformation-btn');
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select a DataFrame first';
          startBtn.title = 'Please select a DataFrame to continue';
        }
        // Mathematical transformations
        const mathTransformCheckbox = document.getElementById('check-mathematical-transformations');
        const mathTransformOptions = document.getElementById('math-transformations-options');
        const mathTransformMethodSelect = document.getElementById('math-transformations-select');
        const mathTransformOtherInput = document.getElementById('math-transformations-other-input');
        
        if (mathTransformCheckbox && mathTransformOptions) {
          mathTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              mathTransformOptions.style.display = 'block';
            } else {
              mathTransformOptions.style.display = 'none';
            }
          });
          
          if (mathTransformMethodSelect) {
            mathTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                mathTransformOtherInput.style.display = 'block';
              } else {
                mathTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // New variables
        const newVarCheckbox = document.getElementById('check-new-variables');
        const newVarOptions = document.getElementById('new-variables-options');
        const newVarMethodSelect = document.getElementById('new-variables-select');
        const newVarOtherInput = document.getElementById('new-variables-custom-input');
        
        if (newVarCheckbox && newVarOptions) {
          newVarCheckbox.addEventListener('change', function() {
            if (this.checked) {
              newVarOptions.style.display = 'block';
            } else {
              newVarOptions.style.display = 'none';
            }
          });
          
          if (newVarMethodSelect) {
            newVarMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                newVarOtherInput.style.display = 'block';
              } else {
                newVarOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Categorical transformations
        const catTransformCheckbox = document.getElementById('check-categorical-transformations');
        const catTransformOptions = document.getElementById('categorical-transformations-options');
        const catTransformMethodSelect = document.getElementById('categorical-transformations-select');
        const catTransformOtherInput = document.getElementById('categorical-transformations-custom-input');
        
        if (catTransformCheckbox && catTransformOptions) {
          catTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              catTransformOptions.style.display = 'block';
            } else {
              catTransformOptions.style.display = 'none';
            }
          });
          
          if (catTransformMethodSelect) {
            catTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                catTransformOtherInput.style.display = 'block';
              } else {
                catTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Date/time transformations
        const dateTransformCheckbox = document.getElementById('check-datetime-transformations');
        const dateTransformOptions = document.getElementById('datetime-transformations-options');
        const dateTransformMethodSelect = document.getElementById('datetime-transformations-select');
        const dateTransformOtherInput = document.getElementById('datetime-transformations-custom-input');
        
        if (dateTransformCheckbox && dateTransformOptions) {
          dateTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              dateTransformOptions.style.display = 'block';
            } else {
              dateTransformOptions.style.display = 'none';
            }
          });
          
          if (dateTransformMethodSelect) {
            dateTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                dateTransformOtherInput.style.display = 'block';
              } else {
                dateTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Merging & combining
        const mergeCheckbox = document.getElementById('check-merging-combining');
        const mergeOptions = document.getElementById('merging-combining-options');
        const mergeMethodSelect = document.getElementById('merging-combining-select');
        const mergeOtherInput = document.getElementById('merging-combining-custom-input');
        
        if (mergeCheckbox && mergeOptions) {
          mergeCheckbox.addEventListener('change', function() {
            if (this.checked) {
              mergeOptions.style.display = 'block';
            } else {
              mergeOptions.style.display = 'none';
            }
          });
          
          if (mergeMethodSelect) {
            mergeMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                mergeOtherInput.style.display = 'block';
              } else {
                mergeOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Aggregation & grouping
        const aggCheckbox = document.getElementById('check-aggregation-grouping');
        const aggOptions = document.getElementById('aggregation-grouping-options');
        const aggMethodSelect = document.getElementById('aggregation-grouping-select');
        const aggOtherInput = document.getElementById('aggregation-grouping-custom-input');
        
        if (aggCheckbox && aggOptions) {
          aggCheckbox.addEventListener('change', function() {
            if (this.checked) {
              aggOptions.style.display = 'block';
            } else {
              aggOptions.style.display = 'none';
            }
          });
          
          if (aggMethodSelect) {
            aggMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                aggOtherInput.style.display = 'block';
            } else {
                aggOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Statistical transformations
        const statTransformCheckbox = document.getElementById('check-statistical-transformations');
        const statTransformOptions = document.getElementById('statistical-transformations-options');
        const statTransformMethodSelect = document.getElementById('statistical-transformations-select');
        const statTransformOtherInput = document.getElementById('statistical-transformations-custom-input');
        
        if (statTransformCheckbox && statTransformOptions) {
          statTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              statTransformOptions.style.display = 'block';
            } else {
              statTransformOptions.style.display = 'none';
            }
          });
          
          if (statTransformMethodSelect) {
            statTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                statTransformOtherInput.style.display = 'block';
              } else {
                statTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Text transformations
        const textTransformCheckbox = document.getElementById('check-text-transformations');
        const textTransformOptions = document.getElementById('text-transformations-options');
        const textTransformMethodSelect = document.getElementById('text-transformations-select');
        const textTransformOtherInput = document.getElementById('text-transformations-custom-input');
        
        if (textTransformCheckbox && textTransformOptions) {
          textTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              textTransformOptions.style.display = 'block';
            } else {
              textTransformOptions.style.display = 'none';
            }
          });
          
          if (textTransformMethodSelect) {
            textTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                textTransformOtherInput.style.display = 'block';
              } else {
                textTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Spatial transformations
        const spatialTransformCheckbox = document.getElementById('check-spatial-transformations');
        const spatialTransformOptions = document.getElementById('spatial-transformations-options');
        const spatialTransformMethodSelect = document.getElementById('spatial-transformations-select');
        const spatialTransformOtherInput = document.getElementById('spatial-transformations-custom-input');
        
        if (spatialTransformCheckbox && spatialTransformOptions) {
          spatialTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              spatialTransformOptions.style.display = 'block';
            } else {
              spatialTransformOptions.style.display = 'none';
            }
          });
          
          if (spatialTransformMethodSelect) {
            spatialTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                spatialTransformOtherInput.style.display = 'block';
              } else {
                spatialTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Custom transformations
        const customTransformCheckbox = document.getElementById('check-custom-transformations');
        const customTransformOptions = document.getElementById('custom-transformations-options');
        
        if (customTransformCheckbox && customTransformOptions) {
          customTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              customTransformOptions.style.display = 'block';
            } else {
              customTransformOptions.style.display = 'none';
            }
          });
        }
      }
      
      // Setup statistical agent checkbox interactions
      function setupStatisticalCheckboxInteractions() {
        console.log('🔍 Setting up statistical agent checkbox interactions...');
        
        // FIXED: Initialize start button state
        const startBtn = document.getElementById('start-statistical-btn');
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select a DataFrame first';
          startBtn.title = 'Please select a DataFrame to continue';
        }
        
        // Group comparisons
        const groupCompCheckbox = document.getElementById('check-group-comparisons');
        const groupCompOptions = document.getElementById('group-comparisons-options');
        
        if (groupCompCheckbox && groupCompOptions) {
          groupCompCheckbox.addEventListener('change', function() {
            if (this.checked) {
              groupCompOptions.style.display = 'block';
            } else {
              groupCompOptions.style.display = 'none';
            }
          });
        }
        
        // Before/after analysis
        const beforeAfterCheckbox = document.getElementById('check-before-after-analysis');
        const beforeAfterOptions = document.getElementById('before-after-options');
        
        if (beforeAfterCheckbox && beforeAfterOptions) {
          beforeAfterCheckbox.addEventListener('change', function() {
            if (this.checked) {
              beforeAfterOptions.style.display = 'block';
            } else {
              beforeAfterOptions.style.display = 'none';
            }
          });
        }
        
        // Power analysis
        const powerCheckbox = document.getElementById('check-power-analysis');
        const powerOptions = document.getElementById('power-analysis-options');
        
        if (powerCheckbox && powerOptions) {
          powerCheckbox.addEventListener('change', function() {
            if (this.checked) {
              powerOptions.style.display = 'block';
            } else {
              powerOptions.style.display = 'none';
            }
          });
        }
        
        // Multiple testing correction
        const multipleTestingCheckbox = document.getElementById('check-multiple-testing-correction');
        const multipleTestingOptions = document.getElementById('multiple-testing-options');
        
        if (multipleTestingCheckbox && multipleTestingOptions) {
          multipleTestingCheckbox.addEventListener('change', function() {
            if (this.checked) {
              multipleTestingOptions.style.display = 'block';
            } else {
              multipleTestingOptions.style.display = 'none';
            }
          });
        }
        
        // Effect size analysis
        const effectSizeCheckbox = document.getElementById('check-effect-size-analysis');
        const effectSizeOptions = document.getElementById('effect-size-options');
        
        if (effectSizeCheckbox && effectSizeOptions) {
          effectSizeCheckbox.addEventListener('change', function() {
            if (this.checked) {
              effectSizeOptions.style.display = 'block';
            } else {
              effectSizeOptions.style.display = 'none';
            }
          });
        }
        
        // Custom statistical analysis
        const customStatCheckbox = document.getElementById('check-custom-statistical-analysis');
        const customStatOptions = document.getElementById('custom-statistical-analysis-options');
        
        if (customStatCheckbox && customStatOptions) {
          customStatCheckbox.addEventListener('change', function() {
            if (this.checked) {
              customStatOptions.style.display = 'block';
            } else {
              customStatOptions.style.display = 'none';
            }
          });
        }
        
        // Nonparametric tests
        const nonparametricCheckbox = document.getElementById('check-nonparametric-tests');
        const nonparametricOptions = document.getElementById('nonparametric-tests-options');
        
        if (nonparametricCheckbox && nonparametricOptions) {
          nonparametricCheckbox.addEventListener('change', function() {
            if (this.checked) {
              nonparametricOptions.style.display = 'block';
            } else {
              nonparametricOptions.style.display = 'none';
            }
          });
        }
        
        // Categorical tests
        const categoricalCheckbox = document.getElementById('check-categorical-tests');
        const categoricalOptions = document.getElementById('categorical-tests-options');
        
        if (categoricalCheckbox && categoricalOptions) {
          categoricalCheckbox.addEventListener('change', function() {
            if (this.checked) {
              categoricalOptions.style.display = 'block';
            } else {
              categoricalOptions.style.display = 'none';
            }
          });
        }
      }
      
      // Setup modeling agent checkbox interactions
      function setupModelingCheckboxInteractions() {
        console.log('🔍 Setting up modeling agent checkbox interactions...');
        
        // Initialize start button state
        const startBtn = document.getElementById('start-modeling-btn');
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select a DataFrame first';
          startBtn.title = 'Please select a DataFrame to continue';
        }
        
        // Dimensionality reduction
        const drCheckbox = document.getElementById('check-dimensionality-reduction');
        const drOptions = document.getElementById('dimensionality-reduction-options');
        
        if (drCheckbox && drOptions) {
          drCheckbox.addEventListener('change', function() {
            if (this.checked) {
              drOptions.style.display = 'block';
            } else {
              drOptions.style.display = 'none';
            }
          });
        }
        
        // Custom modeling
        const customModelingCheckbox = document.getElementById('check-custom-modeling');
        const customModelingOptions = document.getElementById('custom-modeling-options');
        
        if (customModelingCheckbox && customModelingOptions) {
          customModelingCheckbox.addEventListener('change', function() {
            if (this.checked) {
              customModelingOptions.style.display = 'block';
            } else {
              customModelingOptions.style.display = 'none';
            }
          });
        }
        
        // Problem type change handler
        const problemTypeSelect = document.getElementById('modeling-problem-type');
        if (problemTypeSelect) {
          problemTypeSelect.addEventListener('change', function() {
            updateModelingStartButton();
          });
        }
        
        // Target variable change handler
        const targetVariableSelect = document.getElementById('modeling-target-variable');
        if (targetVariableSelect) {
          targetVariableSelect.addEventListener('change', function() {
            updateModelingStartButton();
          });
        }
      }
      
      // Show/hide variable selection for modeling algorithms
      function showHideModelingVariableSelection(checkboxId) {
        const checkbox = document.getElementById(checkboxId);
        if (!checkbox) return;
        
        // Map checkbox IDs to their corresponding options container IDs
        const optionMappings = {
          'check-dimensionality-reduction': 'dimensionality-reduction-options',
          'check-linear-regression': 'linear-regression-options',
          'check-logistic-regression': 'logistic-regression-options',
          'check-multinomial-regression': 'multinomial-regression-options',
          'check-random-forest': 'random-forest-options',
          'check-xgboost': 'xgboost-options',
          'check-feature-engineering': 'feature-engineering-options',
          'check-custom-modeling': 'custom-modeling-options'
        };
        
        const optionsId = optionMappings[checkboxId];
        if (optionsId) {
          const optionsContainer = document.getElementById(optionsId);
          if (optionsContainer) {
            if (checkbox.checked) {
              optionsContainer.style.display = 'block';
            } else {
              optionsContainer.style.display = 'none';
            }
          }
        }
      }
      
      // Add event listeners for modeling agent checkboxes and options
      function addModelingOptionListeners() {
        const checkboxes = [
          'check-dimensionality-reduction',
          'check-linear-regression',
          'check-logistic-regression',
          'check-multinomial-regression',
          'check-random-forest',
          'check-xgboost',
          'check-feature-engineering',
          'check-model-interpretability',
          'check-claude-plots',
          'check-custom-modeling'
        ];
        
        checkboxes.forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', function() {
              updateModelingStartButton();
              // Show/hide variable selection for modeling algorithms
              showHideModelingVariableSelection(id);
            });
          }
        });
        
        // Add listeners to method select dropdowns
        const methodSelects = [
          'dimensionality-reduction-select'
        ];
        
        methodSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateModelingStartButton);
          }
        });
      }
      
      // Add event listeners for statistical agent checkboxes and options
      function addStatisticalOptionListeners() {
        const checkboxes = [
          'check-basic-statistics',
          'check-group-comparisons',
          'check-categorical-tests',
          'check-before-after-analysis',
          'check-effect-size-analysis',
          'check-power-analysis',
          'check-multiple-testing-correction',
          'check-custom-statistical-analysis'
        ];
        
        checkboxes.forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', updateStatisticalStartButton);
          }
        });
        
        // Add listeners to method select dropdowns
        const methodSelects = [
          'group-comparisons-select',
          'nonparametric-tests-select',
          'categorical-tests-select',
          'before-after-select',
          'effect-size-select',
          'power-analysis-select',
          'multiple-testing-select'
        ];
        
        methodSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateStatisticalStartButton);
          }
        });
        
        // Add listener for effect size "Other" option
        const effectSizeSelect = document.getElementById('effect-size-select');
        const effectSizeCustomInput = document.getElementById('effect-size-custom-input');
        if (effectSizeSelect && effectSizeCustomInput) {
          effectSizeSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              effectSizeCustomInput.style.display = 'block';
            } else {
              effectSizeCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for power analysis "Other" option
        const powerAnalysisSelect = document.getElementById('power-analysis-select');
        const powerAnalysisCustomInput = document.getElementById('power-analysis-custom-input');
        if (powerAnalysisSelect && powerAnalysisCustomInput) {
          powerAnalysisSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              powerAnalysisCustomInput.style.display = 'block';
            } else {
              powerAnalysisCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for multiple testing "Other" option
        const multipleTestingSelect = document.getElementById('multiple-testing-select');
        const multipleTestingCustomInput = document.getElementById('multiple-testing-custom-input');
        if (multipleTestingSelect && multipleTestingCustomInput) {
          multipleTestingSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              multipleTestingCustomInput.style.display = 'block';
            } else {
              multipleTestingCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for group comparisons "Other" option
        const groupComparisonsSelect = document.getElementById('group-comparisons-select');
        const groupComparisonsCustomInput = document.getElementById('group-comparisons-custom-input');
        if (groupComparisonsSelect && groupComparisonsCustomInput) {
          groupComparisonsSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              groupComparisonsCustomInput.style.display = 'block';
            } else {
              groupComparisonsCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for nonparametric tests "Other" option
        const nonparametricTestsSelect = document.getElementById('nonparametric-tests-select');
        const nonparametricTestsCustomInput = document.getElementById('nonparametric-tests-custom-input');
        if (nonparametricTestsSelect && nonparametricTestsCustomInput) {
          nonparametricTestsSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              nonparametricTestsCustomInput.style.display = 'block';
            } else {
              nonparametricTestsCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for categorical tests "Other" option
        const categoricalTestsSelect = document.getElementById('categorical-tests-select');
        const categoricalTestsCustomInput = document.getElementById('categorical-tests-custom-input');
        if (categoricalTestsSelect && categoricalTestsCustomInput) {
          categoricalTestsSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              categoricalTestsCustomInput.style.display = 'block';
            } else {
              categoricalTestsCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for before/after analysis "Other" option
        const beforeAfterSelect = document.getElementById('before-after-select');
        const beforeAfterCustomInput = document.getElementById('before-after-custom-input');
        if (beforeAfterSelect && beforeAfterCustomInput) {
          beforeAfterSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              beforeAfterCustomInput.style.display = 'block';
            } else {
              beforeAfterCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listeners to variable selection dropdowns
        const variableSelects = [
          'statistical-continuous-var',
          'statistical-grouping-var',
          'statistical-before-var',
          'statistical-after-var',
          'categorical-var1',
          'categorical-var2'
        ];
        
        variableSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateStatisticalStartButton);
          }
        });
      }
      
      // Update statistical start button based on selections
      function updateStatisticalStartButton() {
        const startBtn = document.getElementById('start-statistical-btn');
        if (!startBtn) return;
        
        // Check if at least one analysis option is selected
        const hasSelection = [
          'check-basic-statistics',
          'check-group-comparisons',
          'check-categorical-tests',
          'check-before-after-analysis',
          'check-effect-size-analysis',
          'check-power-analysis',
          'check-multiple-testing-correction',
          'check-custom-statistical-analysis'
        ].some(id => document.getElementById(id)?.checked);
        
        if (!hasSelection) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select at least one analysis type';
          startBtn.title = 'Please select at least one statistical analysis';
          return;
        }
        
        // Check if required variables are selected for group comparisons
        if (document.getElementById('check-group-comparisons')?.checked) {
          const continuousVar = document.getElementById('statistical-continuous-var')?.value;
          const groupingVar = document.getElementById('statistical-grouping-var')?.value;
          
          if (!continuousVar || !groupingVar) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select variables for group comparisons';
            startBtn.title = 'Please select both continuous and grouping variables';
            return;
          }
        }
        
        // Check if required variables are selected for before/after analysis
        if (document.getElementById('check-before-after-analysis')?.checked) {
          const beforeVar = document.getElementById('statistical-before-var')?.value;
          const afterVar = document.getElementById('statistical-after-var')?.value;
          
          if (!beforeVar || !afterVar) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select variables for before/after analysis';
            startBtn.title = 'Please select both before and after variables';
            return;
          }
        }
        
        // Check if required variables are selected for categorical tests
        if (document.getElementById('check-categorical-tests')?.checked) {
          const catVar1 = document.getElementById('categorical-var1')?.value;
          const catVar2 = document.getElementById('categorical-var2')?.value;
          
          if (!catVar1 || !catVar2) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select variables for categorical tests';
            startBtn.title = 'Please select both categorical variables';
            return;
          }
        }
        
        // All validations passed
        startBtn.disabled = false;
        startBtn.textContent = '🚀 Start Statistical Analysis Agent';
        startBtn.title = 'Start the statistical analysis agent with selected options';
      }
      
      // Handle agent started response
      function handleAgentStarted(result) {
        // Track current agent type for success messages
        window.currentActiveAgentType = 'Cleaning';
        
        if (result.success) {
          const totalSteps = result.total_steps || result.workflow_steps?.length || 'Unknown';
          const stepNum = result.current_step?.step || 1;
          const stepDesc = result.current_step?.description || 'Starting...';
          
          // Show selected cleaning operations
          const selectedOps = [];
          if (result.cleaning_options) {
            if (result.cleaning_options.dataTypes) selectedOps.push('📊 Data Types');
            if (result.cleaning_options.missingValues) selectedOps.push('⚠️ Missing Values');
            if (result.cleaning_options.duplicates) selectedOps.push('🔄 Duplicates');
            if (result.cleaning_options.outliers) selectedOps.push('📈 Outliers');
            if (result.cleaning_options.other) selectedOps.push('🔧 Custom Operations');
            if (result.cleaning_options.columnNames) selectedOps.push('🏷️ Column Names');
          }
          
          // Add custom operations text if available
          if (result.other_operations && result.other_operations.trim()) {
            selectedOps.push(`🔧 Custom: ${result.other_operations}`);
          }
          
          const opsText = selectedOps.length > 0 ? `\n🔧 **Operations:**\n   ${selectedOps.join('\n   ')}` : '';
          
          addMessage(`**Cleaning Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** ${stepDesc}`, 'ai');
          
          console.log('Agent started with workflow:', result);
          
          // Initialize the workflow tracking
          currentAgentWorkflow = {
            dataframe: result.dataframe,
            naHandling: result.na_handling,
            cleaningOptions: result.cleaning_options,
            methodOptions: result.method_options,
            customInputs: result.custom_inputs,
            workflowSteps: result.workflow_steps,
            currentStep: 1,
            totalSteps: result.total_steps
          };
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          // Execute the first step
          if (result.current_step && result.current_step.code) {
            console.log('Executing first step code:', result.current_step.code);
            
            // Store the code for later display
            currentStepCode = result.current_step.code;
            
            // Send code execution request via WebSocket
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: result.current_step.code
              }));
            }
          } else {
            console.log('No code to execute for first step');
          }
        } else {
          addMessage(`❌ **Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Handle transformation agent started response
      function handleTransformationAgentStarted(result) {
        console.log('🔍 handleTransformationAgentStarted called with:', result);
        
        // Track current agent type for success messages
        window.currentActiveAgentType = 'Transformation';
        
        if (result.success) {
          const totalSteps = result.total_steps || result.workflow_steps?.length || 'Unknown';
          const stepNum = result.current_step?.step || 1;
          const stepDesc = result.current_step?.description || 'Starting...';
          
          // Show selected transformation operations
          const selectedOps = [];
          if (result.transformation_options) {
            if (result.transformation_options.distributionAnalysis) selectedOps.push('📊 Distribution Analysis');
            if (result.transformation_options.mathematicalTransformations) selectedOps.push('🧮 Mathematical Transformations');
            if (result.transformation_options.newVariables) selectedOps.push('➕ New Variables');
            if (result.transformation_options.categoricalTransformations) selectedOps.push('🏷️ Categorical Transformations');
            if (result.transformation_options.dateTimeTransformations) selectedOps.push('📅 Date/Time Transformations');
            if (result.transformation_options.mergingCombining) selectedOps.push('🔗 Merging & Combining');
            if (result.transformation_options.aggregationGrouping) selectedOps.push('📊 Aggregation & Grouping');
            if (result.transformation_options.statisticalTransformations) selectedOps.push('📈 Statistical Transformations');
            if (result.transformation_options.textTransformations) selectedOps.push('📝 Text Transformations');
            if (result.transformation_options.spatialTransformations) selectedOps.push('🗺️ Spatial Transformations');
            if (result.transformation_options.customTransformations) selectedOps.push('⚙️ Custom Transformations');
          }
          
          const opsText = selectedOps.length > 0 ? `\n🔄 **Operations:**\n   ${selectedOps.join('\n   ')}` : '';
          
          addMessage(`**🔄 Transformation Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** ${stepDesc}${opsText}`, 'ai');
          
          console.log('Transformation agent started with workflow:', result);
          
          // Initialize the workflow tracking
          currentAgentWorkflow = {
            dataframe: result.dataframe,
            transformationOptions: result.transformation_options,
            methodOptions: result.method_options,
            customInputs: result.custom_inputs,
            workflowSteps: result.workflow_steps,
            currentStep: 1,
            totalSteps: result.total_steps
          };
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // FIXED: Don't transform button here - let the workflow handle it
          // transformToAgentStopButton();
          
          // Execute the first step
          if (result.current_step && result.current_step.code) {
            console.log('Executing first transformation step code:', result.current_step.code);
            
            // Store the code for later display
            currentStepCode = result.current_step.code;
            
            // Send code execution request via WebSocket
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: result.current_step.code
              }));
            }
          } else {
            console.log('No code to execute for first transformation step');
          }
        } else {
          addMessage(`❌ **Transformation Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Handle statistical agent started response
      function handleStatisticalAgentStarted(result) {
        console.log('🔍 handleStatisticalAgentStarted called with:', result);
        
        // Track current agent type for success messages
        window.currentActiveAgentType = 'Statistical';
        
        if (result.success) {
          const totalSteps = result.total_steps || result.workflow_steps?.length || 'Unknown';
          const stepNum = result.current_step?.step || 1;
          const stepDesc = result.current_step?.description || 'Starting...';
          
          // Show selected statistical analysis operations
          const selectedOps = [];
          if (result.analysis_options) {
            if (result.analysis_options.basicStatistics) selectedOps.push('📈 Basic Statistics & Distributions');
            if (result.analysis_options.groupComparisons) selectedOps.push('🆚 Group Comparisons');
            if (result.analysis_options.beforeAfterAnalysis) selectedOps.push('📈 Before/After Analysis');
            if (result.analysis_options.effectSizeAnalysis) selectedOps.push('📏 Effect Size Analysis');
            if (result.analysis_options.powerAnalysis) selectedOps.push('⚡ Power Analysis');
            if (result.analysis_options.multipleTestingCorrection) selectedOps.push('🔄 Multiple Testing Correction');
          }
          
          const opsText = selectedOps.length > 0 ? `\n📊 **Operations:**\n   ${selectedOps.join('\n   ')}` : '';
          
          addMessage(`**📊 Statistical Analysis Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** ${stepDesc}${opsText}`, 'ai');
          
          console.log('Statistical analysis agent started with workflow:', result);
          
          // Initialize the workflow tracking
          currentAgentWorkflow = {
            dataframe: result.dataframe,
            analysisOptions: result.analysis_options,
            methodOptions: result.method_options,
            variables: result.variables,
            customInputs: result.custom_inputs,
            workflowSteps: result.workflow_steps,
            currentStep: 1,
            totalSteps: result.total_steps
          };
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Execute the first step
          if (result.current_step && result.current_step.code) {
            console.log('Executing first statistical analysis step code:', result.current_step.code);
            
            // Store the code for later display
            currentStepCode = result.current_step.code;
            
            // Send code execution request via WebSocket
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: result.current_step.code
              }));
            }
          } else {
            console.log('No code to execute for first statistical analysis step');
            // For statistical analysis steps without code, process the results and move to next step
            if (result.current_step && result.current_step.results) {
              console.log('Processing statistical step results:', result.current_step.results);
              
              // Display the results
              displayStatisticalStepResults(result.current_step);
              
              // Move to next step
              requestNextStatisticalStep();
            }
          }
        } else {
          addMessage(`❌ **Statistical Analysis Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Display statistical step results
      function displayStatisticalStepResults(stepResult) {
        console.log('Displaying statistical step results:', stepResult);
        
        if (stepResult.operation === 'data_overview') {
          let message = `**📊 Data Overview Results**\n\n`;
          
          if (stepResult.results && stepResult.results.structure) {
            const structure = stepResult.results.structure;
            message += `**📋 Data Structure:**\n`;
            message += `- Observations: ${structure.observation_count}\n`;
            message += `- Variables: ${structure.variable_count}\n`;
            message += `- Size: ${(structure.memory_usage / 1024).toFixed(1)} KB\n\n`;
          }
          
          if (stepResult.results && stepResult.results.data_types) {
            message += `**🏷️ Variable Types:**\n`;
            Object.entries(stepResult.results.data_types).forEach(([variable, type]) => {
              message += `- ${variable}: ${type}\n`;
            });
            message += `\n`;
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'distribution_analysis') {
          let message = `**📈 Distribution Analysis Results**\n\n`;
          
          if (stepResult.results) {
            Object.entries(stepResult.results).forEach(([variable, analysis]) => {
              if (variable !== 'success' && variable !== 'step' && variable !== 'operation' && variable !== 'message') {
                message += `**${variable}:**\n`;
                
                if (analysis.normality_test) {
                  const test = analysis.normality_test;
                  message += `- Normality: ${test.method} (p=${test.p_value.toFixed(4)}) - ${test.is_normal ? 'Normal' : 'Non-normal'}\n`;
                }
                
                if (analysis.distribution_characteristics) {
                  const dist = analysis.distribution_characteristics;
                  message += `- Mean: ${dist.mean.toFixed(2)}, Median: ${dist.median.toFixed(2)}\n`;
                  message += `- Std Dev: ${dist.sd.toFixed(2)}, Skewness: ${dist.skewness.toFixed(2)}\n`;
                }
                
                if (analysis.outlier_analysis) {
                  const outliers = analysis.outlier_analysis;
                  message += `- Outliers: ${outliers.outlier_count} (${outliers.outlier_percentage}%)\n`;
                }
                
                message += `\n`;
              }
            });
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'group_comparisons') {
          let message = `**🆚 Group Comparisons Results**\n\n`;
          
          if (stepResult.results) {
            if (stepResult.results.test_type) {
              message += `**Test:** ${stepResult.results.test_type}\n`;
            }
            if (stepResult.results.test_result) {
              const result = stepResult.results.test_result;
              if (result.f_statistic) {
                message += `**F-statistic:** ${result.f_statistic.toFixed(3)}\n`;
                message += `**p-value:** ${result.p_value.toFixed(4)}\n`;
                message += `**Significance:** ${result.significance ? 'Significant' : 'Not significant'}\n`;
              }
              if (result.t_statistic) {
                message += `**t-statistic:** ${result.t_statistic.toFixed(3)}\n`;
                message += `**p-value:** ${result.p_value.toFixed(4)}\n`;
                message += `**Significance:** ${result.p_value < 0.05 ? 'Significant' : 'Not significant'}\n`;
              }
            }
            if (stepResult.results.effect_size) {
              const effect = stepResult.results.effect_size;
              if (effect.eta_squared) {
                message += `**Effect Size (η²):** ${effect.eta_squared.toFixed(3)} (${effect.interpretation})\n`;
              }
              if (effect.cohens_d) {
                message += `**Effect Size (Cohen's d):** ${effect.cohens_d.toFixed(3)} (${effect.interpretation})\n`;
              }
            }
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'before_after_analysis') {
          let message = `**📈 Before/After Analysis Results**\n\n`;
          
          if (stepResult.results?.descriptive) {
            const desc = stepResult.results.descriptive;
            message += `**Descriptive Statistics:**\n`;
            message += `- Paired observations: ${desc.n_pairs}\n`;
            message += `- Before mean: ${desc.before_mean.toFixed(3)}\n`;
            message += `- After mean: ${desc.after_mean.toFixed(3)}\n`;
            message += `- Mean difference: ${desc.mean_difference.toFixed(3)}\n\n`;
          }
          
          if (stepResult.results?.paired_test) {
            const test = stepResult.results.paired_test;
            message += `**Paired t-test:**\n`;
            message += `- t-statistic: ${test.t_statistic.toFixed(3)}\n`;
            message += `- p-value: ${test.p_value.toFixed(4)}\n`;
            message += `- Result: ${test.significance ? 'Significant difference' : 'No significant difference'}\n\n`;
          }
          
          if (stepResult.results?.effect_size) {
            const effect = stepResult.results.effect_size;
            message += `**Effect Size:**\n`;
            message += `- Cohen's d: ${effect.cohens_d.toFixed(3)} (${effect.interpretation})\n`;
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'power_analysis') {
          let message = `**⚡ Power Analysis Results**\n\n`;
          
          if (stepResult.results?.current_sample_size) {
            message += `**Current Sample Size:** ${stepResult.results.current_sample_size}\n\n`;
          }
          
          if (stepResult.results?.basic_guidelines) {
            const guidelines = stepResult.results.basic_guidelines;
            message += `**Sample Size Guidelines (80% power, α=0.05):**\n`;
            message += `**Two-group t-test:**\n`;
            message += `- Small effect: ${guidelines.two_group_ttest.small_effect}\n`;
            message += `- Medium effect: ${guidelines.two_group_ttest.medium_effect}\n`;
            message += `- Large effect: ${guidelines.two_group_ttest.large_effect}\n\n`;
            if (stepResult.results.note) {
              message += `*${stepResult.results.note}*\n`;
            }
          }
          
          if (stepResult.results?.two_sample_ttest) {
            message += `**T-test Power Analysis:**\n`;
            Object.entries(stepResult.results.two_sample_ttest).forEach(([size, analysis]) => {
              message += `- ${size.replace('_', ' ')}: Power = ${analysis.power.toFixed(3)}, Required n = ${analysis.required_n}\n`;
            });
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'multiple_testing_correction') {
          let message = `**🔄 Multiple Testing Correction Results**\n\n`;
          
          if (stepResult.results?.number_of_tests) {
            message += `**Number of tests:** ${stepResult.results.number_of_tests}\n\n`;
          }
          
          if (stepResult.results?.comparison) {
            const comp = stepResult.results.comparison;
            message += `**Significant Tests:**\n`;
            message += `- Uncorrected: ${comp.uncorrected_significant}\n`;
            message += `- Bonferroni: ${comp.bonferroni_significant}\n`;
            message += `- Benjamini-Hochberg (FDR): ${comp.fdr_significant}\n`;
            message += `- Holm: ${comp.holm_significant}\n\n`;
          }
          
          if (stepResult.results?.interpretation) {
            const interp = stepResult.results.interpretation;
            message += `**Recommendations:**\n`;
            message += `- Most conservative: ${interp.most_conservative}\n`;
            message += `- Balanced approach: ${interp.balanced_approach}\n`;
            message += `- ${interp.recommendation}\n`;
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'custom_statistical_analysis') {
          let message = `**🔧 Custom Statistical Analysis**\n\n`;
          
          if (stepResult.results?.description) {
            message += `**Custom Request:** ${stepResult.results.description}\n\n`;
          }
          
          if (stepResult.results?.data_context) {
            const ctx = stepResult.results.data_context;
            message += `**Dataset:** ${ctx.dataframe_name} (${ctx.n_rows} rows × ${ctx.n_cols} columns)\n`;
            message += `**Variables:** ${ctx.column_names.join(', ')}\n\n`;
          }
          
          message += `**Status:** ${stepResult.results?.status || 'Preparing custom analysis'}\n\n`;
          message += `🤖 **Sending custom analysis request to Claude for interpretation and code generation...**\n\n`;
          
          addMessage(message, 'ai');
          
          // Send custom analysis request to Claude
          if (stepResult.claude_prompt && ws && ws.readyState === WebSocket.OPEN) {
            console.log('🔍 Sending custom statistical analysis to Claude');
            
            // Set flag to prevent duplicate requests
            window.customStatisticalAnalysisInProgress = true;
            
            ws.send(JSON.stringify({
              action: 'chat_with_ai',
              message: stepResult.claude_prompt,
              conversation_context: 'custom_statistical_analysis',
              agentType: 'statistical'
            }));
          }
        } else {
          // Generic display for other operations
          let operationName = stepResult.operation || stepResult.test || 'Statistical Analysis';
          let message = `**📊 ${operationName.replace('_', ' ').toUpperCase()} Results**\n\n`;
          message += `Analysis completed successfully.\n`;
          addMessage(message, 'ai');
        }
      }
      
      // Handle statistical step result
      function handleStatisticalStepResult(stepResult) {
        console.log('Processing statistical step result:', stepResult);
        
        if (stepResult.success) {
          // Store result for final summary
          agentResults.push({
            description: (stepResult.operation || stepResult.test || 'Statistical Analysis').replace('_', ' ').toUpperCase(),
            output: formatStatisticalResultForSummary(stepResult),
            step: stepResult.step
          });
          
          // Display the results
          displayStatisticalStepResults(stepResult);
          
          // Move to next step
          requestNextStatisticalStep();
        } else {
          addMessage(`❌ **Statistical Analysis Error:** ${stepResult.error}`, 'ai');
          finishAgentWorkflow();
        }
      }
      
      // Format statistical result for Claude summary
      function formatStatisticalResultForSummary(stepResult) {
        if (stepResult.operation === 'data_overview') {
          let summary = `Dataset: ${stepResult.results?.structure?.observation_count} observations, ${stepResult.results?.structure?.variable_count} variables\n`;
          if (stepResult.results?.data_types) {
            const types = Object.entries(stepResult.results.data_types);
            summary += `Variable types: ${types.map(([name, type]) => `${name}(${type})`).join(', ')}\n`;
          }
          return summary;
        } else if (stepResult.operation === 'distribution_analysis') {
          let summary = 'Distribution Analysis:\n';
          if (stepResult.results) {
            Object.entries(stepResult.results).forEach(([variable, analysis]) => {
              if (variable !== 'success' && variable !== 'step' && variable !== 'operation' && variable !== 'message') {
                summary += `${variable}: `;
                if (analysis.normality_test) {
                  summary += `${analysis.normality_test.is_normal ? 'Normal' : 'Non-normal'} distribution, `;
                }
                if (analysis.outlier_analysis) {
                  summary += `${analysis.outlier_analysis.outlier_count} outliers (${analysis.outlier_analysis.outlier_percentage}%)`;
                }
                summary += '\n';
              }
            });
          }
          return summary;
        } else if (stepResult.operation === 'group_comparisons') {
          let summary = 'Group Comparisons:\n';
          if (stepResult.results?.test_type) {
            summary += `Test: ${stepResult.results.test_type}\n`;
          }
          if (stepResult.results?.test_result) {
            const result = stepResult.results.test_result;
            if (result.p_value !== undefined) {
              summary += `p-value: ${result.p_value.toFixed(4)}, ${result.p_value < 0.05 ? 'Significant' : 'Not significant'}\n`;
            }
          }
          if (stepResult.results?.effect_size) {
            const effect = stepResult.results.effect_size;
            if (effect.eta_squared) {
              summary += `Effect size (η²): ${effect.eta_squared.toFixed(3)}\n`;
            }
            if (effect.cohens_d) {
              summary += `Effect size (Cohen's d): ${effect.cohens_d.toFixed(3)}\n`;
            }
          }
          return summary;
        } else if (stepResult.operation === 'before_after_analysis') {
          let summary = 'Before/After Analysis:\n';
          if (stepResult.results?.paired_test) {
            const test = stepResult.results.paired_test;
            summary += `Test: ${test.test_type}, p-value: ${test.p_value.toFixed(4)}, ${test.significance ? 'Significant' : 'Not significant'}\n`;
          }
          if (stepResult.results?.effect_size) {
            summary += `Effect size (Cohen's d): ${stepResult.results.effect_size.cohens_d.toFixed(3)}\n`;
          }
          return summary;
        } else if (stepResult.operation === 'power_analysis') {
          let summary = 'Power Analysis:\n';
          if (stepResult.results?.current_sample_size) {
            summary += `Current sample size: ${stepResult.results.current_sample_size}\n`;
          }
          if (stepResult.results?.basic_guidelines) {
            summary += 'Sample size guidelines for 80% power provided\n';
          }
          return summary;
        } else if (stepResult.operation === 'multiple_testing_correction') {
          let summary = 'Multiple Testing Correction:\n';
          if (stepResult.results?.comparison) {
            const comp = stepResult.results.comparison;
            summary += `Uncorrected: ${comp.uncorrected_significant} significant tests\n`;
            summary += `Bonferroni: ${comp.bonferroni_significant} significant tests\n`;
            summary += `FDR: ${comp.fdr_significant} significant tests\n`;
          }
          return summary;
        } else if (stepResult.operation === 'custom_statistical_analysis') {
          let summary = 'Custom Statistical Analysis:\n';
          if (stepResult.results?.description) {
            summary += `Request: ${stepResult.results.description.substring(0, 100)}${stepResult.results.description.length > 100 ? '...' : ''}\n`;
          }
          summary += 'Sent to Claude for interpretation and code generation\n';
          return summary;
        } else if (stepResult.test) {
          // Handle categorical tests and other tests with 'test' property
          let summary = `${stepResult.test}:\n`;
          if (stepResult.result) {
            const result = stepResult.result;
            if (result.statistic !== undefined) {
              summary += `Test statistic: ${result.statistic.toFixed(4)}\n`;
            }
            if (result.p_value !== undefined) {
              summary += `p-value: ${result.p_value.toFixed(4)}, ${result.p_value < 0.05 ? 'Significant' : 'Not significant'}\n`;
            }
            if (result.parameter !== undefined) {
              summary += `Degrees of freedom: ${result.parameter}\n`;
            }
            if (result.method) {
              summary += `Method: ${result.method}\n`;
            }
          }
          if (stepResult.contingency_table) {
            summary += `Contingency table available\n`;
          }
          if (stepResult.interpretation) {
            summary += `Interpretation: ${stepResult.interpretation}\n`;
          }
          return summary;
        }
        return 'Analysis completed successfully';
      }
      
      // Request next statistical step
      function requestNextStatisticalStep() {
        if (!currentAgentWorkflow) return;
        
        currentAgentWorkflow.currentStep++;
        console.log(`Requesting next statistical step: ${currentAgentWorkflow.currentStep}/${currentAgentWorkflow.totalSteps}`);
        
        if (currentAgentWorkflow.currentStep <= currentAgentWorkflow.workflowSteps.length) {
          const nextStep = currentAgentWorkflow.workflowSteps[currentAgentWorkflow.currentStep - 1];
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              action: 'get_next_statistical_step_code',
              dataframe: currentAgentWorkflow.dataframe,
              step_info: nextStep,
              variables: currentAgentWorkflow.variables,
              method_options: currentAgentWorkflow.methodOptions,
              custom_inputs: currentAgentWorkflow.customInputs
            }));
          }
        } else {
          console.log('Statistical analysis workflow completed');
          finishAgentWorkflow();
        }
      }
      
      // Finish agent workflow  
      function finishAgentWorkflow() {
        console.log('Finishing agent workflow');
        
        // Check if custom analysis is in progress - if so, skip normal summary
        if (window.customStatisticalAnalysisInProgress || window.customTransformationInProgress) {
          console.log('Custom analysis in progress, skipping normal workflow completion');
          // Clear workflow state without sending summary
          currentAgentWorkflow = null;
          agentResults = [];
          agentCodes = [];
          // Reset button will be handled by finishStreaming() when Claude response completes
          return;
        }
        
        // Determine agent type and send appropriate summary
        const agentType = window.currentActiveAgentType || 'Unknown';
        
        if (agentType === 'Statistical') {
          sendStatisticalSummaryToClaude();
        } else if (agentType === 'Transformation') {
          sendTransformationSummaryToClaude();
        } else {
          // Default to statistical for backward compatibility
          sendStatisticalSummaryToClaude();
        }
        
        // Clear workflow state
        currentAgentWorkflow = null;
        agentResults = [];
        agentCodes = [];
        
        // Reset button will be handled by finishStreaming() when Claude response completes
      }
      
      // Send statistical analysis summary to Claude
      function sendStatisticalSummaryToClaude() {
        if (!currentAgentWorkflow) return;
        
        addMessage(`📊 **Analyzing Results...** Sending statistical findings to Claude for comprehensive summary.`, 'ai');
        
        // Format results for Claude
        const summaryText = `Analyze these statistical analysis results for the "${currentAgentWorkflow.dataframe}" dataset and provide a BRIEF summary:

${agentResults.map(result => `
**${result.description}:**
${result.output}
`).join('\n')}

Provide a CONCISE summary (max 3-4 sentences) covering:
- Key statistical findings
- Data quality insights  
- Main patterns or issues discovered

Keep it brief and focused. Dataset: ${currentAgentWorkflow.dataframe}`;

        // Send to Claude for analysis
        if (ws && ws.readyState === WebSocket.OPEN) {
          window.lastMessageContext = "agent_summary";
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: summaryText,
            conversation_context: 'data_statistical_agent_summary'
          }));
        }
        
        // Store the agent type and results for the follow-up code request
        // We'll send this after the first response completes
        window.pendingAgentCodeRequest = {
          agentType: 'statistical',
          operationType: 'statistical analysis',
          agentResults,
          currentAgentWorkflow: currentAgentWorkflow
        };
      }
      
      // Send transformation analysis summary to Claude
      function sendTransformationSummaryToClaude() {
        if (!currentAgentWorkflow) return;
        
        addMessage(`🔄 **Analyzing Results...** Sending transformation findings to Claude for comprehensive summary.`, 'ai');
        
        // Format results for Claude
        const summaryText = `Analyze these data transformation results for the "${currentAgentWorkflow.dataframe}" dataset and provide a BRIEF summary:

${agentResults.map(result => `
**${result.description}:**
${result.output}
`).join('\n')}

Provide a CONCISE summary (max 3-4 sentences) covering:
- Key transformation changes made
- Data quality improvements
- New variables or structures created

Keep it brief and focused. Dataset: ${currentAgentWorkflow.dataframe}`;

        // Send to Claude for analysis
        if (ws && ws.readyState === WebSocket.OPEN) {
          window.lastMessageContext = "agent_summary";
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: summaryText,
            conversation_context: 'data_transformation_agent_summary'
          }));
        }
        
        // Store the agent type and results for the follow-up code request
        // We'll send this after the first response completes
        window.pendingAgentCodeRequest = {
          agentType: 'transformation',
          operationType: 'data transformation',
          agentResults,
          currentAgentWorkflow: currentAgentWorkflow
        };
      }
      
      // Handle modeling agent started response
      function handleModelingAgentStarted(result) {
        console.log('🔍 handleModelingAgentStarted called with:', result);
        
        // Track current agent type for success messages
        window.currentActiveAgentType = 'Modeling';
        
        if (result.success) {
          const totalSteps = result.total_steps || result.workflow_steps?.length || 'Unknown';
          const stepNum = result.current_step?.step || 1;
          const stepDesc = result.current_step?.description || 'Starting...';
          
          // Show selected modeling algorithms
          const selectedAlgorithms = [];
          if (result.algorithms) {
            if (result.algorithms.dimensionalityReduction) selectedAlgorithms.push('📉 Dimensionality Reduction');
            if (result.algorithms.linearRegression) selectedAlgorithms.push('📈 Linear Regression');
            if (result.algorithms.logisticRegression) selectedAlgorithms.push('🔗 Logistic Regression');
            if (result.algorithms.multinomialRegression) selectedAlgorithms.push('🔗 Multinomial Regression');
            if (result.algorithms.randomForest) selectedAlgorithms.push('🌲 Random Forest');
            if (result.algorithms.xgboost) selectedAlgorithms.push('🚀 XGBoost');
          }
          
          const algorithmsText = selectedAlgorithms.length > 0 ? `\n🤖 **Algorithms:**\n   ${selectedAlgorithms.join('\n   ')}` : '';
          
          addMessage(`**🤖 Modeling Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** ${stepDesc}${algorithmsText}`, 'ai');
          
          console.log('Modeling agent started with workflow:', result);
          
          // Initialize the workflow tracking
          currentAgentWorkflow = {
            dataframe: result.dataframe,
            targetVariable: result.target_variable,
            algorithms: result.algorithms,
            options: result.options,
            workflowSteps: result.workflow_steps,
            selected_variables: result.selected_variables,
            currentStep: 1,
            totalSteps: result.total_steps
          };
          
          console.log('🔍 Modeling agent workflow initialized:', {
            dataframe: currentAgentWorkflow.dataframe,
            targetVariable: currentAgentWorkflow.targetVariable,
            algorithms: currentAgentWorkflow.algorithms,
            selected_variables: currentAgentWorkflow.selected_variables,
            totalSteps: currentAgentWorkflow.totalSteps,
            workflowStepsLength: currentAgentWorkflow.workflowSteps?.length
          });
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Execute the first step
          if (result.current_step && result.current_step.code) {
            console.log('Executing first modeling step code:', result.current_step.code);
            
            // Store the code for later display
            currentStepCode = result.current_step.code;
            
            // Execute the first step directly
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: result.current_step.code
              }));
            }
          } else {
            console.log('No code to execute for first modeling step');
          }
        } else {
          addMessage(`❌ **Modeling Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Execute next step in agent workflow
      function executeNextAgentStep() {
        console.log('🔍 executeNextAgentStep called');
        
        if (!currentAgentWorkflow) {
          console.log('🔍 No active agent workflow');
          return;
        }
        
        console.log('🔍 Workflow state before increment:', {
          currentStep: currentAgentWorkflow.currentStep,
          totalSteps: currentAgentWorkflow.totalSteps,
          workflowSteps: currentAgentWorkflow.workflowSteps?.length,
          agentType: currentAgentWorkflow.algorithms ? 'Modeling' : 
                    currentAgentWorkflow.transformationOptions ? 'Transformation' : 'Cleaning'
        });
        
        currentAgentWorkflow.currentStep++;
        console.log('🔍 After increment - Current step:', currentAgentWorkflow.currentStep);
        
        if (currentAgentWorkflow.currentStep > currentAgentWorkflow.totalSteps) {
          console.log('🔍 Workflow complete - exceeded total steps');
          console.log('🔍 Final workflow state:', {
            currentStep: currentAgentWorkflow.currentStep,
            totalSteps: currentAgentWorkflow.totalSteps,
            agentType: currentAgentWorkflow.algorithms ? 'Modeling' : 
                      currentAgentWorkflow.transformationOptions ? 'Transformation' : 'Cleaning'
          });
          
          // Check if agent was stopped before proceeding
          if (currentAgentWorkflow.stopped) {
            console.log('🔍 Agent was stopped, not proceeding with Claude analysis');
            return;
          }
          
          // Workflow complete - detect agent type
          let agentType = 'Cleaning';
          if (currentAgentWorkflow?.transformationOptions) {
            agentType = 'Transformation';
          } else if (currentAgentWorkflow?.algorithms) {
            agentType = 'Modeling';
          }
          addMessage(`✅ **${agentType} Agent Complete!** All ${currentAgentWorkflow.totalSteps} operations finished.`, "ai");
          
          // Store workflow data before clearing
          const workflowData = {
            dataframe: currentAgentWorkflow.dataframe,
            methodOptions: currentAgentWorkflow.methodOptions,
            customInputs: currentAgentWorkflow.customInputs
          };
          
          // Clear workflow state
          currentAgentWorkflow = null;
          
          // Only proceed with Claude analysis if agent wasn't stopped
          if (workflowData) {
            finishAgentWorkflow();
          }
          return;
        }
        
        // Get the next step from the workflow
        const nextStepIndex = currentAgentWorkflow.currentStep - 1;
        console.log('🔍 Next step index:', nextStepIndex);
        console.log('🔍 Available workflow steps:', currentAgentWorkflow.workflowSteps);
        
        const nextStep = currentAgentWorkflow.workflowSteps[nextStepIndex];
        console.log('🔍 Next step:', nextStep);
        
        if (nextStep) {
          // Check if agent was stopped before proceeding with next step
          if (currentAgentWorkflow.stopped) {
            console.log('🛑 Agent was stopped, not proceeding with next step');
            return;
          }
          
          addMessage(`🔄 **Step ${currentAgentWorkflow.currentStep}/${currentAgentWorkflow.totalSteps}:**\n   ${nextStep.description}`, 'ai');
          
          console.log('🔍 Requesting code for next step via WebSocket');
          
          // Handle different agent types
          if (currentAgentWorkflow.algorithms) {
            // Modeling agent
            const requestData = {
              action: 'get_next_modeling_step_code',
              dataframe: currentAgentWorkflow.dataframe,
              step_info: nextStep,
              target_variable: currentAgentWorkflow.targetVariable,
              algorithms: currentAgentWorkflow.algorithms,
              selected_variables: currentAgentWorkflow.selected_variables
            };
            console.log('🔍 Sending modeling step request with selected_variables:', currentAgentWorkflow.selected_variables);
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify(requestData));
            } else {
              console.log('🔍 WebSocket not available');
            }
          } else {
            // Cleaning or transformation agent
            const requestData = {
              action: 'get_next_step_code',
              dataframe: currentAgentWorkflow.dataframe,
              step_info: nextStep,
              method_options: currentAgentWorkflow.methodOptions,
              custom_inputs: currentAgentWorkflow.customInputs
            };
            
            // Add transformation-specific parameters for transformation agent
            if (currentAgentWorkflow.transformationOptions) {
              requestData.transformation_options = currentAgentWorkflow.transformationOptions;
            } else {
              requestData.na_handling = currentAgentWorkflow.naHandling;
            }
            
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify(requestData));
            } else {
              console.log('🔍 WebSocket not available');
            }
          }
        } else {
          console.log('🔍 No next step found');
        }
      }
      
      // Send agent results to Claude for summary
      function sendAgentSummaryToClaude() {
        // Detect agent type for appropriate messaging
        let agentType = 'cleaning';
        let operationType = 'cleaning';
        
        if (currentAgentWorkflow?.transformationOptions) {
          agentType = 'transformation';
          operationType = 'transformation';
        } else if (currentAgentWorkflow?.algorithms) {
          agentType = 'modeling';
          operationType = 'modeling';
        }
        
        addMessage(`📊 **Analyzing Results...** Sending findings to Claude for comprehensive summary.`, 'ai');
        
        // Format results for Claude - Summary first
        const summaryText = `Analyze these ${operationType} results for the "${currentAgentWorkflow?.dataframe}" dataset and provide a BRIEF summary:

${agentResults.map(result => `
**${result.description}:**
${result.output}
`).join('\n')}

Provide a CONCISE summary (max 3-4 sentences) covering:
- Key issues found
- Overall data quality
- Main recommendations

Keep it brief and focused. Dataset: ${currentAgentWorkflow?.dataframe}`;

        // Send to AI chat
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: summaryText,
            conversation_context: `data_${agentType}_agent_summary`
          }));
        }
        
        // Store the agent type and results for the follow-up code request
        // We'll send this after the first response completes
        window.pendingAgentCodeRequest = {
          agentType,
          operationType,
          agentResults,
          currentAgentWorkflow: currentAgentWorkflow
        };
      }
      
      // Generate final modeling code directly (like other agents do)
      function generateFinalModelingCode() {
        const targetVar = currentAgentWorkflow?.targetVariable || 'target_variable';
        const dataframe = currentAgentWorkflow?.dataframe || 'df';
        const algorithms = currentAgentWorkflow?.algorithms || {};
        
        // Get the selected algorithms
        const selectedAlgorithms = Object.entries(algorithms)
          .filter(([key, value]) => value)
          .map(([key, value]) => key);
        
        let code = `# Final Modeling Code for ${dataframe} dataset
# Target Variable: ${targetVar}
# Selected Algorithms: ${selectedAlgorithms.join(', ')}

# Set seed for reproducibility
set.seed(123)

# Split data into train/test sets
train_idx <- sample(1:nrow(${dataframe}), 0.7 * nrow(${dataframe}))
train_data <- ${dataframe}[train_idx, ]
test_data <- ${dataframe}[-train_idx, ]

# Ensure categorical variables are factors
categorical_cols <- sapply(train_data, is.character)
train_data[categorical_cols] <- lapply(train_data[categorical_cols], as.factor)
test_data[categorical_cols] <- lapply(test_data[categorical_cols], as.factor)

# Train models based on selected algorithms
`;

        // Add code for each selected algorithm
        if (algorithms.linearRegression) {
          code += `
# Linear Regression
features <- names(${dataframe})[names(${dataframe}) != "${targetVar}"]
formula <- as.formula(paste("${targetVar} ~", paste(features, collapse = " + ")))
lm_model <- lm(formula, data = train_data)

# Evaluate linear regression
lm_predictions <- predict(lm_model, test_data)
lm_rmse <- sqrt(mean((test_data$${targetVar} - lm_predictions)^2))
lm_r2 <- 1 - sum((test_data$${targetVar} - lm_predictions)^2) / 
         sum((test_data$${targetVar} - mean(test_data$${targetVar}))^2)

cat("Linear Regression Results:\\n")
cat("RMSE:", round(lm_rmse, 4), "\\n")
cat("R²:", round(lm_r2, 4), "\\n\\n")
`;
        }

        if (algorithms.randomForest) {
          code += `
# Random Forest
if (require(randomForest)) {
  rf_model <- randomForest(${targetVar} ~ ., data = train_data, ntree = 100)
  rf_predictions <- predict(rf_model, test_data)
  rf_rmse <- sqrt(mean((test_data$${targetVar} - rf_predictions)^2))
  
  cat("Random Forest Results:\\n")
  cat("RMSE:", round(rf_rmse, 4), "\\n\\n")
} else {
  cat("randomForest package not available\\n\\n")
}
`;
        }

        if (algorithms.xgboost) {
          code += `
# XGBoost
if (require(xgboost)) {
  # Prepare data for XGBoost
  train_matrix <- model.matrix(${targetVar} ~ . - 1, data = train_data)
  test_matrix <- model.matrix(${targetVar} ~ . - 1, data = test_data)
  
  xgb_model <- xgboost(data = train_matrix, 
                       label = train_data$${targetVar},
                       nrounds = 100, 
                       objective = "reg:squarederror",
                       verbose = 0)
  
  xgb_predictions <- predict(xgb_model, test_matrix)
  xgb_rmse <- sqrt(mean((test_data$${targetVar} - xgb_predictions)^2))
  
  cat("XGBoost Results:\\n")
  cat("RMSE:", round(xgb_rmse, 4), "\\n\\n")
} else {
  cat("xgboost package not available\\n\\n")
}
`;
        }

        // Add visualization code
        code += `
# Visualization
if (require(ggplot2)) {
  # Create a simple summary plot of the target variable
  p <- ggplot(${dataframe}, aes(x = ${targetVar})) +
    geom_histogram(bins = 20, fill = "steelblue", alpha = 0.7) +
    labs(title = "Distribution of ${targetVar}",
         x = "${targetVar}",
         y = "Count") +
    theme_minimal()
  
  print(p)
  
  # If we have predictions, create comparison plot
  if (exists("lm_predictions") && length(lm_predictions) > 0) {
    results_df <- data.frame(
      Actual = test_data$${targetVar},
      Predicted = lm_predictions
    )
    
    p2 <- ggplot(results_df, aes(x = Actual, y = Predicted)) +
      geom_point(alpha = 0.6) +
      geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
      labs(title = "Actual vs Predicted Values",
           subtitle = "Linear Regression Model",
           x = "Actual ${targetVar}",
           y = "Predicted ${targetVar}") +
      theme_minimal()
    
    print(p2)
  }
} else {
  cat("ggplot2 package not available for visualization\\n")
}

cat("\\nModeling workflow completed successfully!\\n")
`;

        return code;
      }
      
      // Show the executed code for each step with copy/insert functionality
      function showAgentCodeSections() {
        // Detect agent type for appropriate messaging
        let agentType = 'cleaning';
        let operationType = 'cleaning';
        
        if (currentAgentWorkflow?.transformationOptions) {
          agentType = 'transformation';
          operationType = 'transformation';
        } else if (currentAgentWorkflow?.algorithms) {
          agentType = 'modeling';
          operationType = 'modeling';
        }
        
        // Show insert all button first
        addMessage(`🤖 **${agentType.charAt(0).toUpperCase() + agentType.slice(1)} Agent Complete!** Generated R code for ${agentCodes.length} ${operationType} steps.`, 'ai');
        
        // Add insert all button
        setTimeout(() => {
          addInsertAllButton();
        }, 100);
        
        // Then show manual options
        setTimeout(() => {
          showManualCodeSections();
        }, 500);
      }
      
      // Add insert all button
      function addInsertAllButton() {
        const container = document.getElementById("chat-container");
        const buttonDiv = document.createElement("div");
        buttonDiv.className = "insert-all-container";
        buttonDiv.style.cssText = "margin: 15px 0; text-align: center;";
        
        const insertAllBtn = document.createElement("button");
        insertAllBtn.textContent = "📝 Insert All Code Chunks to Editor";
        insertAllBtn.className = "insert-all-btn";
        insertAllBtn.style.cssText = "padding: 12px 24px; background: var(--rgent-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600; box-shadow: 0 2px 4px rgba(0,0,0,0.1);";
        insertAllBtn.onclick = () => {
          console.log('🔍 Insert All button clicked');
          insertAllBtn.disabled = true;
          insertAllBtn.textContent = "🚀 Inserting...";
          insertAllAgentCode();
        };
        
        buttonDiv.appendChild(insertAllBtn);
        container.appendChild(buttonDiv);
        container.scrollTop = container.scrollHeight;
      }
      
      // Insert all agent code as separate R chunks
      function insertAllAgentCode() {
        console.log('🔍 Starting insertAllAgentCode');
        console.log('🔍 Agent codes to insert:', agentCodes);
        console.log('🔍 WebSocket state:', ws ? ws.readyState : 'no ws');
        
        if (!agentCodes || agentCodes.length === 0) {
          console.log('🔍 No agent codes to insert');
          addMessage(`❌ **Error:** No code to insert. Please try running the agent again.`, 'ai');
          return;
        }
        
        agentCodes.forEach((codeStep, index) => {
          setTimeout(() => {
            const codeChunk = `\`\`\`{r}\n# ${codeStep.description}\n${codeStep.code}\n\`\`\``;
            
            console.log(`🔍 Inserting step ${index + 1}/${agentCodes.length}:`, codeChunk.substring(0, 100) + '...');
            
            if (ws && ws.readyState === WebSocket.OPEN) {
              const message = {
                action: 'insert_code',
                code: codeChunk
              };
              console.log('🔍 Sending WebSocket message:', message);
              ws.send(JSON.stringify(message));
            } else {
              console.log('🔍 WebSocket not available for insertion');
              addMessage(`❌ **Connection Error:** Unable to insert code. WebSocket not connected.`, 'ai');
            }
            
            // Show progress
            if (index === agentCodes.length - 1) {
              setTimeout(() => {
                console.log('🔍 All insertions completed');
                addMessage(`✅ **All Code Inserted!** ${agentCodes.length} R code chunks have been added to your editor.`, 'ai');
                
                // Re-enable button
                const insertBtn = document.querySelector('.insert-all-btn');
                if (insertBtn) {
                  insertBtn.disabled = false;
                  insertBtn.textContent = "📝 Insert All Code Chunks to Editor";
                }
              }, 200);
            }
          }, 300 * index); // Stagger insertions
        });
      }
      
      // Show manual code sections with copy/insert buttons
      function showManualCodeSections() {
        addPlotAnalysisMessage(`📋 **Generated R Code by Step:**\n\nBelow is the R code that was executed for each cleaning operation. You can copy or insert any section into your editor:`);
        
        agentCodes.forEach((codeStep, index) => {
          const codeContent = `\`\`\`r\n# ${codeStep.description}\n${codeStep.code}\n\`\`\``;
          
          // Use addPlotAnalysisMessage which shows only Copy/Insert buttons (no Execute & Fix)
          setTimeout(() => {
            addPlotAnalysisMessage(`**Step ${codeStep.step}: ${codeStep.description}**\n\n${codeContent}`);
          }, 200 * (index + 1));
        });
      }
      

      
      // Handle agent step response
      function handleAgentStep(result) {
        if (result.success) {
          if (result.completed) {
            // Detect agent type for completion message
            let agentType = 'Cleaning';
            if (currentAgentWorkflow?.transformationOptions) {
              agentType = 'Transformation';
            } else if (currentAgentWorkflow?.problemType) {
              agentType = 'Modeling';
            }
            addMessage(`✅ **${agentType} Agent Completed!**\n\nAll ${result.total_steps} steps have been executed successfully.`, 'ai');
          } else {
            addMessage(`🔄 **Step ${result.step}/${result.total_steps}:** ${result.description}`, 'ai');
            if (result.code) {
              executeAgentCode(result.code, getCurrentDataFrame(), getCurrentNAHandling(), result.step);
            }
          }
        } else {
          addMessage(`❌ **Step ${result.step} Error:** ${result.error}`, 'ai');
        }
      }
      
      // Execute agent code and continue to next step
      function executeAgentCode(code, dataframe, naHandling, currentStep) {
        if (ws && isConnected) {
          // Add code message to chat
          addMessage(code, 'user');
          
          // Execute the code
          ws.send(JSON.stringify({
            action: 'execute_code',
            code: code
          }));
          
          // After a brief delay, request next step based on agent type
          setTimeout(() => {
            if (currentAgentWorkflow?.problemType) {
              // Modeling agent - use the step-by-step execution flow
              executeNextAgentStep();
            } else {
              // Cleaning or transformation agent - use the legacy flow
              ws.send(JSON.stringify({
                action: 'next_agent_step',
                dataframe: dataframe,
                na_handling: naHandling,
                step: currentStep + 1
              }));
            }
          }, 1000);
        }
      }
      
      // Helper functions for agent state
      let currentAgentDataFrame = null;
      let currentAgentNAHandling = null;
      
      function getCurrentDataFrame() { return currentAgentDataFrame; }
      function getCurrentNAHandling() { return currentAgentNAHandling; }
      function setCurrentAgent(dataframe, naHandling) {
        currentAgentDataFrame = dataframe;
        currentAgentNAHandling = naHandling;
      }
      
      // Global iteration counter for error handling
      let cleaningCodeIterationCount = 0;
      const MAX_CLEANING_ITERATIONS = 3;
      let cleaningCodeExecuting = false; // Flag to prevent duplicate handling
      

      
      // Handle Claude's cleaning code response with automatic execution and error handling
      function handleCleaningCodeResponse(message, conversationContext) {
        console.log('🔍 Handling Claude cleaning code response');
        console.log('🔍 Message received:', message);
        console.log('🔍 Conversation context:', conversationContext);
        
        // Check if this is modeling agent code - if so, don't execute automatically
        if (conversationContext === 'data_modeling_agent_code' || currentAgentWorkflow?.algorithms) {
          console.log('🔍 This is modeling agent code - showing success message without execution');
          addMessage(`✅ **Modeling Code Generated Successfully!**\n\nThe modeling workflow has completed and Claude has provided the final R code for your selected algorithms.`, 'ai');
          addMessage(`🎯 **Next Steps:**\n- Copy the code above to your R script\n- Execute it in your R environment\n- The modeling agent workflow is now complete!`, 'ai');
          
          // Reset workflow state
          currentAgentWorkflow = null;
          
          // Don't reset button yet - wait for AI response streaming to complete
          // The button will be reset in finishStreaming() when streaming is done
          return;
        }
        
        // Extract R code from the message
        const codeBlocks = extractRCodeBlocks(message);
        console.log('🔍 Extracted code blocks:', codeBlocks);
        
        if (codeBlocks.length === 0) {
          addMessage('❌ **No R code found** in Claude\'s response. Please ask for executable R code.', 'ai');
          return;
        }
        
        // Get the ORIGINAL formatted code from the message (not extracted)
        const originalCode = getOriginalFormattedCode(message);
        console.log('🔍 Original formatted code:', originalCode.substring(0, 200) + '...');
        
        // Combine extracted code blocks for display
        const combinedCode = codeBlocks.join('\n\n');
        console.log('🔍 Combined code to execute:', combinedCode);
        
        // Check if auto-execute is enabled
        const autoExecute = isAutoExecuteEnabled();
        
        if (autoExecute) {
          // Store the code for error handling
          currentStepCode = originalCode;
          
          // Execute the code automatically
          executeCleaningCodeWithErrorHandling(originalCode);
        } else {
          // Manual mode: Don't add a new message, just add the execute button to the existing code block
          // The code block is already displayed by the normal message processing
          
          // Manual mode: Simple approach - add execute button directly to the last AI message
          setTimeout(() => {
            console.log('🔍 Manual mode: Adding execute button to last AI message...');
            
            // Find the last AI message (which should contain the code block)
            const lastAIMessage = document.querySelector('.ai-message:last-child');
            
            if (lastAIMessage) {
              console.log('🔍 Last AI message found, adding execute button...');
              
              // Create a simple execute button container
              const buttonContainer = document.createElement('div');
              buttonContainer.style.marginTop = '15px';
              buttonContainer.style.padding = '10px';
              buttonContainer.style.backgroundColor = '#f8f9fa';
              buttonContainer.style.borderRadius = '6px';
              buttonContainer.style.border = '1px solid #e9ecef';
              buttonContainer.style.textAlign = 'center';
              
              const executeButton = document.createElement('button');
              executeButton.textContent = 'Execute Cleaning Code';
              executeButton.className = 'execute-cleaning-button';
              executeButton.onclick = () => {
                executeCleaningCodeWithErrorHandling(originalCode);
                // Remove the button after clicking
                buttonContainer.remove();
              };
              
              buttonContainer.appendChild(executeButton);
              lastAIMessage.appendChild(buttonContainer);
              
              console.log('✅ Execute button added to last AI message');
            } else {
              console.log('🔍 No AI message found');
            }
          }, 300); // Simple 300ms delay
        }
        
        // Use the existing copyToClipboard function to preserve formatting
        // Create a temporary button for the copy function
        const tempButton = document.createElement('button');
        tempButton.textContent = 'Copy';
        copyToClipboard(originalCode, tempButton);
      }
      
      // Extract R code blocks from Claude's message
      function extractRCodeBlocks(message) {
        console.log('🔍 Extracting R code from message:', message.substring(0, 200) + '...');
        
        // More flexible regex to catch different code block formats
        const codeBlockRegex = /```(?:r|R)?\s*\n([\s\S]*?)```/g;
        const codeBlocks = [];
        let match;
        
        while ((match = codeBlockRegex.exec(message)) !== null) {
          const codeContent = match[1];
          console.log('🔍 Found code block:', codeContent.substring(0, 100) + '...');
          
          // AGGRESSIVELY preserve line breaks - this is critical for R syntax
          // Only remove leading/trailing whitespace from each line, keep ALL line breaks
          const cleanedCode = codeContent
            .replace(/^\s+|\s+$/gm, '') // Remove leading/trailing whitespace from each line
            .replace(/\n{6,}/g, '\n\n\n\n\n'); // Only replace 6+ consecutive newlines
          
          codeBlocks.push(cleanedCode);
        }
        
        console.log('🔍 Extracted code blocks count:', codeBlocks.length);
        return codeBlocks;
      }
      
      // Get the original formatted code from the message
      function getOriginalFormattedCode(message) {
        console.log('🔍 Getting original formatted code');
        
        // Find the first code block and extract it with original formatting
        const codeBlockMatch = message.match(/```(?:r|R)?\s*\n([\s\S]*?)```/);
        
        if (codeBlockMatch) {
          let originalCode = codeBlockMatch[1];
          console.log('🔍 Original code block found, length:', originalCode.length);
          
          // Decode HTML entities back to actual characters
          originalCode = originalCode
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
          
          // Ensure proper line breaks are preserved
          // Replace any HTML line break entities with actual newlines
          originalCode = originalCode
            .replace(/<br\s*\/?>/gi, '\n')
            .replace(/<\/p>/gi, '\n')
            .replace(/<p[^>]*>/gi, '');
          
          // AGGRESSIVELY preserve line breaks - this is critical for R syntax
          // Only remove leading/trailing whitespace from each line, keep ALL line breaks
          originalCode = originalCode
            .replace(/^\s+|\s+$/gm, '') // Remove leading/trailing whitespace from each line
            .replace(/\n{6,}/g, '\n\n\n\n\n'); // Only replace 6+ consecutive newlines
          
          console.log('🔍 Decoded HTML entities and cleaned formatting, new length:', originalCode.length);
          console.log('🔍 Sample of processed code:', originalCode.substring(0, 200));
          
          // FINAL CHECK: Ensure we have proper line breaks between statements
          // Look for patterns like "}variable" or ")variable" and add line breaks
          originalCode = originalCode
            .replace(/([})\]])([a-zA-Z_])/g, '$1\n$2') // Add line break after } ) ] before variable
            .replace(/([a-zA-Z_])#/g, '$1\n#') // Add line break before comments
            .replace(/([a-zA-Z_])library/g, '$1\nlibrary'); // Add line break before library calls
          
          console.log('🔍 Final processed code length:', originalCode.length);
          console.log('🔍 Final sample of processed code:', originalCode.substring(0, 300));
          
          return originalCode;
        } else {
          console.log('🔍 No code block found, returning empty string');
          return '';
        }
      }
      

      
      // Execute cleaning code with automatic error handling and iteration
      function executeCleaningCodeWithErrorHandling(code, originalMessage) {
        console.log('🔍 Executing cleaning code with error handling');
        
        // Store the code that's being executed for error handling
        currentStepCode = code;
        
        // Set flag to prevent duplicate handling
        cleaningCodeExecuting = true;
        
        // Check if this is normal chat auto-execute (not an agent workflow)
        // If no active agent workflow, clear the agent type flags for normal chat
        if (!currentAgentWorkflow) {
          window.currentActiveAgentType = null;
          window.completedAgentType = null;
        }
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          // Send the code for execution
          ws.send(JSON.stringify({
            action: 'execute_code',
            code: code
          }));
          
          // Don't set timeout - wait for actual WebSocket response
          console.log('🔍 Code sent for execution, waiting for response...');
        }
      }
      

      
      // Handle cleaning code errors and ask Claude to fix them
      function handleCleaningCodeError(error, code) {
        console.log('🔍 Handling cleaning code error:', error);
        
        // Increment iteration counter
        cleaningCodeIterationCount++;
        console.log(`🔍 Cleaning code iteration: ${cleaningCodeIterationCount}/${MAX_CLEANING_ITERATIONS}`);
        
        // Check if we've exceeded the maximum iterations
        if (cleaningCodeIterationCount >= MAX_CLEANING_ITERATIONS) {
          addMessage(`🛑 **Maximum Iterations Reached**\n\nThe cleaning code has failed ${MAX_CLEANING_ITERATIONS} times. Stopping automatic iteration to prevent infinite loops.\n\n**Last Error:**\n\`${error}\`\n\n**Recommendation:**\nPlease manually review and fix the code, or try a different approach.`, 'ai');
          
          // Reset counter for future attempts
          cleaningCodeIterationCount = 0;
          
          // Don't reset button yet - wait for AI response streaming to complete
          // The button will be reset in finishStreaming() when streaming is done
          return;
        }
        
        addMessage(`❌ **Code Execution Failed (Attempt ${cleaningCodeIterationCount}/${MAX_CLEANING_ITERATIONS})**\n\nThe cleaning code encountered an error:\n\n\`${error}\`\n\nAsking Claude to fix this...`, 'ai');
        
        // Ask Claude to fix the code
        const fixRequest = `The R code I provided earlier failed to execute with this error:

\`${error}\`

**Original Code That Failed:**
\`\`\`r
${code || "Code not available"}
\`\`\`

Please fix the code and provide a corrected version that will work. The code should:

1. Handle the specific error that occurred: \`${error}\`
2. Be more robust and defensive
3. Still accomplish the original cleaning goals
4. Be production-ready and executable

**Important:** Please analyze the original code and the specific error to provide a targeted fix, not a generic solution.`;
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: fixRequest,
            conversation_context: 'data_cleaning_agent_code_fix'
          }));
        }
      }
      
      // FIXED: Removed unused originalOnMessage and originalOnOpen functions
      // The main WebSocket handlers above handle all functionality
      
      // ========== VISUALIZATION AGENT FUNCTIONS ==========
      
      
      // Show agent selection view
      function showAgentSelection() {
        document.getElementById('agent-selection').style.display = 'block';
        document.getElementById('back-to-agents-btn').style.display = 'none';
        document.getElementById('agents-main-header').textContent = '🤖 AI Agents';
        document.getElementById('agent-selection-prompt').textContent = 'Select an agent to get started';
        
        // Hide all agent configs
        const configs = ['cleaning-config', 'transformation-config', 'statistical-config', 'modeling-config', 'visualization-config'];
        configs.forEach(id => {
          const config = document.getElementById(id);
          if (config) config.style.display = 'none';
        });
      }
      
      // Load available DataFrames for visualization config
      function loadVisualizationDataFrames() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Populate DataFrame dropdown for visualization config
      function populateVizDataFrameSelect(dataframes) {
        console.log('🎨 populateVizDataFrameSelect called with:', dataframes);
        const select = document.getElementById('viz-dataframe-select');
        const startBtn = document.getElementById('start-viz-btn');
        
        if (!select) {
          console.error('viz-dataframe-select element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log('🎨 Adding viz dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (this.value) {
            updateVizDataFrameInfo();
            setTimeout(() => updateVizStartButton(), 100);
          } else {
            const checklist = document.getElementById('viz-checklist');
            if (checklist) {
              checklist.style.display = 'none';
            }
            if (startBtn) {
              startBtn.disabled = true;
              startBtn.textContent = 'Select a DataFrame first';
              startBtn.title = 'Please select a DataFrame to continue';
            }
          }
        };
      }
      
      // Update DataFrame info when selection changes for visualization
      function updateVizDataFrameInfo() {
        const select = document.getElementById('viz-dataframe-select');
        const selectedDF = select.value;
        const infoDiv = document.getElementById('viz-dataframe-info');
        const checklist = document.getElementById('viz-checklist');
        const variablesSection = document.getElementById('viz-variables-section');
        const optionsSection = document.getElementById('viz-options-section');
        
        if (selectedDF) {
          // Set current visualization dataframe for context
          window.currentVisualizationDataframe = selectedDF;
          
          // Request DataFrame info from R
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: selectedDF
            }));
          }
          
          // Show checklist and other sections
          if (checklist) checklist.style.display = 'block';
          if (variablesSection) variablesSection.style.display = 'block';
          if (optionsSection) optionsSection.style.display = 'block';
        } else {
          if (infoDiv) infoDiv.style.display = 'none';
          if (checklist) checklist.style.display = 'none';
          if (variablesSection) variablesSection.style.display = 'none';
          if (optionsSection) optionsSection.style.display = 'none';
        }
      }
      
      // Handle visualization DataFrame info response
      function handleVisualizationDataframeInfo(dataframeInfo) {
        try {
          if (!dataframeInfo || !window.currentVisualizationDataframe) return;
          
          console.log('🎨 Processing dataframe info for visualization agent:', dataframeInfo);
          
          const infoDiv = document.getElementById('viz-dataframe-info');
          if (!infoDiv) return;
          
          // Check if we have proper column info to update the variables
          const hasColumns = dataframeInfo.columns || dataframeInfo.column_info;
          if (!hasColumns) {
            console.log('⚠️ No column info in dataframe response for visualization agent, keeping loading state');
            return; // Keep the loading state - real column info will come later
          }
          
          // Get columns from either structure
          const columns = dataframeInfo.columns || dataframeInfo.column_info || {};
          
          // Extract variable names and types
          const variables = Object.keys(columns);
          const variableTypes = {};
          
          // Process column information to get types
          variables.forEach(varName => {
            const colInfo = columns[varName];
            if (typeof colInfo === 'object' && colInfo !== null) {
              // If it's an object with type information
              variableTypes[varName] = colInfo.type || colInfo.class || 'unknown';
            } else {
              // If it's just a string or simple value
              variableTypes[varName] = typeof colInfo;
            }
          });
          
          // Store variable types globally for smart filtering
          window.currentVisualizationVariables = variables;
          window.currentVisualizationVariableTypes = variableTypes;
          
          infoDiv.style.display = 'none';
          
          // Store dataframe name for later use
          window.currentVisualizationDataframe = dataframeInfo.name;
          
          // Populate variable dropdowns
          populateVizVariableDropdowns(variables);
          
          // Update start button
          updateVizStartButton();
          
        } catch (error) {
          console.error('🎨 Error handling visualization dataframe info:', error);
          const infoDiv = document.getElementById('viz-dataframe-info');
          if (infoDiv) {
            infoDiv.innerHTML = `<div class="error">Error loading DataFrame info: ${error.message}</div>`;
            infoDiv.style.display = 'block';
          }
        }
      }
      
      // Populate visualization variable dropdowns
      function populateVizVariableDropdowns(variables) {
        // Populate all existing plot variable dropdowns
        const categories = ['distributions', 'comparisons', 'relationships', 'categorical', 'time-series', 'statistical'];
        
        categories.forEach(category => {
          const configsDiv = document.getElementById(`viz-${category}-plot-configs`);
          if (configsDiv) {
            const selects = configsDiv.querySelectorAll('select');
            selects.forEach(select => {
              if (select.id.includes('-var')) {
                // Clear existing options except the first one
                select.innerHTML = select.querySelector('option').outerHTML;
                
                variables.forEach(varName => {
                  const option = document.createElement('option');
                  option.value = varName;
                  option.textContent = varName;
                  select.appendChild(option);
                });
              }
            });
          }
        });
      }
      
      // Update visualization start button state
      function updateVizStartButton() {
        const startBtn = document.getElementById('start-viz-btn');
        const select = document.getElementById('viz-dataframe-select');
        const selectedDF = select ? select.value : '';
        
        // Check if at least one plot is configured
        const configuredPlots = getConfiguredPlots();
        
        console.log('🎨 updateVizStartButton - selectedDF:', selectedDF);
        console.log('🎨 updateVizStartButton - configuredPlots:', configuredPlots);
        console.log('🎨 updateVizStartButton - configuredPlots.length:', configuredPlots.length);
        
        if (startBtn) {
          if (!selectedDF) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          } else if (configuredPlots.length === 0) {
            startBtn.disabled = true;
            startBtn.textContent = 'Configure at least one plot';
            startBtn.title = 'Please configure at least one plot';
          } else {
            startBtn.disabled = false;
            startBtn.textContent = `🎨 Start Visualization Agent (${configuredPlots.length} plots)`;
            startBtn.title = `Ready to generate ${configuredPlots.length} plots`;
          }
        }
      }
      
      // Get all configured plots
      function getConfiguredPlots() {
        const configuredPlots = [];
        
        // Check each category
        const categories = ['distributions', 'comparisons', 'relationships', 'categorical', 'time-series', 'statistical'];
        
        console.log('🎨 getConfiguredPlots - checking categories:', categories);
        
        categories.forEach(category => {
          const checkbox = document.getElementById(`viz-check-${category}`);
          console.log(`🎨 getConfiguredPlots - checking category ${category}:`, checkbox ? checkbox.checked : 'checkbox not found');
          if (checkbox && checkbox.checked) {
            // Map category names to HTML IDs
            const categoryMap = {
              'distributions': 'dist',
              'comparisons': 'comp',
              'relationships': 'rel',
              'categorical': 'cat',
              'time-series': 'ts',
              'statistical': 'stat',
              'automatic': 'auto'
            };
            
            const shortCategory = categoryMap[category] || category;
            
            // Get individual plot configurations directly
            const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
            if (configsDiv) {
              const plotConfigs = configsDiv.querySelectorAll('.plot-config-section');
              plotConfigs.forEach(plotConfig => {
                const plotId = plotConfig.id.replace('-config', '');
                const config = getIndividualPlotConfiguration(plotId);
                if (config && isPlotConfigurationComplete(config)) { // Only add if plot is complete
                  configuredPlots.push({
                    category: category,
                    plotId: plotId,
                    ...config
                  });
                }
              });
            }
          }
        });
        
        return configuredPlots;
      }
      
      // Get configuration for an individual plot
      function getIndividualPlotConfiguration(plotId) {
        const plotType = document.getElementById(`${plotId}-plot-type`)?.value || '';
        const xVar = document.getElementById(`${plotId}-x-var`)?.value || '';
        const yVar = document.getElementById(`${plotId}-y-var`)?.value || '';
        const colorVar = document.getElementById(`${plotId}-color-var`)?.value || '';
        const title = document.getElementById(`${plotId}-title`)?.value || '';
        const bins = document.getElementById(`${plotId}-bins`)?.value || '30';
        
        return {
          plotType: plotType,
          xVar: xVar,
          yVar: yVar,
          colorVar: colorVar,
          title: title,
          bins: parseInt(bins)
        };
      }
      
      // Check if a plot configuration is complete (has all mandatory variables)
      function isPlotConfigurationComplete(config) {
        if (!config.plotType) return false;
        
        // Define mandatory variables for each plot type
        const mandatoryVars = {
          'histogram': ['xVar'],
          'density': ['xVar'],
          'boxplot': ['xVar'],
          'violin': ['xVar'],
          'scatter': ['xVar', 'yVar'],
          'line': ['xVar', 'yVar'],
          'bar': ['xVar'],
          'pie': ['xVar'],
          'heatmap': ['xVar', 'yVar'],
          'correlation': ['xVar'],
          'timeseries': ['xVar', 'yVar'],
          'qqplot': ['xVar'],
          'residual': ['xVar', 'yVar']
        };
        
        const requiredVars = mandatoryVars[config.plotType] || ['xVar'];
        
        // Check if all required variables are filled
        return requiredVars.every(varName => config[varName] && config[varName].trim() !== '');
      }
      
      // Setup visualization agent checkbox interactions
      function setupVisualizationCheckboxInteractions() {
        console.log('🎨 Setting up visualization agent checkbox interactions...');
        
        // Setup category toggles
        const categories = ['distributions', 'comparisons', 'relationships', 'categorical', 'time-series', 'statistical', 'automatic'];
        categories.forEach(category => {
          const checkbox = document.getElementById(`viz-check-${category}`);
          if (checkbox) {
            checkbox.addEventListener('change', () => updateVizStartButton());
          }
        });
      }
      
      // Toggle visualization category options
      function toggleVizCategory(category) {
        const checkbox = document.getElementById(`viz-check-${category}`);
        const optionsDiv = document.getElementById(`viz-${category}-options`);
        
        if (checkbox.checked) {
          optionsDiv.style.display = 'block';
          
          // Automatically create the first plot when category is checked
          // Map category names to HTML IDs (same as in createVizPlotConfig)
          const categoryMap = {
            'distributions': 'dist',
            'comparisons': 'comp',
            'relationships': 'rel',
            'categorical': 'cat',
            'time-series': 'ts',
            'statistical': 'stat',
            'automatic': 'auto'
          };
          const shortCategory = categoryMap[category] || category;
          const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
          console.log('🎨 Auto-creating plot for category:', category);
          console.log('🎨 Short category:', shortCategory);
          console.log('🎨 Looking for ID:', `viz-${shortCategory}-plot-configs`);
          console.log('🎨 ConfigsDiv found:', !!configsDiv);
          console.log('🎨 ConfigsDiv children length:', configsDiv ? configsDiv.children.length : 'N/A');
          
          if (configsDiv && configsDiv.children.length === 0) {
            // Get the default plot type for this category
            const defaultPlotType = getDefaultPlotTypeForCategory(category);
            console.log('🎨 Default plot type:', defaultPlotType);
            
            // Create the first plot configuration
            const plotConfig = createVizPlotConfig(category, defaultPlotType, 1);
            console.log('🎨 Generated plot config HTML length:', plotConfig.length);
            
            configsDiv.insertAdjacentHTML('beforeend', plotConfig);
            console.log('🎨 Plot config inserted, new children length:', configsDiv.children.length);
            
            // Populate variables if available
            if (window.currentVisualizationVariables) {
              populateVizPlotVariables(category);
            }
          } else {
            console.log('🎨 Skipping auto-creation - configsDiv not found or already has children');
          }
        } else {
          optionsDiv.style.display = 'none';
          // Clear plot configs when category is unchecked
          const categoryMap = {
            'distributions': 'dist',
            'comparisons': 'comp',
            'relationships': 'rel',
            'categorical': 'cat',
            'time-series': 'ts',
            'statistical': 'stat',
            'automatic': 'auto'
          };
          const shortCategory = categoryMap[category] || category;
          const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
          if (configsDiv) {
            configsDiv.innerHTML = '';
            configsDiv.style.display = 'none';
          }
        }
        
        updateVizStartButton();
      }
      
      // Toggle plot type and show individual plot configurations
      function toggleVizPlotType(category) {
        console.log('🎨 toggleVizPlotType called for category:', category);
        
        // Map category names to HTML IDs
        const categoryMap = {
          'distributions': 'dist',
          'comparisons': 'comp',
          'relationships': 'rel',
          'categorical': 'cat',
          'time-series': 'ts',
          'automatic': 'auto'
        };
        
        const shortCategory = categoryMap[category] || category;
        const plotTypeSelect = document.getElementById(`viz-${shortCategory}-plot-type`);
        const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
        
        console.log('🎨 Looking for elements:');
        console.log('🎨 plotTypeSelect ID:', `viz-${shortCategory}-plot-type`);
        console.log('🎨 plotTypeSelect element:', plotTypeSelect);
        console.log('🎨 configsDiv ID:', `viz-${shortCategory}-plot-configs`);
        console.log('🎨 configsDiv element:', configsDiv);
        
        if (!plotTypeSelect || !configsDiv) {
          console.log('🎨 Missing elements, returning');
          return;
        }
        
        const plotType = plotTypeSelect.value;
        
        if (plotType && plotType !== 'auto') {
          // Clear existing configs
          configsDiv.innerHTML = '';
          
          // Create a single plot with the selected type
          const plotTypes = [plotType];
          
          // Create individual plot configurations
          plotTypes.forEach((type, index) => {
            const plotNum = index + 1;
            const plotConfig = createVizPlotConfig(category, type, plotNum);
            configsDiv.insertAdjacentHTML('beforeend', plotConfig);
          });
          
          configsDiv.style.display = 'block';
          
          // Show the "Add Plot" button
          const addPlotSection = document.querySelector(`#viz-${shortCategory}-plot-configs`).nextElementSibling;
          if (addPlotSection && addPlotSection.classList.contains('add-plot-section')) {
            addPlotSection.style.display = 'block';
          }
          
          // Populate variables if available
          if (window.currentVisualizationVariables) {
            populateVizPlotVariables(category);
          }
        } else {
          configsDiv.innerHTML = '';
          configsDiv.style.display = 'none';
          
          // Hide the "Add Plot" button
          const addPlotSection = document.querySelector(`#viz-${shortCategory}-plot-configs`).nextElementSibling;
          if (addPlotSection && addPlotSection.classList.contains('add-plot-section')) {
            addPlotSection.style.display = 'none';
          }
        }
        
        updateVizStartButton();
      }
      
      // Add a new plot configuration to a category
      function addVizPlot(category) {
        // Map category names to HTML IDs
        const categoryMap = {
          'distributions': 'dist',
          'comparisons': 'comp',
          'relationships': 'rel',
          'categorical': 'cat',
          'time-series': 'ts',
          'statistical': 'stat',
          'automatic': 'auto'
        };
        
        const shortCategory = categoryMap[category] || category;
        const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
        
        if (!configsDiv) return;
        
        // Count existing plots to get the next number
        const existingPlots = configsDiv.querySelectorAll('.plot-config-section');
        const plotNum = existingPlots.length + 1;
        
        // Create the new plot configuration with default plot type
        const defaultPlotType = getDefaultPlotTypeForCategory(category);
        const plotConfig = createVizPlotConfig(category, defaultPlotType, plotNum);
        configsDiv.insertAdjacentHTML('beforeend', plotConfig);
        
        // Populate variables if available
        if (window.currentVisualizationVariables) {
          populateVizPlotVariables(category);
        }
        
        updateVizStartButton();
      }
      
      // Get default plot type for each category
      function getDefaultPlotTypeForCategory(category) {
        const defaults = {
          'distributions': 'histogram',
          'comparisons': 'boxplot',
          'relationships': 'scatter',
          'categorical': 'bar',
          'time-series': 'line',
          'statistical': 'qqplot'
        };
        return defaults[category] || 'histogram';
      }
      
      // Update individual plot type and refresh the plot configuration
      function updateIndividualPlotType(plotId, category) {
        const plotTypeSelect = document.getElementById(`${plotId}-plot-type`);
        if (!plotTypeSelect) return;
        
        const newPlotType = plotTypeSelect.value;
        if (!newPlotType) return;
        
        // Extract plot number from plotId (e.g., "dist-histogram-2" -> 2)
        const plotNum = plotId.split('-').pop();
        
        // Find the plot config container
        const plotConfigDiv = document.getElementById(`${plotId}-config`);
        if (!plotConfigDiv) return;
        
        // Create new plot configuration with the updated type
        const newPlotConfig = createVizPlotConfig(category, newPlotType, plotNum);
        
        // Replace the existing plot configuration
        plotConfigDiv.outerHTML = newPlotConfig;
        
        // Repopulate variables if available
        if (window.currentVisualizationVariables) {
          populateVizPlotVariables(category);
        }
        
        updateVizStartButton();
      }
      
      // Create individual plot configuration HTML
      function createVizPlotConfig(category, plotType, plotNum) {
        // Map category names to HTML IDs
        const categoryMap = {
          'distributions': 'dist',
          'comparisons': 'comp',
          'relationships': 'rel',
          'categorical': 'cat',
          'time-series': 'ts',
          'automatic': 'auto'
        };
        
        const shortCategory = categoryMap[category] || category;
        const plotId = `${shortCategory}-${plotType}-${plotNum}`;
        const plotName = getPlotDisplayName(plotType);
        
        let configHtml = `
          <div class="plot-config-section" id="${plotId}-config">
            <div class="plot-config-header">
              <h5>📊 ${plotName} ${plotNum}</h5>
              <button type="button" class="remove-plot-btn" onclick="removeVizPlot('${plotId}')" title="Remove this plot">×</button>
            </div>
            <div class="plot-config-details">
              <div class="form-group">
                <label for="${plotId}-plot-type">Plot Type</label>
                <select id="${plotId}-plot-type" onchange="updateIndividualPlotType('${plotId}', '${category}')">
                  <option value="">-- Select Plot Type --</option>
        `;
        
        // Add plot type options based on category
        if (category === 'distributions') {
          configHtml += `
                  <option value="histogram" ${plotType === 'histogram' ? 'selected' : ''}>Histogram</option>
                  <option value="density" ${plotType === 'density' ? 'selected' : ''}>Density Plot</option>
          `;
        } else if (category === 'comparisons') {
          configHtml += `
                  <option value="boxplot" ${plotType === 'boxplot' ? 'selected' : ''}>Box Plot</option>
                  <option value="violin" ${plotType === 'violin' ? 'selected' : ''}>Violin Plot</option>
          `;
        } else if (category === 'relationships') {
          configHtml += `
                  <option value="scatter" ${plotType === 'scatter' ? 'selected' : ''}>Scatter Plot</option>
                  <option value="line" ${plotType === 'line' ? 'selected' : ''}>Line Plot</option>
                  <option value="correlation" ${plotType === 'correlation' ? 'selected' : ''}>Correlation Plot</option>
          `;
        } else if (category === 'categorical') {
          configHtml += `
                  <option value="bar" ${plotType === 'bar' ? 'selected' : ''}>Bar Chart</option>
                  <option value="pie" ${plotType === 'pie' ? 'selected' : ''}>Pie Chart</option>
          `;
        } else if (category === 'time-series') {
          configHtml += `
                  <option value="line" ${plotType === 'line' ? 'selected' : ''}>Line Plot</option>
                  <option value="trend" ${plotType === 'trend' ? 'selected' : ''}>Trend Analysis</option>
          `;
        } else if (category === 'statistical') {
          configHtml += `
                  <option value="qqplot" ${plotType === 'qqplot' ? 'selected' : ''}>Q-Q Plot</option>
                  <option value="residual" ${plotType === 'residual' ? 'selected' : ''}>Residual Plot</option>
          `;
        } else {
          // For any other category, show all options
          configHtml += `
                  <option value="histogram" ${plotType === 'histogram' ? 'selected' : ''}>Histogram</option>
                  <option value="density" ${plotType === 'density' ? 'selected' : ''}>Density Plot</option>
                  <option value="boxplot" ${plotType === 'boxplot' ? 'selected' : ''}>Box Plot</option>
                  <option value="violin" ${plotType === 'violin' ? 'selected' : ''}>Violin Plot</option>
                  <option value="scatter" ${plotType === 'scatter' ? 'selected' : ''}>Scatter Plot</option>
                  <option value="line" ${plotType === 'line' ? 'selected' : ''}>Line Plot</option>
                  <option value="bar" ${plotType === 'bar' ? 'selected' : ''}>Bar Chart</option>
                  <option value="pie" ${plotType === 'pie' ? 'selected' : ''}>Pie Chart</option>
          `;
        }
        
        configHtml += `
                </select>
              </div>
        `;
        
        // Add variable selections based on plot type
        if (plotType === 'histogram' || plotType === 'density') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-bins">Bins (for histogram)</label>
                <input type="number" id="${plotId}-bins" value="30" min="5" max="100">
              </div>
            </div>
          `;
        } else if (plotType === 'boxplot' || plotType === 'violin') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Grouping Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Grouping Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Value Variable</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Value Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'scatter' || plotType === 'line') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">X Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select X Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Y Variable</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Y Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-color-var">Color Variable (Optional)</label>
                <select id="${plotId}-color-var">
                  <option value="">-- Select Color Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'bar' || plotType === 'pie') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Categorical Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Categorical Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Count Variable (Optional)</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Count Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'trend') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Time Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Time Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Value Variable</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Value Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'qqplot') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'residual') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">X Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select X Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Y Variable</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Y Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'correlation') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Variable (for correlation matrix)</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Variable --</option>
                </select>
              </div>
            </div>
          `;
        }
        
        // Add title field for all plots
        configHtml += `
            <div class="form-group">
              <label for="${plotId}-title">Plot Title (Optional)</label>
              <input type="text" id="${plotId}-title" placeholder="Enter custom title">
            </div>
          </div>
        </div>
        `;
        
        return configHtml;
      }
      
      // Get display name for plot type
      function getPlotDisplayName(plotType) {
        const names = {
          'histogram': 'Histogram',
          'density': 'Density Plot',
          'boxplot': 'Box Plot',
          'violin': 'Violin Plot',
          'scatter': 'Scatter Plot',
          'line': 'Line Plot',
          'bar': 'Bar Chart',
          'pie': 'Pie Chart',
          'trend': 'Trend Analysis',
          'correlation': 'Correlation Plot',
          'qqplot': 'Q-Q Plot',
          'residual': 'Residual Plot'
        };
        return names[plotType] || plotType;
      }
      
      // Remove a specific plot configuration
      function removeVizPlot(plotId) {
        const plotElement = document.getElementById(`${plotId}-config`);
        if (plotElement) {
          plotElement.remove();
        }
        updateVizStartButton();
      }
      
      // Populate variables for all plots in a category with smart filtering
      function populateVizPlotVariables(category) {
        if (!window.currentVisualizationVariables || !window.currentVisualizationVariableTypes) return;
        
        // Map category names to HTML IDs
        const categoryMap = {
          'distributions': 'dist',
          'comparisons': 'comp',
          'relationships': 'rel',
          'categorical': 'cat',
          'time-series': 'ts',
          'statistical': 'stat',
          'automatic': 'auto'
        };
        
        const shortCategory = categoryMap[category] || category;
        const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
        if (!configsDiv) return;
        
        const selects = configsDiv.querySelectorAll('select');
        selects.forEach(select => {
          if (select.id.includes('-var')) {
            // Preserve current selection
            const currentValue = select.value;
            
            // Determine what type of variable this select expects
            const expectedType = getExpectedVariableType(select.id);
            
            // Clear existing options except the first one
            select.innerHTML = select.querySelector('option').outerHTML;
            
            // Filter variables based on expected type and add them with data types
            window.currentVisualizationVariables.forEach(varName => {
              const varType = window.currentVisualizationVariableTypes[varName];
              const isCompatible = isVariableCompatible(varType, expectedType);
              
              if (isCompatible) {
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = `${varName} (${varType})`;
                select.appendChild(option);
              }
            });
            
            // Restore selection if it still exists
            if (currentValue && Array.from(select.options).some(opt => opt.value === currentValue)) {
              select.value = currentValue;
            }
            
            // Add change event listener to update start button
            select.addEventListener('change', () => updateVizStartButton());
          }
        });
      }
      
      // Get expected variable type based on select ID and plot type
      function getExpectedVariableType(selectId) {
        // Extract plot type from select ID (e.g., "dist-histogram-1-x-var" -> "histogram")
        const plotTypeMatch = selectId.match(/(histogram|density|boxplot|violin|scatter|line|bar|pie|correlation|qqplot|residual|trend)/);
        const plotType = plotTypeMatch ? plotTypeMatch[1] : '';
        
        // X variable logic
        if (selectId.includes('-x-var') && !selectId.includes('-y-var')) {
          // For boxplots and violin plots, X should be categorical (grouping variable)
          if (plotType === 'boxplot' || plotType === 'violin') {
            return 'categorical';
          }
          // For histograms, density plots, bar charts, pie charts, X can be any type
          if (plotType === 'histogram' || plotType === 'density' || plotType === 'bar' || plotType === 'pie') {
            return 'any';
          }
          // For scatter plots, line plots, residual plots, X should be numeric
          if (plotType === 'scatter' || plotType === 'line' || plotType === 'residual') {
            return 'numeric';
          }
          // For correlation plots and Q-Q plots, X should be numeric
          if (plotType === 'correlation' || plotType === 'qqplot') {
            return 'numeric';
          }
        }
        
        // Y variable logic
        if (selectId.includes('-y-var')) {
          // Y variables should generally be numeric
          return 'numeric';
        }
        
        return 'any'; // Default to any type
      }
      
      // Check if variable type is compatible with expected type
      function isVariableCompatible(varType, expectedType) {
        if (expectedType === 'any') return true;
        
        // Normalize variable types
        const normalizedType = varType.toLowerCase();
        
        if (expectedType === 'numeric') {
          return normalizedType.includes('numeric') || 
                 normalizedType.includes('integer') || 
                 normalizedType.includes('double') ||
                 normalizedType.includes('number');
        }
        
        if (expectedType === 'categorical') {
          return normalizedType.includes('character') || 
                 normalizedType.includes('factor') || 
                 normalizedType.includes('string') ||
                 normalizedType.includes('categorical');
        }
        
        return true; // Default to compatible
      }
      
      
      // Start visualization agent
      function startVisualizationAgent() {
        console.log('🎨 Starting visualization agent...');
        
        const dataframe = document.getElementById('viz-dataframe-select').value;
        if (!dataframe) {
          alert('Please select a DataFrame first');
          return;
        }
        
        // Get configured plots
        const configuredPlots = getConfiguredPlots();
        if (configuredPlots.length === 0) {
          alert('Please configure at least one plot');
          return;
        }
        
        // Collect global options
        const options = {
          auto_analyze: true, // Always analyze plots
          plots: configuredPlots
        };
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // Hide visualization config
        const vizConfig = document.getElementById('visualization-config');
        if (vizConfig) {
          vizConfig.style.display = 'none';
        }
        
        // Send visualization agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_visualization_agent',
            dataframe: dataframe,
            options: options
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          console.log('🎨 Visualization agent start request sent with', configuredPlots.length, 'plots');
        } else {
          alert('Not connected to R. Please check your connection.');
        }
      }
      
      // Handle visualization agent started
      function handleVisualizationAgentStarted(result) {
        console.log('🎨 handleVisualizationAgentStarted called with:', result);
        
        if (result.success) {
          currentAgentWorkflow = {
            type: 'visualization',
            dataframe: result.dataframe,
            options: result.options,
            totalSteps: result.total_steps,
            workflowSteps: result.workflow_steps,
            currentStep: 1,
            stopped: false
          };
          
          const stepNum = currentAgentWorkflow.currentStep;
          const totalSteps = currentAgentWorkflow.totalSteps;
          const plotCount = result.options.plots ? result.options.plots.length : 0;
          
          addMessage(`**🎨 Visualization Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** Generating ${plotCount} configured plots\n` +
            `**Dataset:** ${result.dataframe}`, 'ai');
          
          console.log('Visualization agent started with workflow:', result);
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Start the first visualization step
          requestNextVisualizationStep();
        } else {
          addMessage(`❌ **Visualization Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Handle visualization step result
      function handleVisualizationStepResult(stepResult) {
        console.log('🎨 Processing visualization step result:', stepResult);
        
        if (stepResult.success) {
          // Store result for final summary
          agentResults.push({
            description: stepResult.plot_type,
            output: formatVisualizationResult(stepResult),
            step: stepResult.step
          });
          
          // Display the results
          displayVisualizationResults(stepResult);
          
          // Move to next step
          requestNextVisualizationStep();
        } else {
          addMessage(`❌ **Visualization Error:** ${stepResult.error}`, 'ai');
          finishAgentWorkflow();
        }
      }
      
      // Display visualization results
      function displayVisualizationResults(stepResult) {
        console.log('🎨 Displaying visualization results:', stepResult);
        
        let message = `**🎨 ${stepResult.plot_type.toUpperCase()} VISUALIZATION**\n\n`;
        
        if (stepResult.plot_data) {
          // Add plot description
          message += `Generated ${stepResult.plot_type} showing ${stepResult.description}\n\n`;
          
          // Add base64 image data
          message += `data:image/png;base64,${stepResult.plot_data}`;
          
          // Check if auto-analyze is enabled
          if (stepResult.auto_analyze) {
            message += `\n\n🔍 **Auto-analyzing plot...**`;
          }
        } else {
          message += `Plot generated successfully.\n`;
        }
        
        addVisualizationMessage(message, 'ai');
        
        // Auto-trigger plot analysis if enabled
        if (stepResult.auto_analyze && stepResult.plot_data) {
          setTimeout(() => {
            triggerPlotAnalysis();
          }, 1000);
        }
      }
      
      // Format visualization result for summary
      function formatVisualizationResult(stepResult) {
        if (stepResult.success) {
          return `Generated ${stepResult.plot_type} plot successfully.\nDescription: ${stepResult.description}`;
        } else {
          return `Error: ${stepResult.error}`;
        }
      }
      
      // Request next visualization step
      function requestNextVisualizationStep() {
        if (!currentAgentWorkflow || currentAgentWorkflow.type !== 'visualization') {
          console.log('🎨 No active visualization workflow');
          return;
        }
        
        console.log('🎨 Requesting next visualization step:', currentAgentWorkflow.currentStep);
        
        if (currentAgentWorkflow.currentStep > currentAgentWorkflow.totalSteps) {
          console.log('🎨 Visualization workflow completed');
          finishVisualizationWorkflow();
          return;
        }
        
        // Execute current step, then increment for next time
        const stepToExecute = currentAgentWorkflow.currentStep;
        currentAgentWorkflow.currentStep++;
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'execute_visualization_step',
            step: stepToExecute,
            dataframe: currentAgentWorkflow.dataframe,
            variables: {}, // Legacy parameter
            options: currentAgentWorkflow.options
          }));
        }
      }
      
      // Finish visualization workflow
      function finishVisualizationWorkflow() {
        console.log('🎨 Finishing visualization workflow');
        
        
        // Individual plot analyses already provided comprehensive insights
        // No need for additional comprehensive analysis
        
        // Reset workflow
        currentAgentWorkflow = null;
      }
      

      // Analyze current visualization plot specifically
      function analyzeCurrentVisualizationPlot() {
        console.log('🎨 Analyzing current visualization plot...');
        
        if (!currentAgentWorkflow || currentAgentWorkflow.type !== 'visualization') {
          console.log('🎨 No active visualization workflow for analysis');
          return;
        }
        
        // Get current step info
        const currentStep = currentAgentWorkflow.currentStep - 1; // Step that just completed (0-based)
        const arrayIndex = currentAgentWorkflow.currentStep - 2; // Convert 1-based step to 0-based array index
        
        
        const plotConfig = currentAgentWorkflow.workflowSteps[arrayIndex];
        
        if (!plotConfig) {
          addMessage(`❌ **Debug Error:** No plot config found for current step ${currentStep}\n- Available workflow steps: ${JSON.stringify(currentAgentWorkflow.workflowSteps, null, 2)}`, 'ai');
          return;
        }
        
        
        // Extract plot information
        const plotType = plotConfig.plotType || plotConfig.plot_type || 'histogram';
        const actualConfig = plotConfig.plot_config || plotConfig;
        const xVar = plotConfig.xVar || actualConfig.xVar || '';
        const yVar = plotConfig.yVar || actualConfig.yVar || '';
        
        console.log('🎨 Debug - plotConfig:', plotConfig);
        console.log('🎨 Debug - actualConfig:', actualConfig);
        console.log('🎨 Debug - extracted vars:', { plotType, xVar, yVar });
        
        
        // Create data variables object
        const dataVariables = {
          dataframe: currentAgentWorkflow.dataframe
        };
        if (xVar) dataVariables.x = xVar;
        if (yVar) dataVariables.y = yVar;
        
        // Create plot command (construct from plot configuration)
        let plotCommand = '';
        if (plotType === 'histogram') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar})) + geom_histogram(bins = 30)`;
        } else if (plotType === 'density') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar})) + geom_density()`;
        } else if (plotType === 'boxplot') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar}, y = ${yVar})) + geom_boxplot()`;
        } else if (plotType === 'scatter') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar}, y = ${yVar})) + geom_point()`;
        } else if (plotType === 'bar') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar})) + geom_bar()`;
        } else {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar}${yVar ? `, y = ${yVar}` : ''})) + geom_${plotType}()`;
        }
        
        console.log('🎨 Sending visualization plot analysis request:', {
          plotType,
          dataVariables,
          plotCommand
        });
        
        // Send analysis request
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'analyze_visualization_plot',
            plot_command: plotCommand,
            plot_type: plotType,
            data_variables: dataVariables
          }));
        }
      }
      
      // Trigger plot analysis (integrate with existing analyze last plot)
      function triggerPlotAnalysis() {
        console.log('🔍 Triggering plot analysis...');
        
        addMessage("🔍 **Analyzing Generated Plot...**", "ai");
        
        // Send plot analysis request
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'analyze_last_plot'
          }));
        }
      }
      
      
      // Add visualization agent to WebSocket message handler
      const originalOnMessage = ws?.onmessage;
      
      // Initialize visualization agent interactions
      document.addEventListener('DOMContentLoaded', function() {
        setupVisualizationCheckboxInteractions();
      });
      
    </script>
</body>
</html> 