<!DOCTYPE html>
<!-- CACHE BUST: 2024-12-08-v9 - DEBUG: Added table detection logging to diagnose formatting issues -->
<html>
<head>
    <meta charset="UTF-8">
    <title>RgentAI Assistant</title>
    <style>
      :root {
        /* Default light theme variables - will be overridden by JavaScript */
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-card: #ffffff;
        --text-primary: #2c3e50;
        --text-secondary: #6c757d;
        --border-color: #dee2e6;
        --input-bg: #ffffff;
        --code-bg: #f8f9fa;
        --rgent-primary: #ff6b35; /* Will be overridden by JavaScript for theme awareness */
        --rgent-accent: #3498db; /* Will be overridden by JavaScript for theme awareness */
      }
      
      body { 
        font-family: Arial, sans-serif; 
        margin: 20px 20px 0 20px; 
        background-color: var(--bg-primary);
        color: var(--text-primary);
        transition: all 0.3s ease;
      }
      
      /* Header Title */
      .app-header {
        text-align: left;
        margin-bottom: 15px;
        padding: 5px 0;
      }
      
      .app-header h1 {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
      }
      
      /* Tab Navigation */
      .tab-navigation {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        justify-content: flex-end;
      }
      
      .tab-btn {
        padding: 8px 16px;
        background-color: var(--bg-card) !important;
        color: var(--text-primary) !important;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
      }
      
      .tab-btn.active {
        background-color: var(--text-primary) !important;
        color: var(--bg-primary) !important;
        border-color: var(--text-primary) !important;
      }
      
      .tab-btn:hover:not(.active) {
        background-color: var(--text-secondary) !important;
        color: var(--text-primary) !important;
        border-color: var(--text-secondary) !important;
      }
      
      /* Ensure tab button text color never changes on hover - explicitly override any other rules */
      button.tab-btn.active {
        background-color: var(--text-primary) !important;
        color: var(--bg-primary) !important;
        border-color: var(--text-primary) !important;
      }
      button.tab-btn.active:hover {
        background-color: var(--text-secondary) !important;
        color: var(--bg-primary) !important;
        border-color: var(--text-secondary) !important;
      }
      
      button.tab-btn:not(.active) {
        background-color: var(--bg-card) !important;
        color: var(--text-primary) !important;
        border: 1px solid var(--border-color);
      }
      button.tab-btn:not(.active):hover {
        background-color: var(--text-secondary) !important;
        color: var(--text-primary) !important;
        border-color: var(--text-secondary) !important;
      }
      
      .tab-content {
        display: none;
        overflow: hidden;
        padding-bottom: 0;
        margin-bottom: 0;
      }
      
      .tab-content.active {
        display: block;
        overflow: visible;
        padding-bottom: 0;
        margin-bottom: 0;
      }
      
      .chat-container { 
        height: 60vh; 
        min-height: 250px;
        max-height: 70vh;
        overflow-y: auto; 
        border: 1px solid var(--border-color); 
        border-radius: 8px; 
        padding: 15px; 
        margin-bottom: 0 !important; 
        background-color: var(--bg-card); 
        transition: all 0.3s ease;
        flex: 1;
      }
      .message { 
        margin-bottom: 10px; 
        padding: 8px 12px; 
        border-radius: 8px; 
        max-width: 80%; 
        word-wrap: break-word;
        overflow-wrap: break-word;
        white-space: pre-wrap;
        transition: all 0.3s ease;
      }
      .user-message { 
        background-color: var(--text-primary); 
        color: var(--bg-primary); 
        margin-left: auto; 
        margin-right: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      .ai-message { 
        background-color: var(--bg-card); 
        color: var(--text-primary); 
        line-height: 1.5;
        word-wrap: break-word;
        word-break: normal;
        overflow-wrap: break-word;
        hyphens: none;
        white-space: normal;
        border: 1px solid var(--border-color);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .ai-message strong {
        font-weight: bold;
      }
      
      .ai-message em {
        font-style: italic;
      }
      
      .ai-message code {
        background-color: var(--code-bg);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 0.9em;
      }
      
      /* Animated thinking dots */
      .thinking-dots {
        display: inline-block;
        width: 1.2em;
        text-align: left;
      }
      
      /* Streaming cursor - ChatGPT/Gemini style */
      .streaming-cursor {
        display: inline-block;
        width: 2px;
        height: 1.1em;
        background: var(--text-primary);
        margin-left: 2px;
        vertical-align: text-bottom;
        animation: cursor-blink 0.8s ease-in-out infinite;
      }
      
      @keyframes cursor-blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
      }
      
      /* Streaming message container for smooth rendering */
      .ai-message.streaming {
        min-height: 1.5em;
      }
      
      .ai-message.streaming .streaming-content {
        display: inline;
      }
      
      /* Streaming message styles */
      .ai-message.streaming {
        min-height: 1.5em;
      }
      
      .debug-button {
        background-color: #dc3545 !important;
        color: white !important;
        border: none !important;
        padding: 8px 12px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        font-size: 12px !important;
      }
      .debug-button:hover {
        background-color: #c82333 !important;
        color: white !important;
      }
      
      .analyze-button {
        background-color: #805ad5 !important;
        color: white !important;
        border: none !important;
        padding: 8px 12px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        font-size: 12px !important;
      }
      
      .analyze-button:hover {
        background-color: #6b46c1 !important;
      }
      
      .new-chat-button {
        background-color: #6b7280 !important; /* Neutral gray */
        color: white !important;
        border: none !important;
        padding: 8px 12px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        font-size: 12px !important;
      }
      
      .new-chat-button:hover {
        background-color: #4b5563 !important;
      }
      
      .access-button {
        background-color: #8e44ad !important;
        color: white !important;
        border: none !important;
        padding: 16px 32px !important;
        border-radius: 6px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        font-size: 16px !important;
        font-weight: 600 !important;
        width: 100%;
        margin-top: 10px;
      }
      
      .access-button:hover {
        background-color: #7d3c98 !important;
      }
      
      /* Access Section - Centered */
      .access-section {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 50px 60px;
        max-width: 700px;
        width: 85%;
        min-height: 400px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      
      .form-group {
        margin-bottom: 25px;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 12px;
        color: var(--text-primary);
        font-weight: 600;
        font-size: 16px;
        text-align: left;
      }
      
      .form-group input {
        width: 100%;
        padding: 16px 18px;
        border: 2px solid var(--border-color);
        border-radius: 6px;
        background-color: var(--input-bg);
        color: var(--text-primary);
        font-size: 16px;
      }
      
      .form-group input:focus {
        outline: none;
        border-color: #925de8;
        box-shadow: 0 0 0 3px rgba(146, 93, 232, 0.1);
      }
      
      .access-help {
        margin-top: 25px;
        text-align: center;
        font-size: 14px;
        color: var(--text-secondary);
      }
      
      .access-help a {
        color: #925de8;
        text-decoration: none;
      }
      
      .access-help a:hover {
        text-decoration: underline;
      }
      
      #access-status {
        margin-top: 10px;
        padding: 8px;
        border-radius: 4px;
        text-align: center;
        font-size: 14px;
      }
      
      #access-status.success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      
      #access-status.error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
      
      #access-status.info {
        background-color: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
      }
      
      .send-button {
        background-color: #27ae60 !important;
        color: white !important;
        border: none !important;
        padding: 8px 12px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        flex: 0 0 auto !important;
        font-size: 12px !important;
        min-width: fit-content !important;
      }
      
      .send-button:hover {
        background-color: #229954 !important;
      }
      
      .send-button.stop-mode {
        background-color: #e74c3c !important;
        animation: pulse-stop 2s infinite;
      }
      
      .send-button.stop-mode:hover {
        background-color: #c0392b !important;
      }
      
      /* Mode Selector (Auto Execute / Ask) - Simple toggle button */
      .auto-execute-toggle {
        display: flex !important;
        align-items: stretch !important;
        justify-content: stretch !important;
        flex: 0 0 100px !important;
        min-width: 100px !important;
        max-width: 100px !important;
      }
      
      .mode-selector-button {
        width: 100% !important;
        padding: 8px 16px !important;
        border-radius: 4px !important;
        cursor: pointer !important;
        text-align: center !important;
        font-size: 12px !important;
        font-weight: 500 !important;
        color: white !important;
        transition: all 0.3s ease !important;
        border: none !important;
        background-color: #6b7280 !important;
        white-space: nowrap !important;
        user-select: none !important;
        margin: 0 !important;
        box-sizing: border-box !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
      }
      
      .mode-selector-button:hover {
        background-color: #4b5563 !important;
      }
      
      .mode-selector-button:active {
        transform: scale(0.98);
      }
      
      /* Override any tab-content button styles - match New Chat button exactly */
      .tab-content .mode-selector-button {
        background-color: #6b7280 !important;
        color: white !important;
        padding: 8px 16px !important;
      }
      
      .tab-content .mode-selector-button:hover {
        background-color: #4b5563 !important;
        color: white !important;
      }
      
      /* Match New Chat button styling exactly */
      button.mode-selector-button {
        background-color: #6b7280 !important;
        color: white !important;
      }
      
      button.mode-selector-button:hover {
        background-color: #4b5563 !important;
        color: white !important;
      }
      
      /* Ensure input-row doesn't override */
      .input-row .auto-execute-toggle {
        flex: 0 0 100px !important;
        min-width: 100px !important;
        max-width: 100px !important;
      }
      
      .input-row .mode-selector-button {
        padding: 8px 16px !important;
      }
      
      /* Most specific selectors to override everything */
      #mode-selector-button {
        padding: 8px 16px !important;
        box-sizing: border-box !important;
        width: 100% !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        background-color: #6b7280 !important;
        color: white !important;
        border: none !important;
      }
      
      #mode-selector-button:hover {
        background-color: #4b5563 !important;
        color: white !important;
      }
      
      .input-row #mode-selector-button {
        padding: 8px 16px !important;
        box-sizing: border-box !important;
        background-color: #6b7280 !important;
        color: white !important;
      }
      
      .input-row #mode-selector-button:hover {
        background-color: #4b5563 !important;
      }
      
      .tab-content .input-row .auto-execute-toggle {
        flex: 0 0 100px !important;
        min-width: 100px !important;
        max-width: 100px !important;
      }
      
      .tab-content .input-row #mode-selector-button {
        padding: 8px 16px !important;
        width: 100% !important;
        box-sizing: border-box !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        background-color: #6b7280 !important;
        color: white !important;
        border: none !important;
      }
      
      .tab-content .input-row #mode-selector-button:hover {
        background-color: #4b5563 !important;
        color: white !important;
      }
      
      /* Keep hidden checkbox for compatibility */
      .toggle-switch {
        display: none;
      }
      
      /* Execute Cleaning Button Styles */
      .execute-cleaning-button {
        background-color: #27ae60 !important;
        color: white !important;
        border: none !important;
        padding: 10px 20px !important;
        border-radius: 6px !important;
        cursor: pointer !important;
        font-size: 14px !important;
        font-weight: 600 !important;
        transition: all 0.3s ease !important;
        margin-top: 10px !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        display: inline-block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      .execute-cleaning-button:hover {
        background-color: #229954;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      }
      
      .execute-cleaning-button:active {
        background-color: #1e8449;
        transform: translateY(0);
      }
      
      @keyframes pulse-stop {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
      }
      
      /* Prevent breaking of common terms */
      .ai-message {
        word-break: normal !important;
        hyphens: none !important;
      }
      
      /* Specific protection for function names and data frame names */
      .ai-message div {
        word-break: normal !important;
        hyphens: none !important;
      }
      .code-block { 
        background-color: var(--code-bg); 
        border: 1px solid var(--border-color); 
        border-radius: 8px; 
        padding: 15px; 
        margin: 15px 0; 
        font-family: 'Courier New', monospace;
        white-space: pre;
        overflow-x: auto;
        overflow-y: hidden;
        color: var(--text-primary);
        position: relative;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        max-width: 100%;
      }
      
      .code-block-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--bg-secondary);
        margin: -15px -15px 10px -15px;
        padding: 8px 15px;
        border-radius: 8px 8px 0 0;
        color: var(--text-primary);
        font-size: 12px;
        font-weight: bold;
        width: 100%;
      }
      .code-block-actions {
        margin-left: auto;
        display: flex;
        gap: 8px;
        align-items: center;
      }
      
      .copy-button {
        background-color: #38a169;
        color: white;
        border: none;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        transition: background-color 0.2s;
      }
      
      .copy-button:hover {
        background-color: #2f855a;
      }
      
      .copy-button:active {
        background-color: #276749;
      }
      
      .copy-button.copied {
        background-color: #3182ce;
      }
      .insert-button { 
        background-color: #28a745; 
        color: white; 
        border: none; 
        padding: 5px 10px; 
        border-radius: 4px; 
        cursor: pointer; 
        margin: 5px; 
      }
      .insert-button:hover { 
        background-color: #218838; 
      }
      
      .output-block { 
        background-color: var(--code-bg); 
        border: 1px solid var(--border-color); 
        border-left: 4px solid var(--rgent-accent);
        border-radius: 8px; 
        padding: 12px; 
        margin: 12px 0; 
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        white-space: pre;
        overflow-x: auto;
        overflow-y: hidden;
        color: var(--text-primary);
        position: relative;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        max-width: 100%;
        font-size: 11px;
        line-height: 1.4;
        container-type: inline-size;
        container-name: output-block;
      }
      
      /* Output content wrapper for proper scrolling */
      .output-block > div:not(.output-block-header) {
        overflow-x: auto;
        min-width: 0;
      }
      
      /* Responsive output for narrow containers */
      @container output-block (max-width: 400px) {
        .output-block {
          font-size: 10px;
          padding: 8px;
        }
      }
      
      @container output-block (max-width: 300px) {
        .output-block {
          font-size: 9px;
          padding: 6px;
        }
      }
      
      .output-block-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: var(--bg-secondary);
        margin: -12px -12px 8px -12px;
        padding: 6px 12px;
        border-radius: 8px 8px 0 0;
        color: var(--text-primary);
        font-size: 11px;
        font-weight: 600;
        width: calc(100% + 24px);
        border-bottom: 1px solid var(--border-color);
        white-space: nowrap;
      }
      
      /* Tables inside output blocks - more compact for narrow views */
      .output-block table {
        font-size: inherit;
        border-collapse: collapse;
        width: auto;
        min-width: 100%;
      }
      
      .output-block th,
      .output-block td {
        padding: 4px 8px;
        border: 1px solid var(--border-color);
        white-space: nowrap;
      }
      
      .output-block th {
        background: var(--bg-secondary);
        font-weight: 600;
      }
      
      #chat-tab {
        padding-bottom: 0 !important;
        margin-bottom: 0 !important;
        display: flex;
        flex-direction: column;
        height: calc(100vh - 100px);
        gap: 0 !important;
      }
      
      #chat-tab.active {
        padding-bottom: 0 !important;
        margin-bottom: 0 !important;
        display: flex !important;
        flex-direction: column;
        height: calc(100vh - 100px);
        gap: 0 !important;
      }
      
      .input-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 0;
        margin-bottom: 0 !important;
        padding-bottom: 0 !important;
        padding-top: 0 !important;
        flex-shrink: 0;
      }
      
      .button-row {
        margin-bottom: 0 !important;
        margin-top: 0 !important;
        padding-bottom: 0 !important;
        padding-top: 0 !important;
      }
      
      .input-row {
        display: flex;
        gap: 10px;
        margin-bottom: 0 !important;
        padding-bottom: 0 !important;
        background-color: var(--input-bg);
        border-radius: 4px;
        position: relative;
      }
      
      .input-row:has(#user-input:focus) {
        background-color: var(--bg-primary);
      }
      
      .button-row {
        display: flex;
        gap: 10px;
      }
      
      .button-row button {
        margin-bottom: 0 !important;
        padding-bottom: 8px;
      }
      
      /* Button size ratios: Debug = 40, Analyze = 40, New Chat = 20 */
      #debug-error-button {
        flex: 40;
      }
      
      #analyze-plot-button {
        flex: 40;
      }
      
      #new-conversation-button {
        flex: 0 0 100px !important;
        min-width: 100px !important;
        max-width: 100px !important;
      }
      input[type="text"] { 
        flex: 1;
        padding: 8px; 
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--input-bg);
        color: var(--text-primary);
      }
      
      #user-input {
        flex: 1 1 auto !important;
        min-width: 0 !important;
        padding: 8px; 
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: transparent;
        color: var(--text-primary);
        font-family: inherit;
        font-size: inherit;
        resize: none;
        height: 24px;
        max-height: 150px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 1.4;
      }
      
      #user-input:focus {
        outline: none;
        border-color: var(--border-color);
        background-color: transparent;
        box-shadow: none;
      }
      
      /* Specific button classes - each button type has its own explicit styling */
      button.debug-button {
        background-color: #dc3545 !important;
      }
      button.send-button {
        background-color: #27ae60 !important;
      }
      button.analyze-button {
        background-color: #805ad5 !important;
      }
      button.access-button {
        background-color: #8e44ad !important;
      }
      button.copy-button {
        background-color: #38a169 !important;
      }
      button.insert-button {
        background-color: #28a745 !important;
      }
      button.execute-cleaning-button {
        background-color: #27ae60 !important;
      }
      button.new-chat-button {
        background-color: #6b7280 !important;
      }
      
      /* Ensure buttons in tab content are not affected by tab hover */
      .tab-content button:not(.debug-button):not(.send-button):not(.analyze-button):not(.access-button):not(.copy-button):not(.insert-button):not(.execute-cleaning-button):not(.new-chat-button):not(.action-btn):not(.custom-dropdown-button) {
        background-color: var(--text-primary) !important;
        color: var(--bg-primary) !important;
      }
      
      .tab-content button:not(.debug-button):not(.send-button):not(.analyze-button):not(.access-button):not(.copy-button):not(.insert-button):not(.execute-cleaning-button):not(.new-chat-button):not(.action-btn):not(.custom-dropdown-button):hover {
        background-color: var(--rgent-accent) !important;
        color: white !important;
      }
      
      /* Override for specific buttons even inside tab-content */
      .tab-content button.debug-button {
        background-color: #dc3545 !important;
      }
      .tab-content button.send-button {
        background-color: #27ae60 !important;
      }
      .tab-content button.analyze-button {
        background-color: #805ad5 !important;
      }
      .tab-content button.access-button {
        background-color: #8e44ad !important;
      }
      .tab-content button.copy-button {
        background-color: #38a169 !important;
      }
      .tab-content button.insert-button {
        background-color: #28a745 !important;
      }
      .tab-content button.new-chat-button {
        background-color: #6b7280 !important;
      }
      .tab-content button.execute-cleaning-button {
        background-color: #27ae60 !important;
      }

      
      /* Usage Tab Styles */
      .stats-section {
        margin-bottom: 30px;
      }
      
      .stats-section h4 {
        margin-bottom: 15px;
        color: var(--text-primary);
        font-size: 16px;
      }
      
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }
      
      /* Usage Breakdown Styles */
      .usage-breakdown {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 15px;
      }
      
      .usage-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: var(--bg-secondary);
        border-radius: 6px;
        border: 1px solid var(--border-color);
      }
      
      .feature-name {
        font-weight: 500;
        color: var(--text-primary);
      }
      
      .api-calls {
        font-size: 14px;
        color: var(--text-secondary);
        font-family: monospace;
      }
      
      /* Plan Type Box - Horizontal Prominent Display */
      .plan-type-box {
        background: var(--bg-card);
        border: 2px solid var(--rgent-accent);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        text-align: center;
        color: var(--text-primary);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .plan-type-header {
        margin-bottom: 10px;
      }
      
      .plan-type-header h3 {
        margin: 0 0 5px 0;
        font-size: 18px;
        font-weight: bold;
        color: var(--text-primary);
      }
      
      .plan-type-header small {
        color: var(--text-secondary);
        font-size: 12px;
      }
      
      .plan-type-display {
        font-size: 32px;
        font-weight: bold;
        color: var(--rgent-accent);
      }
      
      /* Subscription Info Box */
      .subscription-info-box {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        color: var(--text-primary);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .subscription-header {
        margin-bottom: 15px;
      }
      
      .subscription-header h3 {
        margin: 0 0 5px 0;
        font-size: 18px;
        font-weight: bold;
        color: var(--text-primary);
      }
      
      .subscription-header small {
        color: var(--text-secondary);
        font-size: 12px;
      }
      
      .subscription-details {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      
      .subscription-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid var(--border-color);
      }
      
      .subscription-item:last-child {
        border-bottom: none;
      }
      
      .subscription-label {
        font-weight: 500;
        color: var(--text-secondary);
        font-size: 14px;
      }
      
      .subscription-value {
        font-weight: 600;
        color: var(--text-primary);
        font-size: 14px;
        text-align: right;
      }
      
      /* Total Cost Box - Horizontal Prominent Display */
      .total-cost-box {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        text-align: center;
        color: var(--text-primary);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .total-cost-header {
        margin-bottom: 10px;
      }
      
      .total-cost-header h3 {
        margin: 0 0 5px 0;
        font-size: 18px;
        font-weight: bold;
        color: var(--text-primary);
      }
      
      .total-cost-header small {
        color: var(--text-secondary);
        font-size: 12px;
      }
      
      .total-cost-amount {
        font-size: 32px;
        font-weight: bold;
        color: var(--text-primary);
      }
      
      /* Input Output Container - Side by Side */
      .input-output-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }
      
      .stat-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .stat-card h4 {
        margin-bottom: 10px;
        color: var(--text-primary);
        font-size: 14px;
      }
      
      .stat-card div {
        font-size: 24px;
        font-weight: bold;
        color: var(--text-primary);
        margin-bottom: 5px;
      }
      
      .stat-card small {
        color: var(--text-secondary);
        font-size: 12px;
      }
      
      /* Progress Bar */
      .progress-fill {
        background: #27ae60;
        height: 20px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 12px;
        transition: width 0.3s ease;
      }
      
      #monthly-progress-bar, #free-progress-bar {
        background: var(--bg-secondary);
        border-radius: 10px;
        height: 20px;
        overflow: hidden;
        border: 1px solid var(--border-color);
      }
      
      .access-section {
        background-color: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 15px;
        text-align: center;
        color: var(--text-primary);
      }
      
      .form-group {
        margin-bottom: 15px;
      }
      
      .form-group label {
        display: block;
        margin-bottom: 5px;
        color: var(--text-primary);
        font-weight: bold;
      }
      
      .form-group input {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--input-bg);
        color: var(--text-primary);
      }
      
      .access-help {
        margin-top: 10px;
        font-size: 12px;
        color: var(--text-secondary);
      }
      
      .access-help a {
        color: var(--rgent-accent);
        text-decoration: none;
      }
      
      .access-help a:hover {
        text-decoration: underline;
      }
      
      /* Guide Tab Styles */
      
      .guide-section {
        margin-bottom: 30px;
      }
      
      .guide-section h3 {
        margin-bottom: 15px;
        color: var(--text-primary);
        font-size: 18px;
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 8px;
      }
      
      .guide-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .guide-card h4 {
        margin-bottom: 10px;
        color: var(--text-primary);
        font-size: 16px;
        font-weight: bold;
      }
      
      .guide-card p {
        margin-bottom: 10px;
        line-height: 1.5;
        color: var(--text-secondary);
      }
      
      .guide-card ul {
        margin: 10px 0;
        padding-left: 20px;
      }
      
      .guide-card li {
        margin-bottom: 5px;
        line-height: 1.4;
        color: var(--text-secondary);
      }
      
      .guide-card code {
        background-color: var(--code-bg);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 0.9em;
        color: var(--text-primary);
      }
      
      /* Progress bar for free trial */
      #free-progress-bar {
        width: 100%;
        height: 20px;
        background-color: var(--bg-secondary);
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid var(--border-color);
      }
      
      .progress-fill {
        height: 100%;
        background: #27ae60;
        border-radius: 10px;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 12px;
        font-weight: bold;
      }
      
      /* Agents Tab Styles */
      .agents-container {
        padding: 20px;
        max-width: 600px;
        margin: 0 auto;
      }
      
      .agents-header {
        text-align: center;
        margin-bottom: 30px;
      }
      
      .agents-header h2 {
        color: var(--text-primary);
        margin-bottom: 10px;
      }
      
      .agents-header p {
        color: var(--text-secondary);
        font-size: 16px;
      }
      
      .agent-selection {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .agent-card {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        display: flex;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      
      .agent-card:hover:not(.disabled) {
        border-color: var(--text-primary);
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }
      
      .agent-card.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      .agent-icon {
        font-size: 32px;
        margin-right: 20px;
      }
      
      .agent-info {
        flex: 1;
      }
      
      .agent-info h3 {
        color: var(--text-primary);
        margin: 0 0 5px 0;
        font-size: 18px;
      }
      
      .agent-info p {
        color: var(--text-secondary);
        margin: 0;
        font-size: 14px;
      }
      
      .agent-arrow {
        font-size: 20px;
        color: var(--text-secondary);
        margin-left: 15px;
      }
      
      /* Data Explorer Tab Styles */
      #explorer-tab {
        overflow: hidden !important;
        display: none !important;
        margin: 0;
        padding: 0;
        padding-bottom: 0 !important;
        margin-bottom: 0 !important;
        flex-direction: column;
        height: calc(100vh - 100px);
        position: relative;
      }
      
      #explorer-tab.active {
        display: flex !important;
        overflow: hidden !important;
        margin: 0;
        padding: 0;
        padding-bottom: 0 !important;
        margin-bottom: 0 !important;
        flex-direction: column;
        height: calc(100vh - 100px);
        position: relative;
      }
      
      .explorer-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
        background: var(--bg-primary);
        margin: 0;
        padding: 0;
        flex: 1;
        position: relative;
      }
      
      /* Guide Tab Styles - Hidden, content moved to modal */
      #guide-tab {
        overflow: hidden !important;
        display: none !important;
        margin: 0;
        padding: 0;
        padding-bottom: 0 !important;
        margin-bottom: 0 !important;
        flex-direction: column;
        height: calc(100vh - 100px);
        position: relative;
      }
      
      #guide-tab.active {
        display: none !important; /* Keep hidden even when active - use modal instead */
      }
      
      .guide-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin: 0;
        flex: 1;
        position: relative;
        box-sizing: border-box;
      }
      
      /* Usage Tab Styles */
      #usage-tab {
        overflow: hidden !important;
        display: none !important;
        margin: 0;
        padding: 0;
        padding-bottom: 0 !important;
        margin-bottom: 0 !important;
        flex-direction: column;
        height: calc(100vh - 100px);
        position: relative;
      }
      
      #usage-tab.active {
        display: flex !important;
        overflow: hidden !important;
        margin: 0;
        padding: 0;
        padding-bottom: 0 !important;
        margin-bottom: 0 !important;
        flex-direction: column;
        height: calc(100vh - 100px);
        position: relative;
      }
      
      .usage-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin: 0;
        flex: 1;
        position: relative;
        box-sizing: border-box;
      }
      
      #explorer-dataframe-select-wrapper {
        position: relative !important;
        z-index: 10;
      }
      
      #explorer-dataframe-select-dropdown {
        position: absolute !important;
        z-index: 1001 !important;
        max-height: 400px !important;
        overflow-y: auto !important;
      }
      
      /* Force hide wrapper, button, and dropdown when explorer tab is not active or hidden */
      #explorer-tab:not(.active) #explorer-dataframe-select-wrapper,
      #explorer-tab:not(.active) #explorer-dataframe-select-button,
      #explorer-tab:not(.active) #explorer-dataframe-select-dropdown,
      #explorer-tab[style*="display: none"] #explorer-dataframe-select-wrapper,
      #explorer-tab[style*="display: none"] #explorer-dataframe-select-button,
      #explorer-tab[style*="display: none"] #explorer-dataframe-select-dropdown,
      #explorer-tab[style*="display:none"] #explorer-dataframe-select-wrapper,
      #explorer-tab[style*="display:none"] #explorer-dataframe-select-button,
      #explorer-tab[style*="display:none"] #explorer-dataframe-select-dropdown {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
      }
      
      /* Also hide if any other tab is active */
      #chat-tab.active ~ #explorer-dataframe-select-wrapper,
      #chat-tab.active ~ #explorer-dataframe-select-button,
      #chat-tab.active ~ #explorer-dataframe-select-dropdown,
      #agents-tab.active ~ #explorer-dataframe-select-wrapper,
      #agents-tab.active ~ #explorer-dataframe-select-button,
      #agents-tab.active ~ #explorer-dataframe-select-dropdown,
      #usage-tab.active ~ #explorer-dataframe-select-wrapper,
      #usage-tab.active ~ #explorer-dataframe-select-button,
      #usage-tab.active ~ #explorer-dataframe-select-dropdown,
      #guide-tab.active ~ #explorer-dataframe-select-wrapper,
      #guide-tab.active ~ #explorer-dataframe-select-button,
      #guide-tab.active ~ #explorer-dataframe-select-dropdown {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
      }
      
      /* Nuclear option: hide dropdown unless explicitly in active explorer tab */
      #explorer-dataframe-select-dropdown {
        display: none !important;
      }
      
      #explorer-tab.active #explorer-dataframe-select-dropdown[style*="display: block"],
      #explorer-tab.active #explorer-dataframe-select-dropdown[style*="display:block"] {
        display: block !important;
      }
      
      .explorer-status-bar {
        margin-top: auto;
        margin-bottom: 5px !important;
      }
      
      .explorer-action-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 20px;
        border-bottom: 2px solid var(--border-color);
        background: var(--bg-card);
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        flex-shrink: 0;
      }
      
      .explorer-title-section {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      
      .explorer-title-section select {
        font-size: 14px;
        font-weight: 500;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        min-width: 200px;
      }
      
      /* Ensure select dropdown options have theme-aware colors */
      .explorer-title-section select option {
        background: var(--bg-card) !important;
        color: var(--text-primary) !important;
      }
      
      .explorer-title-section .dims-text {
        font-size: 13px;
        color: var(--text-secondary);
        font-weight: normal;
      }
      
      .custom-dropdown-menu {
        background: var(--bg-card) !important;
        background-color: var(--bg-card) !important;
        opacity: 1 !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
      }
      
      /* Theme-aware gray matching dataview rows (text-secondary) */
      body.dark-theme .dropdown-arrow {
        color: #6c757d;
      }
      
      body:not(.dark-theme) .dropdown-arrow {
        color: #6c757d;
      }
      
      /* Custom dropdown button text color - must use !important to override tab-content rule */
      body.dark-theme .custom-dropdown-button {
        color: var(--text-primary) !important;
      }
      
      body:not(.dark-theme) .custom-dropdown-button {
        color: var(--text-primary) !important;
      }
      
      /* Prevent color change on hover/active/focus for dropdown button */
      .custom-dropdown-button:hover,
      .custom-dropdown-button:active,
      .custom-dropdown-button:focus {
        color: var(--text-primary) !important;
      }
      
      body.dark-theme .custom-dropdown-button:hover,
      body.dark-theme .custom-dropdown-button:active,
      body.dark-theme .custom-dropdown-button:focus {
        color: var(--text-primary) !important;
      }
      
      body:not(.dark-theme) .custom-dropdown-button:hover,
      body:not(.dark-theme) .custom-dropdown-button:active,
      body:not(.dark-theme) .custom-dropdown-button:focus {
        color: var(--text-primary) !important;
      }
      
      .dropdown-category-items {
        background: var(--bg-card) !important;
        background-color: var(--bg-card) !important;
        opacity: 1 !important;
      }
      
      .dropdown-item {
        background: var(--bg-card) !important;
        background-color: var(--bg-card) !important;
        opacity: 1 !important;
      }
      
      .dropdown-category-header {
        background: var(--bg-secondary) !important;
        background-color: var(--bg-secondary) !important;
        opacity: 1 !important;
      }
      
      .explorer-actions {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }
      
      .action-btn {
        padding: 8px 14px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-card);
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: all 0.2s;
        white-space: nowrap;
        color: var(--text-primary) !important;
      }
      
      .action-btn:hover:not(:disabled) {
        /* No color change on hover */
        color: var(--text-primary) !important;
      }
      
      .action-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        color: var(--text-primary) !important;
      }
      
      /* Prevent color and background change on active/focus for action buttons */
      .action-btn:active,
      .action-btn:focus,
      .action-btn:focus-visible,
      .action-btn:focus-within {
        color: var(--text-primary) !important;
        background: var(--bg-card) !important;
        outline: none !important;
        box-shadow: none !important;
      }
      
      .action-btn:active:not(:disabled),
      .action-btn:focus:not(:disabled),
      .action-btn:focus-visible:not(:disabled) {
        background: var(--bg-card) !important;
        color: var(--text-primary) !important;
        outline: none !important;
        box-shadow: none !important;
      }
      
      /* Ensure buttons maintain color after click (remove any visited/active state styling) */
      .action-btn:visited {
        color: var(--text-primary) !important;
        background: var(--bg-card) !important;
      }
      
      .explorer-filter-bar {
        padding: 10px;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
      }
      
      .filter-item {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        margin-right: 8px;
        margin-bottom: 8px;
      }
      
      .explorer-grid-container {
        display: flex;
        flex: 1;
        overflow: hidden;
        min-height: 0;
      }
      
      .explorer-summary-panel {
        width: 320px;
        border-right: 2px solid var(--border-color);
        display: flex;
        flex-direction: column;
        background: var(--bg-card);
        flex-shrink: 0;
        box-shadow: 2px 0 4px rgba(0,0,0,0.05);
      }
      
      .explorer-summary-panel.collapsed {
        width: 0;
        overflow: hidden;
      }
      
      .summary-header {
        padding: 12px;
        border-bottom: 2px solid var(--border-color);
        display: flex;
        gap: 6px;
        flex-shrink: 0;
        background: var(--bg-secondary);
      }
      
      .summary-header input {
        font-size: 13px;
        padding: 6px 10px;
        border-radius: 4px;
      }
      
      .summary-header select {
        font-size: 12px;
        padding: 6px 8px;
        border-radius: 4px;
      }
      
      .summary-columns-list {
        flex: 1;
        overflow-y: auto;
        padding: 4px 0;
      }
      
      .summary-column-item {
        padding: 12px 14px;
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s;
        background: var(--bg-card);
        position: relative;
      }
      
      .summary-column-item:hover {
        background: var(--bg-secondary);
        padding-left: 16px;
      }
      
      .summary-column-item.expanded {
        background: var(--bg-secondary);
        border-left: 3px solid var(--text-primary);
      }
      
      .expand-icon {
        display: inline-block;
        transition: transform 0.2s ease;
      }
      
      .summary-column-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 6px;
      }
      
      .summary-column-header span:first-of-type {
        font-weight: 600;
        font-size: 13px;
        color: var(--text-primary);
      }
      
      .summary-column-header span:last-of-type {
        font-size: 11px;
        color: var(--text-secondary);
        margin-left: auto;
      }
      
      .column-type-icon {
        width: 16px;
        height: 16px;
        border-radius: 2px;
        display: inline-block;
      }
      
      .column-type-icon.numeric {
        background: color-mix(in srgb, var(--text-primary) 70%, var(--bg-primary));
      }
      
      .column-type-icon.character {
        background: color-mix(in srgb, var(--text-primary) 60%, var(--bg-primary));
      }
      
      .column-type-icon.factor {
        background: color-mix(in srgb, var(--text-primary) 50%, var(--bg-primary));
      }
      
      .column-type-icon.logical {
        background: color-mix(in srgb, var(--text-primary) 65%, var(--bg-primary));
      }
      
      .mini-sparkline {
        height: 35px;
        display: flex;
        align-items: flex-end;
        gap: 2px;
        margin: 8px 0;
        padding: 4px 8px;
        background: var(--bg-primary);
        border-radius: 4px;
        border: 1px solid var(--border-color);
      }
      
      .sparkline-bar {
        flex: 1;
        min-height: 2px;
        border-radius: 2px 2px 0 0;
        transition: opacity 0.2s;
      }
      
      .sparkline-bar:hover {
        opacity: 0.8;
      }
      
      /* Theme-aware blue for histogram bars */
      body.dark-theme .sparkline-bar {
        background: #4a9eff;
      }
      
      body:not(.dark-theme) .sparkline-bar {
        background: #0066cc;
      }
      
      .missing-data-bar {
        height: 5px;
        background: linear-gradient(to right, var(--text-primary), color-mix(in srgb, var(--text-primary) 80%, transparent));
        margin-top: 6px;
        border-radius: 3px;
        box-shadow: 0 1px 2px color-mix(in srgb, var(--text-primary) 30%, transparent);
      }
      
      .column-stats-expanded {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid var(--border-color);
        font-size: 13px;
        color: var(--text-secondary);
        line-height: 1.6;
      }
      
      .column-stats-expanded div {
        padding: 2px 0;
      }
      
      .column-stats-expanded strong {
        color: var(--text-primary);
        font-weight: 600;
      }
      
      .explorer-grid-wrapper {
        flex: 1;
        overflow: auto;
        position: relative;
        min-width: 0;
      }
      
      .explorer-grid {
        position: relative;
      }
      
      .grid-header {
        display: flex;
        position: sticky;
        top: 0;
        z-index: 100;
        background: var(--bg-card);
      }
      
      .row-header-corner {
        position: sticky;
        left: 0;
        z-index: 101;
        flex-shrink: 0;
      }
      
      .grid-column-headers {
        display: grid;
        flex: 1;
        min-width: 0;
      }
      
      .grid-column-header {
        padding: 10px 12px;
        border-right: 1px solid var(--border-color);
        border-bottom: 2px solid var(--border-color);
        cursor: pointer;
        position: relative;
        min-width: 120px;
        user-select: none;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-weight: 600;
        font-size: 12px;
        color: var(--text-primary);
        transition: background 0.2s;
        box-sizing: border-box;
        height: 35px;
        display: flex;
        align-items: center;
      }
      
      .grid-column-header:hover {
        background: var(--bg-primary);
        box-shadow: inset 0 -2px 0 var(--text-primary);
      }
      
      .grid-column-header.sorted-asc::after {
        content: " ";
        color: var(--text-primary);
        font-weight: bold;
        margin-left: 4px;
      }
      
      .grid-column-header.sorted-desc::after {
        content: " ";
        color: var(--text-primary);
        font-weight: bold;
        margin-left: 4px;
      }
      
      .grid-column-header.pinned {
        background: var(--bg-primary);
        border-left: 3px solid var(--text-primary);
        padding-left: 10px;
      }
      
      .resize-handle {
        position: absolute;
        right: 0;
        top: 0;
        width: 4px;
        height: 100%;
        cursor: col-resize;
        background: transparent;
      }
      
      .resize-handle:hover {
        background: var(--text-primary);
      }
      
      .grid-body {
        display: flex;
        position: relative;
      }
      
      .grid-row-headers {
        position: sticky;
        left: 0;
        z-index: 50;
        background: var(--bg-card);
        display: flex;
        flex-direction: column;
        width: 60px;
        min-width: 60px;
        max-width: 60px;
        flex-shrink: 0;
      }
      
      .grid-row-header {
        padding: 8px 10px;
        border-right: 2px solid var(--border-color);
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        text-align: right;
        user-select: none;
        width: 60px;
        min-width: 60px;
        max-width: 60px;
        font-size: 11px;
        color: var(--text-secondary);
        font-weight: 500;
        transition: background 0.2s;
        box-sizing: border-box;
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        flex-shrink: 0;
      }
      
      .grid-row-header:hover {
        background: var(--bg-primary);
      }
      
      .grid-row-header.pinned {
        background: var(--bg-primary);
        border-top: 3px solid var(--text-primary);
      }
      
      .grid-data-cells {
        display: grid;
        flex: 1;
      }
      
      .grid-cell {
        padding: 8px 12px;
        border-right: 1px solid var(--border-color);
        border-bottom: 1px solid var(--border-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: cell;
        background: var(--bg-card);
        font-size: 12px;
        color: var(--text-primary);
        transition: background 0.15s;
        height: 35px;
        display: flex;
        align-items: center;
        box-sizing: border-box;
      }
      
      .grid-cell:hover {
        background: var(--bg-secondary);
      }
      
      .grid-cell.selected {
        background: color-mix(in srgb, var(--text-primary) 25%, transparent);
        border: 1px solid var(--text-primary);
        z-index: 10;
        position: relative;
      }
      
      .grid-cell.range-selected {
        background: color-mix(in srgb, var(--text-primary) 15%, transparent);
      }
      
      .explorer-status-bar {
        padding: 8px 20px;
        border-top: 2px solid var(--border-color);
        background: var(--bg-card);
        font-size: 12px;
        color: var(--text-secondary);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        box-shadow: 0 -2px 4px rgba(0,0,0,0.05);
      }
      
      .explorer-status-bar #explorer-status-text {
        font-weight: 500;
        color: var(--text-primary);
      }
      
      /* Context Menu Styles */
      .context-menu {
        position: absolute;
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        min-width: 180px;
        padding: 4px 0;
      }
      
      .context-menu-item {
        padding: 8px 16px;
        cursor: pointer;
        font-size: 13px;
        color: var(--text-primary);
      }
      
      .context-menu-item:hover {
        background: var(--bg-secondary);
      }
      
      .context-menu-item.disabled {
        color: var(--text-secondary);
        cursor: not-allowed;
        opacity: 0.5;
      }
      
      /* Transformation Tab Styles */
      .transformation-container {
        padding: 20px;
        max-width: 800px;
        margin: 0 auto;
      }
      
      .transformation-header {
        text-align: center;
        margin-bottom: 30px;
      }
      
      .transformation-header h2 {
        color: var(--text-primary);
        margin-bottom: 10px;
      }
      
      .transformation-header p {
        color: var(--text-secondary);
        font-size: 16px;
      }
      
      .transformation-config {
        background: var(--bg-card);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 25px;
      }
      
      .transformation-checklist {
        margin-top: 20px;
        padding: 20px;
        background-color: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        display: none; /* FIXED: Start hidden, will be shown when dataframe selected */
      }
      
      .statistical-checklist {
        margin-top: 20px;
        padding: 20px;
        background-color: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        display: none; /* Start hidden, will be shown when dataframe selected */
      }
      
      .variable-selection {
        background-color: var(--bg-primary);
        padding: 15px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        margin-top: 10px;
      }
      
      .variable-selection label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: var(--text-primary);
      }
      
      .variable-selection select {
        width: 100%;
        margin-bottom: 10px;
        padding: 10px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--input-bg);
        color: var(--text-primary);
        font-size: 14px;
      }
      
      .test-guidance {
        margin-top: 8px;
        padding: 10px;
        background: color-mix(in srgb, var(--text-primary) 5%, var(--bg-primary));
        border-left: 4px solid var(--text-primary);
        border-radius: 6px;
        font-size: 12px;
        line-height: 1.4;
        color: var(--text-primary);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .test-guidance .warning {
        color: var(--text-primary);
        font-weight: 600;
      }
      
      .transformation-checklist h4 {
        color: var(--text-primary);
        margin-bottom: 20px;
        font-size: 18px;
      }
      
      /* Agent Configuration Styles */
      .agent-config {
        animation: slideIn 0.3s ease;
      }
      
      .config-header {
        display: flex;
        align-items: center;
        margin-bottom: 25px;
        padding-bottom: 15px;
        border-bottom: 1px solid var(--border-color);
      }
      
      .back-btn {
        background: none;
        border: none;
        color: var(--text-primary);
        cursor: pointer;
        font-size: 14px;
        margin-right: 15px;
        padding: 5px 10px;
        border-radius: 4px;
      }
      
      .back-btn:hover {
        text-decoration: underline;
      }
      
      .config-header h3 {
        color: var(--text-primary);
        margin: 0;
        font-size: 20px;
      }
      
      .config-form {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      
      .form-group {
        display: flex;
        flex-direction: column;
      }
      
      .form-group label {
        color: var(--text-primary);
        font-weight: 600;
        margin-bottom: 8px;
        font-size: 14px;
      }
      
      .form-group select {
        padding: 10px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--input-bg);
        color: var(--text-primary);
        font-size: 14px;
      }
      
      /* Ensure select dropdown options have theme-aware colors for agents only */
      .form-group select option {
        background: var(--bg-card) !important;
        color: var(--text-primary) !important;
      }
      
      .start-agent-btn {
        padding: 12px 20px;
        background: var(--text-primary) !important;
        color: var(--bg-primary) !important;
        border: none !important;
        border-radius: 6px !important;
        font-size: 16px !important;
        font-weight: 600 !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        margin-top: 10px !important;
      }
      
      .start-agent-btn:hover:not(:disabled) {
        background: var(--text-secondary) !important;
        color: var(--bg-primary) !important;
      }
      
      /* Ensure start-agent-btn overrides general button rule with higher specificity */
      button.start-agent-btn {
        background: var(--text-primary) !important;
        color: var(--bg-primary) !important;
      }
      button.start-agent-btn:hover:not(:disabled) {
        background: var(--text-secondary) !important;
        color: var(--bg-primary) !important;
      }
      
      .start-agent-btn:disabled {
        background: var(--text-secondary);
        cursor: not-allowed;
        opacity: 0.6;
      }
      
      /* Visualization Plot Configuration Styles */
      .plot-configs {
        margin-top: 15px;
        padding: 15px;
        background: var(--background-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }
      
      .plot-config-section {
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        background: var(--background-primary);
      }
      
      .plot-config-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      
      .plot-config-header h5 {
        margin: 0;
        color: var(--text-primary);
      }
      
      .plot-config-details {
        margin-top: 15px;
      }
      
      .remove-plot-btn {
        background: #ff4444;
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.3s ease;
      }
      
      .remove-plot-btn:hover {
        background: #cc0000;
      }
      
      .add-plot-section {
        margin-top: 15px;
        text-align: center;
      }
      
      .add-plot-btn {
        background: #2ed573;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: background-color 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      
      .add-plot-btn:hover {
        background: #26d065;
      }
      
      @keyframes slideIn {
        from { opacity: 0; transform: translateX(20px); }
        to { opacity: 1; transform: translateX(0); }
      }
      
      /* Cleaning Checklist Styles */
      .cleaning-checklist {
        margin-top: 20px;
        padding: 20px;
        background: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid color-mix(in srgb, var(--text-primary) 20%, transparent);
      }
      
      .cleaning-checklist h4 {
        color: var(--text-primary);
        margin: 0 0 15px 0;
        font-size: 16px;
        font-weight: 600;
      }
      
      .checklist-group {
        margin-bottom: 15px;
      }
      
      .checkbox-item {
        display: flex;
        align-items: flex-start;
        cursor: pointer;
        padding: 12px;
        border-radius: 6px;
        transition: background-color 0.2s ease;
        position: relative;
      }
      
      .checkbox-item:hover {
        background: color-mix(in srgb, var(--text-primary) 5%, transparent);
      }
      
      .checkbox-item input[type="checkbox"] {
        display: none;
      }
      
      .checkmark {
        width: 20px;
        height: 20px;
        border: 2px solid var(--border-color);
        border-radius: 4px;
        margin-right: 12px;
        flex-shrink: 0;
        position: relative;
        transition: all 0.2s ease;
        background: var(--bg-primary);
      }
      
      .checkbox-item input[type="checkbox"]:checked + .checkmark {
        background: var(--text-primary);
        border-color: var(--text-primary);
      }
      
      .checkbox-item input[type="checkbox"]:checked + .checkmark::after {
        content: '';
        position: absolute;
        left: 3px;
        top: -1px;
        color: white;
        font-size: 14px;
        font-weight: bold;
      }
      
      .checkbox-item.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      
      .checkbox-item.disabled .checkmark {
        background: var(--bg-tertiary);
        border-color: var(--border-color);
      }
      
      .checkbox-item.disabled input[type="checkbox"]:checked + .checkmark {
        background: var(--text-secondary);
        border-color: var(--text-secondary);
      }
      
      .checkbox-item.disabled input[type="checkbox"]:checked + .checkmark::after {
        content: '';
        top: 1px;
        left: 4px;
      }
      
      .checkbox-item .checkbox-content {
        flex: 1;
      }
      
      .checkbox-item small {
        display: block;
        color: var(--text-secondary);
        font-size: 12px;
        margin-top: 2px;
        line-height: 1.3;
      }
      
      /* Variable Selection Styles */
      .variable-selection-subsection {
        margin-top: 15px;
        padding: 12px;
        background: color-mix(in srgb, var(--text-primary) 3%, transparent);
        border-radius: 6px;
        border: 1px solid color-mix(in srgb, var(--text-primary) 8%, transparent);
      }
      
      .variable-selection-subsection h6 {
        color: var(--text-primary);
        margin: 0 0 10px 0;
        font-size: 13px;
        font-weight: 600;
      }
      
      .variable-selection-controls {
        display: flex;
        gap: 8px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
      
      .variable-selection-controls .btn-small {
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 4px;
        border: 1px solid color-mix(in srgb, var(--text-primary) 20%, transparent);
        background: var(--background-primary);
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .variable-selection-controls .btn-small:hover {
        background: color-mix(in srgb, var(--text-primary) 10%, transparent);
        border-color: color-mix(in srgb, var(--text-primary) 30%, transparent);
      }
      
      .btn-small {
        padding: 6px 12px;
        font-size: 12px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .btn-small:hover {
        background: var(--text-primary);
        color: var(--bg-primary);
        border-color: var(--text-primary);
      }
      
      .variable-selection-container {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-primary);
        padding: 10px;
      }
      
      .variable-checkbox-item {
        display: flex;
        align-items: center;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      
      .variable-checkbox-item:hover {
        background: color-mix(in srgb, var(--text-primary) 5%, transparent);
      }
      
      .variable-checkbox-item input[type="checkbox"] {
        margin-right: 8px;
        cursor: pointer;
      }
      
      .variable-info {
        flex: 1;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .variable-name {
        font-weight: 500;
        color: var(--text-primary);
      }
      
      .variable-type {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 3px;
        background: var(--bg-tertiary);
        color: var(--text-secondary);
      }
      
      .variable-type.numeric {
        background: color-mix(in srgb, var(--text-primary) 10%, transparent);
        color: var(--text-primary);
      }
      
      .variable-type.categorical {
        background: color-mix(in srgb, var(--text-primary) 10%, transparent);
        color: var(--text-primary);
      }
      
      .sub-options {
        margin-left: 32px;
        margin-top: 8px;
        padding: 10px;
        background: var(--bg-primary);
        border-radius: 4px;
        border: 1px solid var(--border-color);
      }
      
      .sub-options label {
        font-size: 12px;
        color: var(--text-secondary);
        margin-bottom: 5px;
        display: block;
      }
      
      .sub-select {
        width: 100%;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 12px;
      }
      
      .sub-textarea {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 12px;
        font-family: inherit;
        resize: vertical;
        min-height: 60px;
      }
      

      
      /* Modal Styles */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .modal-content {
        background: var(--bg-card);
        border-radius: 12px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        margin: 20px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      }
      
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 24px;
        border-bottom: 1px solid var(--border-color);
      }
      
      .modal-header h3 {
        color: var(--text-primary);
        margin: 0;
        font-size: 20px;
      }
      
      .modal-close {
        font-size: 24px;
        cursor: pointer;
        color: var(--text-secondary);
        transition: color 0.3s ease;
      }
      
      .modal-close:hover {
        color: var(--text-primary);
      }
      
      .modal-body {
        padding: 24px;
      }
      
      /* Guide modal specific styling */
      #guide-modal {
        z-index: 10000 !important;
        position: fixed !important;
        background: var(--bg-primary) !important;
      }
      
      #guide-modal .modal-content {
        background: var(--bg-card) !important;
        background-color: var(--bg-card) !important;
        opacity: 1 !important;
      }
      
      #guide-modal .modal-header {
        position: sticky !important;
        top: 0 !important;
        background: #4a4a4a !important;
        background-color: #4a4a4a !important;
        opacity: 1 !important;
        z-index: 10 !important;
        border-bottom: 1px solid var(--border-color) !important;
      }
      
      #guide-modal .modal-header h3 {
        color: #ffffff !important;
      }
      
      #guide-modal .modal-close {
        color: #ffffff !important;
      }
      
      #guide-modal .modal-close:hover {
        color: #e0e0e0 !important;
      }
      
      .config-section {
        margin-bottom: 24px;
      }
      
      .config-section label {
        display: block;
        color: var(--text-primary);
        font-weight: 600;
        margin-bottom: 8px;
      }
      
      .config-section select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--input-bg);
        color: var(--text-primary);
        font-size: 14px;
      }
      
      /* Ensure select dropdown options have theme-aware colors */
      .config-section select option {
        background: var(--bg-card) !important;
        color: var(--text-primary) !important;
      }
      
      .dataframe-info {
        margin-top: 12px;
        padding: 12px;
        background: var(--bg-secondary);
        border-radius: 6px;
        font-size: 13px;
        color: var(--text-secondary);
      }
      
      .radio-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .radio-option {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        transition: background 0.3s ease;
      }
      
      .radio-option:hover {
        background: var(--bg-secondary);
      }
      
      .radio-option input[type="radio"] {
        margin: 0;
      }
      
      .workflow-steps {
        color: var(--text-secondary);
        padding-left: 20px;
      }
      
      .workflow-steps li {
        margin-bottom: 4px;
      }
      
      .modal-footer {
        padding: 20px 24px;
        border-top: 1px solid var(--border-color);
        background: var(--bg-secondary);
        border-radius: 0 0 12px 12px;
      }
      
      .modal-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }
      
      .btn-secondary {
        padding: 10px 20px;
        background: var(--bg-card);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
      }
      
      .btn-secondary:hover {
        background: var(--bg-secondary);
      }
      
      .btn-primary {
        padding: 10px 20px;
        background: var(--text-primary);
        color: var(--bg-primary);
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
      }
      
      .btn-primary:hover:not(:disabled) {
        background: var(--rgent-accent);
      }
      
      .btn-primary:disabled {
        background: var(--text-secondary);
        cursor: not-allowed;
        opacity: 0.6;
      }
      
    </style>
</head>
<body>
    <!-- Access Code Section -->
    <div id="access-section" class="access-section">
      <h3 style="margin-top: 0; margin-bottom: 30px; text-align: center; color: var(--text-primary); font-size: 28px; font-weight: 600;">Rgent - Your RStudio AI Assistant</h3>
      <div class="form-group">
        <label for="access-code">Access Code:</label>
        <div style="position: relative; display: flex; align-items: center;">
          <input type="password" id="access-code" placeholder="Enter your access code" style="flex: 1; margin-right: 10px;">
          <button type="button" id="toggleAccessCode" style="background: none; border: none; cursor: pointer; color: #925de8; font-size: 12px; padding: 8px 12px; font-weight: 500; text-decoration: underline; white-space: nowrap;">
            Show
          </button>
        </div>
      </div>
                <button onclick="validateAccess()" class="access-button">Validate Access</button>
      <div id="access-status"></div>
      <div class="access-help">
        <p>Forgot your access code? <a href="https://rgentai.com/signin.html" target="_blank">Click here</a></p>
      </div>
    </div>
    
    <!-- Main Interface with Tabs -->
    <div id="main-interface" style="display: none;">
      <div class="app-header">
        <h1>Rgent - Your AI Assistant</h1>
      </div>
      <!-- Tab Navigation -->
      <div class="tab-navigation">
        <button class="tab-btn active" onclick="switchTab('chat')">Chat</button>
        <button class="tab-btn" onclick="switchTab('explorer')">Data Explorer</button>
        <button class="tab-btn" onclick="switchTab('agents')" id="agents-tab-btn">Agents</button>
        <button class="tab-btn" onclick="switchTab('usage')">Usage</button>
      </div>
      
      <!-- Chat Tab -->
      <div id="chat-tab" class="tab-content active">
        <div id="chat-container" class="chat-container">
        </div>
        <div class="input-container">
          <div class="input-row">
            <textarea id="user-input" placeholder="Ask me anything about your R project" disabled rows="1" style="resize: none; height: 24px; max-height: 150px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;"></textarea>
            <button onclick="sendMessage()" id="send-button" disabled class="send-button">Send</button>
            <div class="auto-execute-toggle">
              <input type="checkbox" id="auto-execute-toggle" checked style="display: none;">
              <button class="mode-selector-button" id="mode-selector-button" onclick="toggleMode()">Auto Execute</button>
            </div>
          </div>
          <div class="button-row">
            <button onclick="debugLastError()" id="debug-error-button" disabled class="debug-button">Debug Last Error</button>
            <button onclick="analyzeLastPlot()" id="analyze-plot-button" disabled class="analyze-button">Analyze Last Plot</button>
            <button onclick="newConversation()" id="new-conversation-button" disabled class="new-chat-button">New Chat</button>
          </div>
        </div>

      </div>
      
      <!-- Usage Tab -->
      <div id="usage-tab" class="tab-content">
        <div class="usage-container">
          <div class="section">
            <h3>Usage Statistics</h3>
            
            <!-- Overall Stats -->
            <div class="stats-section" id="paid-usage-section">
              
              <!-- Plan Type Display -->
              <div class="plan-type-box">
                <div class="plan-type-header">
                  <h3>Current Plan</h3>
                  <small>Your subscription</small>
                </div>
                <div class="plan-type-display" id="plan-type-display">-</div>
              </div>
              
              <!-- Subscription Info -->
              <div class="subscription-info-box">
                <div class="subscription-header">
                  <h3>Subscription Details</h3>
                  <small>Billing information</small>
                </div>
                <div class="subscription-details">
                  <div class="subscription-item">
                    <span class="subscription-label">Status:</span>
                    <span class="subscription-value" id="subscription-status">-</span>
                </div>
                  <div class="subscription-item">
                    <span class="subscription-label">Next Billing:</span>
                    <span class="subscription-value" id="subscription-end-date">-</span>
                  </div>

              </div>
            </div>

            </div>



            <!-- Monthly Usage -->
            <div class="stats-section" id="monthly-usage-section">
              <h4>Monthly Usage</h4>
              
              <!-- Monthly Requests -->
              <div class="stat-card">
                <h4>Monthly Requests</h4>
                <div id="monthly-requests">-</div>
                <small id="monthly-requests-limit">-</small>
              </div>
              
              <!-- Requests Remaining -->
                <div class="stat-card">
                <h4>Requests Remaining</h4>
                <div id="requests-remaining">-</div>
                <small>This month</small>
                </div>
              
              <!-- Progress Bar -->
                <div class="stat-card">
                <h4>Progress</h4>
                <div id="monthly-progress-bar">
                  <div class="progress-fill" id="monthly-progress-fill"></div>
                </div>
                <small>Monthly usage progress</small>
              </div>
            </div>

            <!-- Free Trial Stats -->
            <div class="stats-section" id="free-trial-section" style="display: none;">
              <h4>Free Trial Usage</h4>
              <div class="stats">
                <div class="stat-card">
                  <h4>Requests Used</h4>
                  <div id="free-requests-used">-</div>
                  <small>Out of 25 free requests</small>
                </div>
                <div class="stat-card">
                  <h4>Requests Remaining</h4>
                  <div id="free-requests-remaining">-</div>
                  <small>Free trial requests left</small>
                </div>
                <div class="stat-card">
                  <h4>Progress</h4>
                  <div id="free-progress-bar">
                    <div class="progress-fill" id="free-progress-fill"></div>
                  </div>
                  <small>Free trial progress</small>
                </div>
              </div>
            </div>

            <div id="usage-status" class="status" style="display: none;"></div>
            
            <!-- API Usage Info -->
            <div class="stats-section">
              <h4>Requests per Feature</h4>
              <div class="usage-breakdown">
                <div class="usage-item">
                  <span class="feature-name">Data Explorer</span>
                  <span class="api-calls">0 requests</span>
                </div>
                <div class="usage-item">
                  <span class="feature-name">Basic Chat</span>
                  <span class="api-calls">1 request per message</span>
          </div>
                <div class="usage-item">
                  <span class="feature-name">Auto Execute</span>
                  <span class="api-calls">1-3 requests</span>
                </div>
                <div class="usage-item">
                  <span class="feature-name">Analyze Last Plot</span>
                  <span class="api-calls">1 request when used</span>
                </div>
                <div class="usage-item">
                  <span class="feature-name">Debug Last Error</span>
                  <span class="api-calls">1 request when used</span>
                </div>
                <div class="usage-item">
                  <span class="feature-name">Agent Workflows</span>
                  <span class="api-calls">2-5 requests per workflow</span>
                </div>
              </div>
              <small style="color: var(--text-secondary); font-style: italic;">
                Agents use: 1 analysis request + 1 code generation request + up to 3 error fix requests if needed
              </small>
            </div>
          </div>
          
          <!-- Guide Link -->
          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color); text-align: center;">
            <button onclick="event.stopPropagation(); openGuideModal();" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.3s ease;">
               View Guide & Help
            </button>
          </div>
        </div>
      </div>
      
      <!-- Agents Tab -->
      <div id="agents-tab" class="tab-content">
        <div class="agents-container">
          <div class="agents-header">
            <div class="header-with-back" style="display: flex; justify-content: space-between; align-items: center;">
              <h2 id="agents-main-header">AI Agents</h2>
              <button id="back-to-agents-btn" class="back-btn" onclick="showAgentSelection()" style="display: none;"> Back to Agents</button>
            </div>
            <p id="agent-selection-prompt">Select an agent to get started</p>
          </div>
          
          <!-- Agent Selection View -->
          <div id="agent-selection" class="agent-selection">
            <div class="agent-card" onclick="selectAgent('cleaning')">
              <div class="agent-icon"></div>
              <div class="agent-info">
                <h3>Data Cleaning Agent</h3>
                <p>Clean datasets: handle missing values, fix types, remove outliers</p>
              </div>
              <div class="agent-arrow"></div>
            </div>
            
            <div class="agent-card" onclick="selectAgent('transformation')">
              <div class="agent-icon"></div>
              <div class="agent-info">
                <h3>Data Transformation Agent</h3>
                <p>Transform data: create variables, apply functions, reshape structure</p>
              </div>
              <div class="agent-arrow"></div>
            </div>
            
            <div class="agent-card" onclick="selectAgent('visualization')">
              <div class="agent-icon"></div>
              <div class="agent-info">
                <h3>Visualization Agent</h3>
                <p>Create intelligent plots and visualizations with automatic analysis</p>
              </div>
              <div class="agent-arrow"></div>
            </div>
            
            <div class="agent-card" onclick="selectAgent('modeling')">
              <div class="agent-icon"></div>
              <div class="agent-info">
                <h3>Modeling Agent</h3>
                <p>Build ML models with interpretability and AI-powered insights</p>
              </div>
              <div class="agent-arrow"></div>
            </div>
            
            <div class="agent-card" onclick="selectAgent('statistical')">
              <div class="agent-icon"></div>
              <div class="agent-info">
                <h3>Statistical Analysis Agent</h3>
                <p>Perform hypothesis tests, analyze distributions, and calculate effect sizes</p>
              </div>
              <div class="agent-arrow"></div>
            </div>
          </div>
          
          <!-- Cleaning Agent Configuration -->
          <div id="cleaning-config" class="agent-config" style="display: none;">

            
            <div class="config-form">
              <div class="form-group">
                <label for="dataframe-select-main">Select DataFrame</label>
                <select id="dataframe-select-main">
                  <option value="">-- Choose a DataFrame --</option>
                </select>
                <div id="dataframe-info-main" class="dataframe-info" style="display: none;"></div>
              </div>
              
              <div id="cleaning-checklist" class="cleaning-checklist" style="display: none;">
                <h4>Select Cleaning Operations</h4>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-data-types" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      Data Type Check & Conversion
                      <small>Identify and fix data type issues</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="data-type-options" style="display: none;">
                    <label for="data-type-method-select">Conversion method:</label>
                    <select id="data-type-method-select" class="sub-select">
                      <option value="automatic" selected>Automatic detection</option>
                      <option value="other">Other (specify below)</option>
                    </select>
                    <div id="data-type-other-input" style="display: none; margin-top: 8px;">
                      <label for="data-type-custom-input">Custom method:</label>
                      <textarea id="data-type-custom-input" class="sub-textarea" 
                                placeholder="e.g., 'Force all text to factor', 'Convert dates to POSIXct', 'Handle mixed types'"
                                rows="2"></textarea>
                    </div>
                    
                    <!-- Variable Selection for Data Types -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('data-types')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('data-types')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('data-types')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('data-types')">None</button>
                      </div>
                      <div id="data-types-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group" id="missing-values-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-missing-values" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      Missing Values Analysis
                      <small>Detect % missing per column</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="missing-handling-options" style="display: none;">
                    <label for="na-handling-select">Handle missing values:</label>
                    <select id="na-handling-select" class="sub-select">
                      <option value="median" selected>Replace with median (numeric)</option>
                      <option value="mean">Replace with mean (numeric)</option>
                      <option value="mode">Replace with mode (text)</option>
                      <option value="remove">Remove rows with missing values</option>
                      <option value="dont">Just analyze, don't fix</option>
                      <option value="other">Other (specify below)</option>
                    </select>
                    <div id="missing-values-other-input" style="display: none; margin-top: 8px;">
                      <label for="missing-values-custom-input">Custom method:</label>
                      <textarea id="missing-values-custom-input" class="sub-textarea" 
                                placeholder="e.g., 'KNN imputation', 'Forward fill', 'Interpolation', 'Multiple imputation'"
                                rows="2"></textarea>
                    </div>
                    
                    <!-- Variable Selection for Missing Values -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('missing-values')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('missing-values')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('missing-values')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('missing-values')">None</button>
                      </div>
                      <div id="missing-values-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-duplicates" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      Duplicate Detection
                      <small>Count and identify duplicate rows</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="duplicates-options" style="display: none;">
                    <!-- Variable Selection for Duplicates -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('duplicates')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('duplicates')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('duplicates')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('duplicates')">None</button>
                      </div>
                      <div id="duplicates-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-outliers" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      Outlier Analysis
                      <small>Detect outliers using selected method</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="outlier-method-options" style="display: none;">
                    <label for="outlier-method-select">Detection method:</label>
                    <select id="outlier-method-select" class="sub-select">
                      <option value="iqr" selected>IQR (1.5x multiplier)</option>
                      <option value="zscore">Z-Score (3 threshold)</option>
                      <option value="modified_zscore">Modified Z-Score (3.5 MAD)</option>
                      <option value="other">Other (specify below)</option>
                    </select>
                    <div id="outlier-other-input" style="display: none; margin-top: 8px;">
                      <label for="outlier-custom-input">Custom method:</label>
                      <textarea id="outlier-custom-input" class="sub-textarea" 
                                placeholder="e.g., 'Custom threshold', 'Percentile-based', 'Domain-specific rules'"
                                rows="2"></textarea>
                    </div>
                    
                    <!-- Variable Selection for Outliers -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('outliers')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('outliers')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('outliers')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('outliers')">None</button>
                      </div>
                      <div id="outliers-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-column-names" checked>
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      Standardize Column Names
                      <small>Convert to selected naming convention</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="column-naming-options" style="display: none;">
                    <label for="column-naming-select">Naming convention:</label>
                    <select id="column-naming-select" class="sub-select">
                      <option value="snake_case" selected>snake_case (default)</option>
                      <option value="camelCase">camelCase</option>
                      <option value="PascalCase">PascalCase</option>
                      <option value="lowercase">lowercase</option>
                      <option value="UPPERCASE">UPPERCASE</option>
                      <option value="other">Other (specify below)</option>
                    </select>
                    <div id="column-naming-other-input" style="display: none; margin-top: 8px;">
                      <label for="column-naming-custom-input">Custom convention:</label>
                      <textarea id="column-naming-custom-input" class="sub-textarea" 
                                placeholder="e.g., 'Use dots instead of underscores', 'Keep original case', 'Custom separator'"
                                rows="2"></textarea>
                    </div>
                    
                    <!-- Variable Selection for Column Names -->
                    <div class="variable-selection-subsection">
                      <h6>Select Variables to Analyze:</h6>
                      <div class="variable-selection-controls">
                        <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('column-names')">Select All</button>
                        <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('column-names')">Numeric</button>
                        <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('column-names')">Categorical</button>
                        <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('column-names')">None</button>
                      </div>
                      <div id="column-names-variable-container" class="variable-selection-container">
                        <!-- Variables will be populated here -->
                      </div>
                    </div>
                  </div>
                </div>
                
                <div class="checklist-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="check-other">
                    <span class="checkmark"></span>
                    <div class="checkbox-content">
                      Other Custom Operations
                      <small>Specify your own cleaning needs</small>
                    </div>
                  </label>
                  
                  <div class="sub-options" id="other-options" style="display: none;">
                    <label for="other-operations-input">Describe what you want:</label>
                    <textarea id="other-operations-input" class="sub-textarea" 
                              placeholder="e.g., 'Convert all text to lowercase', 'Remove rows where age < 0', 'Create new column from existing ones'"
                              rows="3"></textarea>
                  </div>
                </div>
              </div>
              
              <button class="start-agent-btn" id="start-agent-btn" onclick="startCleaningAgentSimple()" disabled>
                Select a DataFrame
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Transformation Agent Configuration -->
      <div id="transformation-config" class="agent-config" style="display: none;">

        
        <div class="config-form">
          <div class="form-group">
            <label for="transformation-dataframe-select">Select DataFrame</label>
            <select id="transformation-dataframe-select" onchange="updateTransformationDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
            <div id="transformation-dataframe-info" class="dataframe-info" style="display: none;"></div>
          </div>
          
          <div id="transformation-checklist" class="transformation-checklist" style="display: none;">
            <h4>Select Transformation Operations</h4>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-distribution-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Distribution Analysis
                  <small>Analyze variable distributions and identify transformation needs</small>
                </div>
              </label>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-mathematical-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Mathematical Transformations
                  <small>Apply log, sqrt, power transformations to skewed variables</small>
                </div>
              </label>
              <div class="sub-options" id="math-transformations-options" style="display: none;">
                <label for="math-transformations-select">Transformation type:</label>
                <select id="math-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic (based on skewness)</option>
                  <option value="log">Log transformation</option>
                  <option value="sqrt">Square root</option>
                  <option value="power">Power transformation</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="math-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="math-transformations-custom-input">Custom transformation:</label>
                  <textarea id="math-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'x^2', '1/x', 'exp(x)'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Mathematical Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('math-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('math-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('math-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('math-transformations')">None</button>
                  </div>
                  <div id="math-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-new-variables">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  New Variables
                  <small>Create new variables from combinations of existing ones</small>
                </div>
              </label>
              <div class="sub-options" id="new-variables-options" style="display: none;">
                <label for="new-variables-select">Variable creation type:</label>
                <select id="new-variables-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="arithmetic">Arithmetic combinations</option>
                  <option value="ratio">Ratio variables</option>
                  <option value="interaction">Interaction terms</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="new-variables-other-input" style="display: none; margin-top: 8px;">
                  <label for="new-variables-custom-input">Custom variable creation:</label>
                  <textarea id="new-variables-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'age_group = cut(age, breaks=c(0,25,50,75,100))', 'bmi = weight/height^2'"
                            rows="3"></textarea>
                </div>
                
                <!-- Variable Selection for New Variables -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('new-variables')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('new-variables')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('new-variables')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('new-variables')">None</button>
                  </div>
                  <div id="new-variables-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-categorical-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Categorical Transformations
                  <small>Recode categories, combine levels, create dummy variables</small>
                </div>
              </label>
              <div class="sub-options" id="categorical-transformations-options" style="display: none;">
                <label for="categorical-transformations-select">Transformation type:</label>
                <select id="categorical-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="recode">Recode categories</option>
                  <option value="combine">Combine small categories</option>
                  <option value="dummy">Create dummy variables</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="categorical-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="categorical-transformations-custom-input">Custom categorical transformation:</label>
                  <textarea id="categorical-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Combine categories A,B,C into "Group1"', 'Recode 1,2,3 to "Low","Medium","High"'"
                            rows="3"></textarea>
                </div>
                
                <!-- Variable Selection for Categorical Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('categorical-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('categorical-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('categorical-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('categorical-transformations')">None</button>
                  </div>
                  <div id="categorical-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-datetime-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Date/Time Transformations
                  <small>Extract components, create time variables, handle periods</small>
                </div>
              </label>
              <div class="sub-options" id="datetime-transformations-options" style="display: none;">
                <label for="datetime-transformations-select">Transformation type:</label>
                <select id="datetime-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="components">Extract components (year, month, day)</option>
                  <option value="periods">Create time periods</option>
                  <option value="differences">Calculate time differences</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="datetime-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="datetime-transformations-custom-input">Custom datetime transformation:</label>
                  <textarea id="datetime-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Create quarter variable', 'Extract hour from timestamp'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Date/Time Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('datetime-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('datetime-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('datetime-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('datetime-transformations')">None</button>
                  </div>
                  <div id="datetime-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-merging-combining">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Merging & Combining
                  <small>Merge variables, reshape data structure, combine columns</small>
                </div>
              </label>
              <div class="sub-options" id="merging-combining-options" style="display: none;">
                <label for="merging-combining-select">Operation type:</label>
                <select id="merging-combining-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="combine">Combine text columns</option>
                  <option value="split">Split text columns</option>
                  <option value="reshape">Reshape data (wide/long)</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="merging-combining-other-input" style="display: none; margin-top: 8px;">
                  <label for="merging-combining-custom-input">Custom merging operation:</label>
                  <textarea id="merging-combining-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Combine first_name and last_name into full_name', 'Split address into street, city, zip'"
                            rows="3"></textarea>
                </div>
                
                <!-- Variable Selection for Merging & Combining -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('merging-combining')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('merging-combining')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('merging-combining')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('merging-combining')">None</button>
                  </div>
                  <div id="merging-combining-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-aggregation-grouping">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Aggregation & Grouping
                  <small>Create group summaries, rolling statistics, cumulative measures</small>
                </div>
              </label>
              <div class="sub-options" id="aggregation-grouping-options" style="display: none;">
                <label for="aggregation-grouping-select">Aggregation type:</label>
                <select id="aggregation-grouping-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="summary">Group summaries</option>
                  <option value="rolling">Rolling statistics</option>
                  <option value="cumulative">Cumulative measures</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="aggregation-grouping-other-input" style="display: none; margin-top: 8px;">
                  <label for="aggregation-grouping-custom-input">Custom aggregation:</label>
                  <textarea id="aggregation-grouping-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Calculate mean by department', 'Create 7-day rolling average'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Aggregation & Grouping -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('aggregation-grouping')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('aggregation-grouping')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('aggregation-grouping')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('aggregation-grouping')">None</button>
                  </div>
                  <div id="aggregation-grouping-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-statistical-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Statistical Transformations
                  <small>Z-scores, normalization, ranking, scaling</small>
                </div>
              </label>
              <div class="sub-options" id="statistical-transformations-options" style="display: none;">
                <label for="statistical-transformations-select">Transformation type:</label>
                <select id="statistical-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="zscore">Z-score standardization</option>
                  <option value="minmax">Min-max normalization</option>
                  <option value="robust">Robust scaling</option>
                  <option value="rank">Rank transformation</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="statistical-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="statistical-transformations-custom-input">Custom statistical transformation:</label>
                  <textarea id="statistical-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Apply Box-Cox transformation', 'Use robust scaling with MAD'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Statistical Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('statistical-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('statistical-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('statistical-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('statistical-transformations')">None</button>
                  </div>
                  <div id="statistical-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-text-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Text Transformations
                  <small>Case changes, pattern replacement, text extraction</small>
                </div>
              </label>
              <div class="sub-options" id="text-transformations-options" style="display: none;">
                <label for="text-transformations-select">Transformation type:</label>
                <select id="text-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="case">Case changes</option>
                  <option value="pattern">Pattern replacement</option>
                  <option value="extraction">Text extraction</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="text-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="text-transformations-custom-input">Custom text transformation:</label>
                  <textarea id="text-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Remove special characters', 'Extract first word', 'Replace "NA" with empty string'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Text Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('text-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('text-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('text-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('text-transformations')">None</button>
                  </div>
                  <div id="text-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-spatial-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Spatial Transformations
                  <small>Coordinate systems, distance calculations, spatial joins</small>
                </div>
              </label>
              <div class="sub-options" id="spatial-transformations-options" style="display: none;">
                <label for="spatial-transformations-select">Transformation type:</label>
                <select id="spatial-transformations-select" class="sub-select">
                  <option value="automatic" selected>Automatic suggestions</option>
                  <option value="coordinates">Coordinate transformations</option>
                  <option value="distance">Distance calculations</option>
                  <option value="spatial">Spatial operations</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="spatial-transformations-other-input" style="display: none; margin-top: 8px;">
                  <label for="spatial-transformations-custom-input">Custom spatial transformation:</label>
                  <textarea id="spatial-transformations-custom-input" class="sub-textarea" 
                            placeholder="e.g., 'Convert WGS84 to UTM', 'Calculate distance to nearest point'"
                            rows="2"></textarea>
                </div>
                
                <!-- Variable Selection for Spatial Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('spatial-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('spatial-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('spatial-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('spatial-transformations')">None</button>
                  </div>
                  <div id="spatial-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-custom-transformations">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Custom Transformations
                  <small>Specify your own transformation logic</small>
                </div>
              </label>
              <div class="sub-options" id="custom-transformations-options" style="display: none;">
                <label for="custom-transformations-custom-input">Custom transformation code:</label>
                <textarea id="custom-transformations-custom-input" class="sub-textarea" 
                          placeholder="e.g., 'Create age groups: ifelse(age < 30, "Young", ifelse(age < 60, "Middle", "Senior"))', 'Calculate compound growth rate: (final/initial)^(1/years) - 1'"
                          rows="4"></textarea>
                
                <!-- Variable Selection for Custom Transformations -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Analyze:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('custom-transformations')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('custom-transformations')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('custom-transformations')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('custom-transformations')">None</button>
                  </div>
                  <div id="custom-transformations-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <button class="start-agent-btn" id="start-transformation-btn" onclick="startTransformationAgent()" disabled>
              Start Transformation Agent
            </button>
          </div>
        </div>
      </div>
      
      <!-- Statistical Agent Configuration -->
      <div id="statistical-config" class="agent-config" style="display: none;">

        
        <div class="config-form">
          <div class="form-group">
            <label for="statistical-dataframe-select">Select DataFrame</label>
            <select id="statistical-dataframe-select" onchange="updateStatisticalDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
            <div id="statistical-dataframe-info" class="dataframe-info" style="display: none;"></div>
          </div>
          
          <div id="statistical-checklist" class="statistical-checklist" style="display: none;">
            <h4>Select Statistical Analysis Types</h4>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-basic-statistics">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Basic Statistics & Distributions
                  <small>Summary statistics, normality tests, outlier detection</small>
                </div>
              </label>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-group-comparisons">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Group Comparisons
                  <small>T-tests, Z-tests, ANOVA, non-parametric alternatives</small>
                </div>
              </label>
              <div class="sub-options" id="group-comparisons-options" style="display: none;">
                <label for="group-comparisons-select">Test type:</label>
                <select id="group-comparisons-select" class="sub-select" onchange="updateGroupComparisonGuidance()">
                  <option value="automatic" selected>Automatic (based on data assumptions)</option>
                  <option value="independent_ttest">Independent t-test (2 groups, parametric)</option>
                  <option value="welch_ttest">Welch's t-test (2 groups, unequal variance)</option>
                  <option value="paired_ttest">Paired t-test (before/after, parametric)</option>
                  <option value="one_way_anova">One-way ANOVA (3+ groups, parametric)</option>
                  <option value="mann_whitney">Mann-Whitney U (2 groups, non-parametric)</option>
                  <option value="kruskal_wallis">Kruskal-Wallis (3+ groups, non-parametric)</option>
                  <option value="wilcoxon_signed">Wilcoxon signed-rank (paired, non-parametric)</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <div id="group-comparison-guidance" class="test-guidance" style="margin-top: 8px; padding: 8px; background: #f0f8ff; border-radius: 4px; font-size: 12px; color: #666; display: none;">
                  <span id="guidance-text">Select variables to see test recommendations</span>
                </div>
                <textarea id="group-comparisons-custom-input" class="sub-textarea" 
                          placeholder="Specify custom group comparison test..." 
                          rows="2" style="display: none;"></textarea>
                <div class="variable-selection" style="margin-top: 15px;">
                  <label for="statistical-continuous-var">Continuous Variable:</label>
                  <select id="statistical-continuous-var" class="sub-select" onchange="updateGroupComparisonGuidance()">
                    <option value="">-- Select Variable --</option>
                  </select>
                  
                  <label for="statistical-grouping-var" style="margin-top: 10px;">Grouping Variable:</label>
                  <select id="statistical-grouping-var" class="sub-select" onchange="updateGroupComparisonGuidance()">
                    <option value="">-- Select Variable --</option>
                  </select>
                </div>
              </div>
            </div>
            

            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-categorical-tests">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Categorical Data Tests
                  <small>Chi-squared, Fisher's exact, McNemar's test</small>
                </div>
              </label>
              <div class="sub-options" id="categorical-tests-options" style="display: none;">
                <label for="categorical-tests-select">Test type:</label>
                <select id="categorical-tests-select" class="sub-select">
                  <option value="automatic" selected>Automatic (based on data)</option>
                  <option value="chi_squared_goodness">Chi-squared Goodness-of-Fit</option>
                  <option value="chi_squared_independence">Chi-squared Test of Independence</option>
                  <option value="fishers_exact">Fisher's Exact Test</option>
                  <option value="mcnemar">McNemar's Test</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="categorical-tests-custom-input" class="sub-textarea" 
                          placeholder="Specify custom categorical test..." 
                          rows="2" style="display: none;"></textarea>
                <div class="variable-selection" style="margin-top: 15px;">
                  <label for="categorical-var1">Categorical Variable 1:</label>
                  <select id="categorical-var1" class="sub-select">
                    <option value="">-- Select Variable --</option>
                  </select>
                  
                  <label for="categorical-var2" style="margin-top: 10px;">Categorical Variable 2:</label>
                  <select id="categorical-var2" class="sub-select">
                    <option value="">-- Select Variable --</option>
                  </select>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-before-after-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Before/After Analysis
                  <small>Paired t-tests, repeated measures ANOVA</small>
                </div>
              </label>
              <div class="sub-options" id="before-after-options" style="display: none;">
                <label for="before-after-select">Analysis type:</label>
                <select id="before-after-select" class="sub-select">
                  <option value="automatic" selected>Automatic (based on data)</option>
                  <option value="paired_ttest">Paired t-test</option>
                  <option value="repeated_anova">Repeated measures ANOVA</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="before-after-custom-input" class="sub-textarea" 
                          placeholder="Specify custom before/after analysis..." 
                          rows="2" style="display: none;"></textarea>
                <div class="variable-selection" style="margin-top: 15px;">
                  <label for="statistical-before-var">Before Variable:</label>
                  <select id="statistical-before-var" class="sub-select">
                    <option value="">-- Select Variable --</option>
                  </select>
                  
                  <label for="statistical-after-var" style="margin-top: 10px;">After Variable:</label>
                  <select id="statistical-after-var" class="sub-select">
                    <option value="">-- Select Variable --</option>
                  </select>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-effect-size-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Effect Size Analysis
                  <small>Cohen's d, eta-squared, odds ratios, confidence intervals</small>
                </div>
              </label>
              <div class="sub-options" id="effect-size-options" style="display: none;">
                <label for="effect-size-select">Effect size type:</label>
                <select id="effect-size-select" class="sub-select">
                  <option value="automatic" selected>Automatic (based on test type)</option>
                  <option value="cohens_d">Cohen's d (mean differences)</option>
                  <option value="eta_squared">Eta-squared (ANOVA)</option>
                  <option value="odds_ratio">Odds ratios (categorical)</option>
                  <option value="confidence_intervals">Confidence intervals</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="effect-size-custom-input" class="sub-textarea" 
                          placeholder="Specify custom effect size calculation..." 
                          rows="2" style="display: none;"></textarea>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-power-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Power Analysis
                  <small>Sample size calculations, effect size estimation</small>
                </div>
              </label>
              <div class="sub-options" id="power-analysis-options" style="display: none;">
                <label for="power-analysis-select">Power level:</label>
                <select id="power-analysis-select" class="sub-select">
                  <option value="0.8" selected>80% (Standard)</option>
                  <option value="0.9">90% (High)</option>
                  <option value="0.95">95% (Very High)</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="power-analysis-custom-input" class="sub-textarea" 
                          placeholder="Specify custom power level (e.g., 0.85, 0.99)..." 
                          rows="2" style="display: none;"></textarea>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-multiple-testing-correction">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Multiple Testing Correction
                  <small>Bonferroni, FDR, Holm's method</small>
                </div>
              </label>
              <div class="sub-options" id="multiple-testing-options" style="display: none;">
                <label for="multiple-testing-select">Correction method:</label>
                <select id="multiple-testing-select" class="sub-select">
                  <option value="bonferroni" selected>Bonferroni (Conservative)</option>
                  <option value="fdr">False Discovery Rate (Less Conservative)</option>
                  <option value="holm">Holm's Method (Step-down)</option>
                  <option value="other">Other (specify below)</option>
                </select>
                <textarea id="multiple-testing-custom-input" class="sub-textarea" 
                          placeholder="Specify custom multiple testing correction method..." 
                          rows="2" style="display: none;"></textarea>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-custom-statistical-analysis">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Custom Statistical Analysis
                  <small>Specify your own statistical analysis requirements</small>
                </div>
              </label>
              <div class="sub-options" id="custom-statistical-analysis-options" style="display: none;">
                <label for="custom-statistical-analysis-input">Custom analysis description:</label>
                <textarea id="custom-statistical-analysis-input" class="sub-textarea" 
                          placeholder="e.g., 'Perform Bayesian analysis with MCMC', 'Run multilevel mixed-effects model', 'Custom survival analysis with time-varying covariates'"
                          rows="4"></textarea>
              </div>
            </div>
            
            <button class="start-agent-btn" id="start-statistical-btn" onclick="startStatisticalAgent()" disabled>
              Start Statistical Analysis Agent
            </button>
          </div>
        </div>
      </div>
      
      <!-- Modeling Agent Configuration -->
      <div id="modeling-config" class="agent-config" style="display: none;">

        
        <div class="config-content">
          <div class="config-section">
            <label for="modeling-dataframe-select">Select DataFrame</label>
            <select id="modeling-dataframe-select" onchange="updateModelingDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
          </div>
          

          
          <div class="config-section" id="target-variable-section" style="display: none;">
            <label for="modeling-target-variable">Target Variable</label>
            <select id="modeling-target-variable" onchange="updateAlgorithmOptions()">
              <option value="">-- Select Target Variable --</option>
            </select>
          </div>
          
          <div id="modeling-checklist" class="modeling-checklist" style="display: none;">
            <h4>Select Machine Learning Algorithms</h4>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-dimensionality-reduction">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Dimensionality Reduction
                  <small>PCA, t-SNE, UMAP for feature reduction</small>
                </div>
              </label>
              <div class="sub-options" id="dimensionality-reduction-options" style="display: none;">
                <label for="dimensionality-reduction-select">Method:</label>
                <select id="dimensionality-reduction-select" class="sub-select">
                  <option value="automatic" selected>Automatic (best method)</option>
                  <option value="pca">Principal Component Analysis (PCA)</option>
                  <option value="tsne">t-SNE (t-Distributed Stochastic Neighbor Embedding)</option>
                  <option value="umap">UMAP (Uniform Manifold Approximation and Projection)</option>
                </select>
                
                <!-- Variable Selection for Dimensionality Reduction -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('dimensionality-reduction')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('dimensionality-reduction')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('dimensionality-reduction')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('dimensionality-reduction')">None</button>
                  </div>
                  <div id="dimensionality-reduction-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group" id="linear-regression-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-linear-regression">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Linear Regression
                  <small>Linear regression with interpretability</small>
                </div>
              </label>
              <div class="sub-options" id="linear-regression-options" style="display: none;">
                <!-- Variable Selection for Linear Regression -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('linear-regression')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('linear-regression')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('linear-regression')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('linear-regression')">None</button>
                  </div>
                  <div id="linear-regression-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group" id="logistic-regression-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-logistic-regression">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Logistic Regression
                  <small>Binary classification with interpretability</small>
                </div>
              </label>
              <div class="sub-options" id="logistic-regression-options" style="display: none;">
                <!-- Variable Selection for Logistic Regression -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('logistic-regression')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('logistic-regression')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('logistic-regression')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('logistic-regression')">None</button>
                  </div>
                  <div id="logistic-regression-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group" id="multinomial-regression-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-multinomial-regression">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Multinomial Regression
                  <small>Multi-class classification with interpretability</small>
                </div>
              </label>
              <div class="sub-options" id="multinomial-regression-options" style="display: none;">
                <!-- Variable Selection for Multinomial Regression -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('multinomial-regression')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('multinomial-regression')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('multinomial-regression')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('multinomial-regression')">None</button>
                  </div>
                  <div id="multinomial-regression-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-random-forest">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Random Forest
                  <small>Ensemble method with feature importance</small>
                </div>
              </label>
              <div class="sub-options" id="random-forest-options" style="display: none;">
                <!-- Variable Selection for Random Forest -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('random-forest')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('random-forest')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('random-forest')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('random-forest')">None</button>
                  </div>
                  <div id="random-forest-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-xgboost">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  XGBoost
                  <small>Gradient boosting with interpretability</small>
                </div>
              </label>
              <div class="sub-options" id="xgboost-options" style="display: none;">
                <!-- Variable Selection for XGBoost -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('xgboost')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('xgboost')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('xgboost')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('xgboost')">None</button>
                  </div>
                  <div id="xgboost-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-feature-engineering">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Feature Engineering
                  <small>Create interaction terms and polynomial features</small>
                </div>
              </label>
              <div class="sub-options" id="feature-engineering-options" style="display: none;">
                <!-- Variable Selection for Feature Engineering -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('feature-engineering')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('feature-engineering')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('feature-engineering')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('feature-engineering')">None</button>
                  </div>
                  <div id="feature-engineering-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-model-interpretability" checked>
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Model Interpretability
                  <small>SHAP values, feature importance, partial dependence plots</small>
                </div>
              </label>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-claude-plots" checked>
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Claude-Powered Plots
                  <small>AI-suggested visualizations based on results</small>
                </div>
              </label>
            </div>
            
            <div class="checklist-group">
              <label class="checkbox-item">
                <input type="checkbox" id="check-custom-modeling">
                <span class="checkmark"></span>
                <div class="checkbox-content">
                  Custom Modeling
                  <small>Specify your own modeling requirements and custom algorithms</small>
                </div>
              </label>
              <div class="sub-options" id="custom-modeling-options" style="display: none;">
                <label for="custom-modeling-input">Custom modeling description:</label>
                <textarea id="custom-modeling-input" class="sub-textarea" 
                          placeholder="e.g., 'Train custom neural network with specific architecture', 'Use ensemble of SVMs with custom kernels', 'Implement domain-specific algorithm'"
                          rows="4"></textarea>
                
                <!-- Variable Selection for Custom Modeling -->
                <div class="variable-selection-subsection">
                  <h6>Select Variables to Include:</h6>
                  <div class="variable-selection-controls">
                    <button type="button" class="btn-small" onclick="selectAllVariablesForOperation('custom-modeling')">Select All</button>
                    <button type="button" class="btn-small" onclick="selectNumericVariablesForOperation('custom-modeling')">Numeric</button>
                    <button type="button" class="btn-small" onclick="selectCategoricalVariablesForOperation('custom-modeling')">Categorical</button>
                    <button type="button" class="btn-small" onclick="selectNoneVariablesForOperation('custom-modeling')">None</button>
                  </div>
                  <div id="custom-modeling-variable-container" class="variable-selection-container">
                    <!-- Variables will be populated here -->
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <button class="start-agent-btn" id="start-modeling-btn" onclick="startModelingAgent()" disabled>
            Start Modeling Agent
          </button>
        </div>
      </div>
      
      <!-- Visualization Agent Configuration -->
      <div id="visualization-config" class="agent-config" style="display: none;">
        <div class="config-content">
          <div class="config-section">
            <label for="viz-dataframe-select">Select DataFrame</label>
            <select id="viz-dataframe-select" onchange="updateVizDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
            <div id="viz-dataframe-info" class="dataframe-info" style="display: none;"></div>
          </div>
          
                       <div id="viz-checklist" class="viz-checklist" style="display: none;">
               <h4>Select Visualization Categories</h4>
               <p>Choose the types of visualizations you want to generate. Each category will create appropriate plots for your data.</p>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-distributions" onchange="toggleVizCategory('distributions')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     Distributions
                     <small>Histograms, density plots, and distribution analysis</small>
                   </div>
                 </label>
                 <div id="viz-distributions-options" class="sub-options" style="display: none;">
                   <div id="viz-dist-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('distributions')">
                       Add Plot
                     </button>
                   </div>
                 </div>
               </div>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-comparisons" onchange="toggleVizCategory('comparisons')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     Comparisons
                     <small>Box plots, violin plots, and group comparisons</small>
                   </div>
                 </label>
                 <div id="viz-comparisons-options" class="sub-options" style="display: none;">
                   <div id="viz-comp-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('comparisons')">
                       Add Plot
                     </button>
                   </div>
                 </div>
               </div>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-relationships" onchange="toggleVizCategory('relationships')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     Relationships
                     <small>Scatter plots, line plots, and correlation analysis</small>
                   </div>
                 </label>
                 <div id="viz-relationships-options" class="sub-options" style="display: none;">
                   <div id="viz-rel-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('relationships')">
                       Add Plot
                     </button>
                   </div>
                 </div>
               </div>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-categorical" onchange="toggleVizCategory('categorical')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     Categorical
                     <small>Bar charts, pie charts, and frequency analysis</small>
                   </div>
                 </label>
                 <div id="viz-categorical-options" class="sub-options" style="display: none;">
                   <div id="viz-cat-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('categorical')">
                       Add Plot
                     </button>
                   </div>
                 </div>
               </div>

               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-time-series" onchange="toggleVizCategory('time-series')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     Time Series
                     <small>Line plots, trend analysis, and temporal patterns</small>
                   </div>
                 </label>
                 <div id="viz-time-series-options" class="sub-options" style="display: none;">
                   <div id="viz-ts-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('timeseries')">
                       Add Plot
                     </button>
                   </div>
                 </div>
               </div>
               
               <div class="checklist-group">
                 <label class="checkbox-item">
                   <input type="checkbox" id="viz-check-statistical" onchange="toggleVizCategory('statistical')">
                   <span class="checkmark"></span>
                   <div class="checkbox-content">
                     Statistical Plots
                     <small>Q-Q plots, residual plots, and statistical diagnostics</small>
                   </div>
                 </label>
                 <div id="viz-statistical-options" class="sub-options" style="display: none;">
                   <div id="viz-stat-plot-configs" class="plot-configs">
                     <!-- Individual plot configurations will be added here -->
                   </div>
                   <div class="add-plot-section">
                     <button type="button" class="add-plot-btn" onclick="addVizPlot('statistical')">
                       Add Plot
                     </button>
                   </div>
                 </div>
               </div>
             </div>
          
          
          <button class="start-agent-btn" id="start-viz-btn" onclick="startVisualizationAgent()" disabled>
            Start Visualization Agent
          </button>
        </div>
      </div>
      
      <!-- Guide Tab -->
      <div id="guide-tab" class="tab-content">
        <div class="guide-container">
          <div class="guide-section">
            <h3>Getting Started</h3>
            <div class="guide-card">
              <h4>Be Specific</h4>
              <ul>
                <li>"Create a function to calculate mean by group"</li>
                <li>"help me with data"</li>
                <li>"Debug this ggplot error: object not found"</li>
                <li>"it's not working"</li>
              </ul>
            </div>
          </div>
          
          <div class="guide-section">
            <h3>Key Features</h3>
            <div class="guide-card">
              <h4>Smart Context Capture</h4>
              <p>Automatically captures your entire R environment - data frames, functions, variables, plots, and active code.</p>
            </div>
            <div class="guide-card">
              <h4>Real-time Streaming</h4>
              <p>Watch AI responses stream in real-time. No waiting for complete responses.</p>
            </div>
            <div class="guide-card">
              <h4>Code Insertion</h4>
              <p>Click "Insert at Cursor" to add code directly into your R scripts. No copy-paste needed.</p>
            </div>
            <div class="guide-card">
              <h4>Error Debugging</h4>
              <p>Click "Debug Last Error" for instant analysis and step-by-step fixes.</p>
            </div>
            <div class="guide-card">
              <h4>Plot Analysis</h4>
              <p>Click "Analyze Last Plot" for statistical insights and improvement suggestions.</p>
            </div>
            <div class="guide-card">
              <h4>Data Explorer</h4>
              <p>Browse and explore your R objects in the Data Explorer tab. View data frames, matrices, vectors, and lists with sorting and pagination.</p>
            </div>
          </div>
          
          <div class="guide-section">
            <h3>AI Agents</h3>
            
            <div class="guide-card">
              <h4>What are Agents?</h4>
              <p>Specialized AI workflows that guide you through complete data analysis tasks step-by-step.</p>
            </div>
            
            <div class="guide-card">
              <h4>Data Cleaning Agent</h4>
              <ul>
                <li>Automatically detects missing values, outliers, duplicates</li>
                <li>Provides intelligent imputation suggestions</li>
                <li>Standardizes column names and data types</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>Transformation Agent</h4>
              <ul>
                <li>Smart mathematical transformations (log, sqrt)</li>
                <li>Automatic new variable creation</li>
                <li>Data reshaping and categorical encoding</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>Statistical Analysis Agent</h4>
              <ul>
                <li>Intelligent test selection (t-test, ANOVA, chi-square)</li>
                <li>Effect size calculations (Cohen's d, eta-squared)</li>
                <li>Distribution analysis with assumption checking</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>Modeling Agent</h4>
              <ul>
                <li>Smart algorithm recommendations by target type</li>
                <li>Automatic feature engineering</li>
                <li>Model comparison and interpretation</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>Visualization Agent</h4>
              <ul>
                <li>Intelligent plot type recommendations</li>
                <li>Automatic statistical analysis of plots</li>
                <li>Smart variable filtering and validation</li>
              </ul>
            </div>
            
            <div class="guide-card">
              <h4>Getting Started with Agents</h4>
              <ol>
                <li>Click the <strong>Agents</strong> tab</li>
                <li>Select your data frame</li>
                <li>Choose your analysis type</li>
                <li>Follow the guided workflow</li>
                <li>Get AI analysis + executable code</li>
              </ol>
            </div>
          </div>
          
          <div class="guide-section">
            <h3>Performance Tips</h3>
            <div class="guide-card">
              <h4>Keep Environment Clean</h4>
              <p>This will save tokens and cost:</p>
              <ul>
                <li>Remove unused variables: <code>rm(unused_var)</code></li>
                <li>Clear large objects: <code>rm(large_dataframe)</code></li>
                <li>Restart R session: "Session > Restart R"</li>
                <li>Use <code>rm(list = ls())</code> for fresh start</li>
              </ul>
            </div>
          </div>
          

          
          <div class="guide-section">
            <h3>Troubleshooting</h3>
            <div class="guide-card">
              <h4>Slow Responses?</h4>
              <ul>
                <li>Your environment might be too large</li>
                <li>Try <code>rm(list = ls())</code> to clear workspace</li>
                <li>Restart R session for fresh start</li>
              </ul>
            </div>
            <div class="guide-card">
              <h4>Connection Issues?</h4>
              <ul>
                <li>Check your internet connection</li>
                <li>Verify your access code is valid</li>
                <li>Try refreshing the page</li>
                <li>Restart the addin if needed</li>
              </ul>
            </div>
            <div class="guide-card">
              <h4>Need Anything?</h4>
              <p>Contact us at <a href="mailto:founders@rgentai.com">founders@rgentai.com</a></p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Data Explorer Tab -->
      <div id="explorer-tab" class="tab-content">
        <div class="explorer-container">
          <!-- Top Action Bar -->
          <div class="explorer-action-bar">
            <div class="explorer-title-section">
              <div class="custom-dropdown" id="explorer-dataframe-select-wrapper" style="position: relative; min-width: 200px;">
                <button id="explorer-dataframe-select-button" class="custom-dropdown-button" style="padding: 8px 16px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-card); font-size: 14px; width: 100%; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                  <span id="explorer-dataframe-select-text">Select an object...</span>
                  <span class="dropdown-arrow" style="margin-left: 8px; display: inline-block;"></span>
                </button>
                <div id="explorer-dataframe-select-dropdown" class="custom-dropdown-menu" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: var(--bg-card) !important; background-color: var(--bg-card) !important; border: 1px solid var(--border-color); border-radius: 4px; margin-top: 4px; max-height: 400px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 6px rgba(0,0,0,0.1); opacity: 1 !important; backdrop-filter: none !important; -webkit-backdrop-filter: none !important; will-change: auto;">
                  <!-- Options will be populated here -->
                </div>
              </div>
              <span id="explorer-df-dims" class="dims-text" style="margin-left: 15px;"></span>
            </div>
            <div class="explorer-actions" style="display: none; gap: 8px; align-items: center;">
              <button id="prev-page-btn" onclick="explorerPreviousPage()" class="action-btn" style="padding: 6px 12px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-card); color: var(--text-primary) !important; cursor: pointer; font-size: 12px; font-weight: 500; width: 120px; height: 32px; box-sizing: border-box; display: flex; align-items: center; justify-content: center;" disabled> Previous 100</button>
              <button id="next-page-btn" onclick="explorerNextPage()" class="action-btn" style="padding: 6px 12px; border-radius: 4px; border: 1px solid var(--border-color); background: var(--bg-card); color: var(--text-primary) !important; cursor: pointer; font-size: 12px; font-weight: 500; width: 120px; height: 32px; box-sizing: border-box; display: flex; align-items: center; justify-content: center;" disabled>Next 100 </button>
            </div>
          </div>
          
          <!-- Filter Bar -->
          <div id="explorer-filter-bar" class="explorer-filter-bar" style="display: none;">
            <div id="explorer-filters-container"></div>
          </div>
          
          <!-- Main Grid Area -->
          <div class="explorer-grid-container">
            <!-- Summary Panel (Left) -->
            <div id="explorer-summary-panel" class="explorer-summary-panel" style="display: none;">
              <div class="summary-header">
                <input type="text" id="summary-search" placeholder="Search columns..." oninput="filterSummaryColumns()" style="flex: 1; padding: 6px; border: 1px solid var(--border-color); border-radius: 4px; display: none;">
              </div>
              <div id="summary-columns-list" class="summary-columns-list"></div>
            </div>
            
            <!-- Data Grid -->
            <div class="explorer-grid-wrapper" style="display: none;">
              <div id="explorer-grid" class="explorer-grid">
                <div class="grid-header">
                  <div class="row-header-corner" id="row-header-corner" style="width: 60px; min-width: 60px; max-width: 60px; flex-shrink: 0; border-right: 2px solid var(--border-color); border-bottom: 2px solid var(--border-color); height: 35px; box-sizing: border-box; position: sticky; left: 0; z-index: 101;"></div>
                  <div id="grid-column-headers" class="grid-column-headers"></div>
                </div>
                <div class="grid-body">
                  <div id="grid-row-headers" class="grid-row-headers"></div>
                  <div id="grid-data-cells" class="grid-data-cells"></div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Status Bar -->
          <div class="explorer-status-bar">
            <span id="explorer-status-text"></span>
          </div>
        </div>
      </div>
      
      <!-- Filter Modal -->
      <div id="filter-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
          <div class="modal-header">
            <h3>Add Filter</h3>
            <button onclick="closeFilterModal()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-secondary);">&times;</button>
          </div>
          <div class="modal-body">
            <div style="margin-bottom: 15px;">
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">Column:</label>
              <select id="filter-column-select" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-card); color: var(--text-primary);">
                <option value="">Select a column...</option>
              </select>
            </div>
            <div style="margin-bottom: 15px;">
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter Type:</label>
              <select id="filter-type-select" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-card); color: var(--text-primary);">
                <option value="">Select filter type...</option>
              </select>
            </div>
            <div id="filter-value-container" style="margin-bottom: 15px; display: none;">
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">Value:</label>
              <input type="text" id="filter-value-input" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-card); color: var(--text-primary); box-sizing: border-box;">
              <div id="filter-between-container" style="display: none; margin-top: 10px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 500;">To:</label>
                <input type="text" id="filter-value-input-2" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-card); color: var(--text-primary); box-sizing: border-box;">
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button onclick="closeFilterModal()" class="btn-secondary" style="margin-right: 10px;">Cancel</button>
            <button onclick="applyFilter()" class="btn-primary">Apply Filter</button>
          </div>
        </div>
      </div>
    </div>
    

    <div id="agent-config-modal" class="modal" style="display: none;">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Configure Data Cleaning Agent</h3>
          <span class="modal-close" onclick="closeAgentConfigModal()">&times;</span>
        </div>
        
        <div class="modal-body">
          <div class="config-section">
            <label for="dataframe-select">Select DataFrame *</label>
            <select id="dataframe-select" onchange="updateDataFrameInfo()">
              <option value="">-- Choose a DataFrame --</option>
            </select>
            <div id="dataframe-info" class="dataframe-info" style="display: none;"></div>
          </div>
          
          <div class="config-section">
            <label>Handle Missing Values (NAs)</label>
            <div class="radio-group">
              <label class="radio-option">
                <input type="radio" name="na-handling" value="dont" checked>
                <span>Don't touch missing values</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="na-handling" value="mean">
                <span>Replace with mean (numeric columns)</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="na-handling" value="median">
                <span>Replace with median (numeric columns)</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="na-handling" value="mode">
                <span>Replace with mode (text columns)</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="na-handling" value="remove">
                <span>Remove rows with missing values</span>
              </label>
            </div>
          </div>
          
          <div class="config-section">
            <h4> Cleaning Workflow</h4>
            <ol class="workflow-steps">
              <li>Examine data structure and types</li>
              <li>Identify missing values and patterns</li>
              <li>Handle missing values using selected method</li>
              <li>Fix data type conversions</li>
              <li>Remove outliers using IQR method</li>
            </ol>
          </div>
        </div>
        
        <div class="modal-footer">
          <div class="modal-actions">
            <button class="btn-secondary" onclick="closeAgentConfigModal()">Cancel</button>
            <button class="btn-primary" id="start-cleaning-btn" onclick="startCleaningAgent()" disabled>
              Start Cleaning Agent
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Guide Modal -->
    <div id="guide-modal" class="modal" style="display: none; z-index: 10000;">
      <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
          <h3>Guide & Help</h3>
          <span class="modal-close" onclick="closeGuideModal()">&times;</span>
        </div>
        <div class="modal-body">
          <div class="guide-container">
            <div class="guide-section">
              <h3>Getting Started</h3>
              <div class="guide-card">
                <h4>Be Specific</h4>
                <ul>
                  <li>"Create a function to calculate mean by group"</li>
                  <li>"help me with data"</li>
                  <li>"Debug this ggplot error: object not found"</li>
                  <li>"it's not working"</li>
                </ul>
              </div>
            </div>
            
            <div class="guide-section">
              <h3>Key Features</h3>
              <div class="guide-card">
                <h4>Smart Context Capture</h4>
                <p>Automatically captures your entire R environment - data frames, functions, variables, plots, and active code.</p>
              </div>
              <div class="guide-card">
                <h4>Real-time Streaming</h4>
                <p>Watch AI responses stream in real-time. No waiting for complete responses.</p>
              </div>
              <div class="guide-card">
                <h4>Code Insertion</h4>
                <p>Click "Insert at Cursor" to add code directly into your R scripts. No copy-paste needed.</p>
              </div>
              <div class="guide-card">
                <h4>Error Debugging</h4>
                <p>Click "Debug Last Error" for instant analysis and step-by-step fixes.</p>
              </div>
              <div class="guide-card">
                <h4>Plot Analysis</h4>
                <p>Click "Analyze Last Plot" for statistical insights and improvement suggestions.</p>
              </div>
              <div class="guide-card">
                <h4>Data Explorer</h4>
                <p>Browse and explore your R objects in the Data Explorer tab. View data frames, matrices, vectors, and lists with sorting and pagination.</p>
              </div>
            </div>
            
            <div class="guide-section">
              <h3>AI Agents</h3>
              
              <div class="guide-card">
                <h4>What are Agents?</h4>
                <p>Specialized AI workflows that guide you through complete data analysis tasks step-by-step.</p>
              </div>
              
              <div class="guide-card">
                <h4>Data Cleaning Agent</h4>
                <ul>
                  <li>Automatically detects missing values, outliers, duplicates</li>
                  <li>Provides intelligent imputation suggestions</li>
                  <li>Standardizes column names and data types</li>
                </ul>
              </div>
              
              <div class="guide-card">
                <h4>Transformation Agent</h4>
                <ul>
                  <li>Smart mathematical transformations (log, sqrt)</li>
                  <li>Automatic new variable creation</li>
                  <li>Data reshaping and categorical encoding</li>
                </ul>
              </div>
              
              <div class="guide-card">
                <h4>Statistical Analysis Agent</h4>
                <ul>
                  <li>Intelligent test selection (t-test, ANOVA, chi-square)</li>
                  <li>Effect size calculations (Cohen's d, eta-squared)</li>
                  <li>Distribution analysis with assumption checking</li>
                </ul>
              </div>
              
              <div class="guide-card">
                <h4>Modeling Agent</h4>
                <ul>
                  <li>Smart algorithm recommendations by target type</li>
                  <li>Automatic feature engineering</li>
                  <li>Model comparison and interpretation</li>
                </ul>
              </div>
              
              <div class="guide-card">
                <h4>Visualization Agent</h4>
                <ul>
                  <li>Intelligent plot type recommendations</li>
                  <li>Automatic statistical analysis of plots</li>
                  <li>Smart variable filtering and validation</li>
                </ul>
              </div>
              
              <div class="guide-card">
                <h4>Getting Started with Agents</h4>
                <ol>
                  <li>Click the <strong>Agents</strong> tab</li>
                  <li>Select your data frame</li>
                  <li>Choose your analysis type</li>
                  <li>Follow the guided workflow</li>
                  <li>Get AI analysis + executable code</li>
                </ol>
              </div>
            </div>
            
            <div class="guide-section">
              <h3>Performance Tips</h3>
              <div class="guide-card">
                <h4>Keep Environment Clean</h4>
                <p>This will save tokens and cost:</p>
                <ul>
                  <li>Remove unused variables: <code>rm(unused_var)</code></li>
                  <li>Clear large objects: <code>rm(large_dataframe)</code></li>
                  <li>Restart R session: "Session > Restart R"</li>
                  <li>Use <code>rm(list = ls())</code> for fresh start</li>
                </ul>
              </div>
            </div>
            
            <div class="guide-section">
              <h3>Troubleshooting</h3>
              <div class="guide-card">
                <h4>Slow Responses?</h4>
                <ul>
                  <li>Your environment might be too large</li>
                  <li>Try <code>rm(list = ls())</code> to clear workspace</li>
                  <li>Restart R session for fresh start</li>
                </ul>
              </div>
              <div class="guide-card">
                <h4>Connection Issues?</h4>
                <ul>
                  <li>Check your internet connection</li>
                  <li>Verify your access code is valid</li>
                  <li>Try refreshing the page</li>
                  <li>Restart the addin if needed</li>
                </ul>
              </div>
              <div class="guide-card">
                <h4>Need Anything?</h4>
                <p>Contact us at <a href="mailto:founders@rgentai.com">founders@rgentai.com</a></p>
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn-primary" onclick="closeGuideModal()">Close</button>
        </div>
      </div>
    </div>
    
    <script>
      let ws = null;
      let isConnected = false;
      let isAccessValid = false;
      let accessCode = '';
      let currentStreamingMessage = null;
      let streamingTimeout = null;
      let currentAgentWorkflow = null;
      let agentResults = [];
      let agentCodes = [];
      let currentStepCode = null;
      
      // Stop response state management
      let isAIResponding = false;
      let currentRequestId = null;
      let pendingTimeouts = [];
      let operationStopped = false;
      
      // Store last output for context in follow-up messages
      let lastCodeOutput = null;
      
      // Context extraction - full output up to ~1500 tokens (~4500 chars), smart extraction above
      function extractSmartContext(output, maxChars = 4500) {
        if (!output) return null;
        
        // Remove PLOT_DATA base64 strings (always)
        let cleaned = output.replace(/PLOT_DATA:\s*[A-Za-z0-9+/=]+\s*/g, '[plot]');
        cleaned = cleaned.replace(/ANALYZE_PLOT:TRUE\s*/g, '');
        cleaned = cleaned.replace(/\n{3,}/g, '\n\n').trim();
        
        // If under limit, return full cleaned output
        if (cleaned.length <= maxChars) {
          return cleaned;
        }
        
        // Over limit: smart extraction - keep everything except numbered data rows
        const lines = cleaned.split('\n');
        const keptLines = [];
        let skippedDataRows = 0;
        
        // Pattern for numbered data rows (like "1  Player_1  QB  49...")
        const dataRowPattern = /^\s*\d+\s+\S+/;
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          
          // Always keep first 10 and last 10 lines
          if (i < 10 || i >= lines.length - 10) {
            keptLines.push(line);
            continue;
          }
          
          // Skip numbered data rows in the middle
          if (dataRowPattern.test(line)) {
            skippedDataRows++;
            continue;
          }
          
          // Keep everything else
          keptLines.push(line);
        }
        
        let result = keptLines.join('\n');
        
        // Add data row summary if we skipped any
        if (skippedDataRows > 0) {
          result = result.replace(/\n{2,}/, `\n[${skippedDataRows} data rows omitted]\n`);
        }
        
        // Final length limit
        if (result.length > maxChars) {
          result = result.substring(0, maxChars) + '\n[truncated]';
        }
        
        return result || null;
      }
      
      // Access validation
      window.validateAccess = async function(isAutoLogin = false) {
        const code = document.getElementById('access-code').value.trim();
        if (!code) {
          showAccessStatus('Please enter an access code', 'error');
          return;
        }
        
        if (!isAutoLogin) {
          showAccessStatus('Validating access...', 'info');
        }
        
        try {
          const response = await fetch('https://rgent.onrender.com/validate', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ access_code: code })
          });
          
          const data = await response.json();
          
          if (response.ok && data.valid) {
            isAccessValid = true;
            accessCode = code;
            
            if (isAutoLogin) {
              showAccessStatus(' Access code found! Automatically logged in.', 'success');
            } else {
              showAccessStatus('Access validated successfully!', 'success');
            }
            
            document.getElementById('access-section').style.display = 'none';
            document.getElementById('main-interface').style.display = 'block';
            
            // Ensure explorer dropdown is hidden when main interface is first shown
            const explorerDropdown = document.getElementById('explorer-dataframe-select-dropdown');
            if (explorerDropdown) {
              console.log(' Initial display: Hiding explorer dropdown');
              explorerDropdown.style.display = 'none';
              explorerDropdown.style.visibility = 'hidden';
              explorerDropdown.style.opacity = '0';
              explorerDropdown.style.pointerEvents = 'none';
            }
            
            // Ensure we start on chat tab
            const chatTab = document.getElementById('chat-tab');
            if (chatTab && !chatTab.classList.contains('active')) {
              switchTab('chat');
            }
            
            // WebSocket should already be connected (from page load), but connect if not
            if (!isConnected && (!ws || ws.readyState !== WebSocket.OPEN)) {
              connectWebSocket();
            }
            
            // Enable UI elements now that access is validated
            if (document.getElementById("user-input")) {
              document.getElementById("user-input").disabled = false;
            }
            if (document.getElementById("send-button")) {
              document.getElementById("send-button").disabled = false;
            }
            if (document.getElementById("new-conversation-button")) {
              document.getElementById("new-conversation-button").disabled = false;
            }
            if (document.getElementById("debug-error-button")) {
              document.getElementById("debug-error-button").disabled = false;
            }
            if (document.getElementById("analyze-plot-button")) {
              document.getElementById("analyze-plot-button").disabled = false;
            }
            
            // Request objects first, then show personalized welcome message
            if (isConnected && ws && ws.readyState === WebSocket.OPEN) {
              window.showWelcomeMessage = true;
              window.welcomeMessageShown = false;
              // Request objects to personalize welcome message
              ws.send(JSON.stringify({
                action: "get_objects"
              }));
              // Fallback: if objects don't arrive quickly, show default message
              setTimeout(() => {
                if (window.showWelcomeMessage && !window.welcomeMessageShown) {
                  window.welcomeMessageShown = true;
                  typeMessage(" Hi! I'm your RStudio AI assistant. I can help you write code, analyze data, create visualizations, debug errors, and more. What would you like to work on?", "ai", 15);
                  window.showWelcomeMessage = false;
                }
              }, 1000);
            }
            
            // Send access code to R backend once WebSocket is connected
            // Note: We don't need to do this here because if WebSocket was already open,
            // the R backend would have sent access_code_loaded which we handle separately
            // Only send if WebSocket wasn't already connected
            if (!isConnected) {
              // WebSocket will be connected via connectWebSocket(), and R backend will send access_code_loaded
              // So we don't need to send set_access_code here
            } else if (ws && ws.readyState === WebSocket.OPEN) {
              // WebSocket was already connected, send access code now
              ws.send(JSON.stringify({
                action: 'set_access_code',
                access_code: code
              }));
            }
          } else {
            // Show the specific error message from the backend
            const errorMessage = data.detail || 'Invalid access code';
            showAccessStatus(errorMessage, 'error');
          }
        } catch (error) {
          showAccessStatus('Failed to validate access code', 'error');
        }
      }
      
      function showAccessStatus(message, type) {
        const statusDiv = document.getElementById('access-status');
        statusDiv.textContent = message;
        statusDiv.className = 'status ' + type;
        statusDiv.style.display = 'block';
      }
      
      // Tab switching - REMOVED DUPLICATE FUNCTION
      // The working switchTab function is defined later in the file
      
      // Load usage statistics
      async function loadStats() {
        if (!isAccessValid) return;

        try {
          const response = await fetch(`https://rgent.onrender.com/usage?access_code=${accessCode}`);
          const data = await response.json();

          console.log('Stats response:', data);

          if (response.ok) {
            // Get plan type and basic stats
            const planType = data.plan_type || 'free_trial';
            const monthRequests = data.month_requests || 0;
            const requestsRemaining = data.requests_remaining || 0;
            
            // Get subscription information
            const subscriptionStatus = data.subscription_status || 'inactive';
            const subscriptionEndDate = data.subscription_end_date || null;
            const subscriptionId = data.subscription_id || null;
            
            console.log('Usage stats:', { 
              planType, monthRequests, requestsRemaining, subscriptionStatus, subscriptionEndDate, subscriptionId
            });
            
            // Update plan type display
            const planTypeDisplay = document.getElementById('plan-type-display');
            if (planTypeDisplay) {
              const planNames = {
                'free_trial': 'Free Trial',
                'pro_haiku': 'Pro Haiku',
                'pro_sonnet': 'Pro Sonnet'
              };
              planTypeDisplay.textContent = planNames[planType] || planType;
            }
            
            // Update subscription information
            const subscriptionStatusElement = document.getElementById('subscription-status');
            const subscriptionEndDateElement = document.getElementById('subscription-end-date');
            const subscriptionIdElement = document.getElementById('subscription-id');
            
            if (subscriptionStatusElement) {
              const statusDisplay = subscriptionStatus === 'active' ? 'Active' : 'Inactive';
              subscriptionStatusElement.textContent = statusDisplay;
            }
            
            if (subscriptionEndDateElement) {
              if (subscriptionEndDate) {
                const endDate = new Date(subscriptionEndDate);
                const formattedDate = endDate.toLocaleDateString('en-US', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                });
                subscriptionEndDateElement.textContent = `${formattedDate} UTC`;
              } else {
                subscriptionEndDateElement.textContent = 'N/A';
              }
            }
            

            

            

            
            // Update monthly usage
            const monthlyRequestsElement = document.getElementById('monthly-requests');
            const monthlyRequestsLimitElement = document.getElementById('monthly-requests-limit');
            const requestsRemainingElement = document.getElementById('requests-remaining');
            const monthlyProgressBar = document.getElementById('monthly-progress-bar');
            const monthlyProgressFill = document.getElementById('monthly-progress-fill');
            
            if (monthlyRequestsElement && monthlyRequestsLimitElement && requestsRemainingElement && monthlyProgressBar && monthlyProgressFill) {
              monthlyRequestsElement.textContent = monthRequests;
              
              // Set limit based on plan type
              let monthlyLimit;
              if (planType === 'free_trial') {
                monthlyLimit = 25;
              } else if (planType === 'pro_haiku' || planType === 'pro_sonnet') {
                monthlyLimit = 1000;
              } else {
                monthlyLimit = 100; // fallback
              }
              
              monthlyRequestsLimitElement.textContent = `of ${monthlyLimit} requests`;
              requestsRemainingElement.textContent = requestsRemaining;
              
              // Update progress bar
              const progressPercent = Math.min(100, (monthRequests / monthlyLimit) * 100);
              monthlyProgressFill.style.width = `${progressPercent}%`;
              monthlyProgressFill.textContent = `${Math.round(progressPercent)}%`;
            }
            
            // Show/hide sections based on plan type
            const isFreeTrial = planType === 'free_trial';
            const paidUsageSection = document.getElementById('paid-usage-section');

            const monthlyUsageSection = document.getElementById('monthly-usage-section');
            const freeTrialSection = document.getElementById('free-trial-section');
            
            if (isFreeTrial) {
              // Hide paid usage sections, show free trial section
              paidUsageSection.style.display = 'none';

              monthlyUsageSection.style.display = 'none';
              freeTrialSection.style.display = 'block';
              
              // Update free trial stats
              const requestsUsed = data.monthly_requests || 0;
              const requestsRemaining = Math.max(0, 25 - requestsUsed);
              const progressPercent = Math.min(100, (requestsUsed / 25) * 100);
              
              document.getElementById('free-requests-used').textContent = requestsUsed;
              document.getElementById('free-requests-remaining').textContent = requestsRemaining;
              document.getElementById('free-progress-fill').style.width = `${progressPercent}%`;
              document.getElementById('free-progress-fill').textContent = `${Math.round(progressPercent)}%`;
            } else {
              // Show paid usage sections, hide free trial section
              paidUsageSection.style.display = 'block';

              monthlyUsageSection.style.display = 'block';
              freeTrialSection.style.display = 'none';
              



            }
            
            // Show success status
            const statusDiv = document.getElementById('usage-status');
            statusDiv.className = 'status success';
            statusDiv.textContent = 'Stats updated successfully';
            statusDiv.style.display = 'block';
            setTimeout(() => {
              statusDiv.style.display = 'none';
            }, 3000);
          }
        } catch (error) {
          console.error('Failed to load stats:', error);
          const statusDiv = document.getElementById('usage-status');
          statusDiv.className = 'status error';
          statusDiv.textContent = 'Failed to load stats';
          statusDiv.style.display = 'block';
        }
      }
      
      // Copy code to clipboard with fallback for restricted environments
      function copyToClipboard(text, button) {
        // Check if we're in a restricted environment (like RStudio viewer pane)
        const isRestricted = window.location.href.includes('viewer_pane') || 
                           window.location.href.includes('capabilities') ||
                           !navigator.clipboard;
        
        if (!isRestricted && navigator.clipboard && navigator.clipboard.writeText) {
          // Try modern clipboard API only in non-restricted environments
          navigator.clipboard.writeText(text).then(function() {
            button.textContent = "Copied!";
            button.classList.add("copied");
            setTimeout(function() {
              button.textContent = "Copy";
              button.classList.remove("copied");
            }, 2000);
          }).catch(function(err) {
            console.error('Failed to copy: ', err);
            // Fallback to old method
            fallbackCopyToClipboard(text, button);
          });
        } else {
          // Use fallback method for restricted environments
          fallbackCopyToClipboard(text, button);
        }
      }
      
      function fallbackCopyToClipboard(text, button) {
        // Create a temporary textarea element
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        textArea.style.opacity = "0";
        document.body.appendChild(textArea);
        
        // Select and copy
        textArea.focus();
        textArea.select();
        
        try {
          const successful = document.execCommand('copy');
          if (successful) {
            button.textContent = "Copied!";
            button.classList.add("copied");
            setTimeout(function() {
              button.textContent = "Copy";
              button.classList.remove("copied");
            }, 2000);
          } else {
            button.textContent = "Failed";
            setTimeout(function() {
              button.textContent = "Copy";
            }, 2000);
          }
        } catch (err) {
          console.error('Fallback copy failed: ', err);
          button.textContent = "Failed";
          setTimeout(function() {
            button.textContent = "Copy";
          }, 2000);
        }
        
        // Clean up
        document.body.removeChild(textArea);
      }
      
               // Connect to WebSocket
         function connectWebSocket() {
           // Prevent duplicate connections
           if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
             return;
           }
           
           // Try port 8888 first, then 8889 if that fails
           let wsUrl;
           
           if (window.location.protocol === 'https:') {
             // If we're on HTTPS, use secure WebSocket
             const host = window.location.hostname || 'localhost';
             wsUrl = `wss://${host}/ws`;
           } else {
             // If we're on HTTP, use regular WebSocket
             const host = window.location.hostname || '127.0.0.1';
             wsUrl = `ws://${host}:8888`;
           }
           ws = new WebSocket(wsUrl);
           
           ws.onerror = function(event) {
             console.log("WebSocket connection failed on port 8888, trying 8889...");
             // Try port 8889 if 8888 fails
             wsUrl = `ws://${window.location.hostname || '127.0.0.1'}:8889`;
             console.log("Connecting to WebSocket:", wsUrl);
             ws = new WebSocket(wsUrl);
             
             ws.onopen = function() {
               console.log("WebSocket connected on port 8889");
               isConnected = true;
               document.getElementById("user-input").disabled = false;
               document.getElementById("send-button").disabled = false;
               document.getElementById("new-conversation-button").disabled = false;
               document.getElementById("debug-error-button").disabled = false;
               document.getElementById("analyze-plot-button").disabled = false;
               
               // Request objects first, then show personalized welcome message
               window.showWelcomeMessage = true;
               window.welcomeMessageShown = false;
               // Request objects to personalize welcome message
               ws.send(JSON.stringify({
                 action: "get_objects"
               }));
               // Fallback: if objects don't arrive quickly, show default message
               setTimeout(() => {
                 if (window.showWelcomeMessage && !window.welcomeMessageShown) {
                   window.welcomeMessageShown = true;
                   typeMessage(" Hi! I'm your RStudio AI assistant. I can help you write code, analyze data, create visualizations, debug errors, and more. What would you like to work on?", "ai", 15);
                   window.showWelcomeMessage = false;
                 }
               }, 1000);
             };
             
             ws.onmessage = function(event) {
               console.log("Message received:", event.data);
               // FIXED: Remove call to non-existent handleMessage function
               // The main WebSocket handler below will handle all messages
             };
             
             ws.onclose = function() {
               console.log("WebSocket disconnected on port 8889");
               isConnected = false;
               document.getElementById("user-input").disabled = true;
               document.getElementById("send-button").disabled = true;
               document.getElementById("new-conversation-button").disabled = true;
               document.getElementById("debug-error-button").disabled = true;
               document.getElementById("analyze-plot-button").disabled = true;
               
               // Clean up agent workflow state
               if (currentAgentWorkflow) {
                 console.log(' Cleaning up agent workflow due to disconnect');
                 currentAgentWorkflow = null;
                 agentResults = [];
                 agentCodes = [];
                 currentStepCode = null;
               }
               
               // Clear pending requests and timeouts
               if (window.pendingAgentCodeRequest) {
                 console.log(' Clearing pending agent code request');
                 window.pendingAgentCodeRequest = null;
               }
               
               pendingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
               pendingTimeouts = [];
               
               // Reset agent type flags
               window.currentActiveAgentType = null;
               window.completedAgentType = null;
               
               // Reset iteration counters
               cleaningCodeIterationCount = 0;
               cleaningCodeExecuting = false;
               
               // Reset AI responding flag and transform button back
               isAIResponding = false;
               transformToSendButton();
             };
             
             ws.onerror = function(event) {
               console.log("WebSocket error on port 8889:", event);
             };
           };
        
        ws.onopen = function() {
          console.log("WebSocket connected");
          isConnected = true;
          
          // Request completions for tab completion
          requestCompletions();
          
          // Only enable UI elements and show message if access is already validated
          // (If not validated, wait for access_code_loaded to auto-validate)
          if (isAccessValid) {
            document.getElementById("user-input").disabled = false;
            document.getElementById("send-button").disabled = false;
            document.getElementById("new-conversation-button").disabled = false;
            document.getElementById("debug-error-button").disabled = false;
            document.getElementById("analyze-plot-button").disabled = false;
            
            // Request objects first, then show personalized welcome message
            window.showWelcomeMessage = true;
            window.welcomeMessageShown = false;
            // Request objects to personalize welcome message
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                action: "get_objects"
              }));
              // Fallback: if objects don't arrive quickly, show default message
              setTimeout(() => {
                if (window.showWelcomeMessage && !window.welcomeMessageShown) {
                  window.welcomeMessageShown = true;
                  typeMessage(" Hi! I'm your RStudio AI assistant. I can help you write code, analyze data, create visualizations, debug errors, and more. What would you like to work on?", "ai", 15);
                  window.showWelcomeMessage = false;
                }
              }, 1000);
            }
          }
        };
        
        ws.onmessage = function(event) {
          const data = JSON.parse(event.data);
          // Minimal logging for explorer debugging only
          if (data.action && (data.action.includes('explorer') || data.action.includes('dataframe'))) {
            console.log(" Explorer:", data.action);
          }
          
          // Handle access_code_loaded message (when R backend has saved access code)
          if (data.action === 'access_code_loaded' && data.access_code) {
            // Just fill in the access code input field, but don't auto-validate
            // This allows users to change the code if needed before validating
            const accessCodeInput = document.getElementById('access-code');
            if (accessCodeInput) {
              accessCodeInput.value = data.access_code;
            }
            accessCode = data.access_code;
            
            // Show message that access code was found from past session
            const accessSection = document.getElementById('access-section');
            if (accessSection && window.getComputedStyle(accessSection).display !== 'none') {
              showAccessStatus(' Access code found from past session.', 'info');
            }
            
            // If already validated, sync with backend but don't re-validate
            if (isAccessValid && ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                action: 'set_access_code',
                access_code: data.access_code
              }));
            }
          }
          
          
          // Helper function to detect R code blocks - used by multiple cases
          // ONLY detects R code blocks (```r, ```R, ```{r}, ```{R}), NOT generic ``` or other languages
          const hasCodeBlock = (text) => {
            if (!text) return false;
            // Only return true if we have BOTH opening and closing backticks AND it's R code
            // This prevents triggering on incomplete/truncated code blocks or output blocks
            return /```(?:\{[rR]\}|[rR])(?:\n|\s+)[\s\S]+?```/.test(text);
          };
          
          
          switch(data.action) {
            case "ai_response":
              // Check if operation was stopped
              if (operationStopped) {
                return;
              }
              
              // Check if agent was stopped
              if (currentAgentWorkflow && currentAgentWorkflow.stopped) {
                return;
              }
              
              if (data.streaming) {
                if (data.chunk) {
                  addStreamingChunk(data.chunk);
                } else if (data.finished) {
                  finishStreaming();
                }
              } else {
                // Handle regular response
                // Remove all animated placeholders
                removeAnimatedPlaceholder("ai-thinking");
                removeAnimatedPlaceholder("ai-debugging");
                removeAnimatedPlaceholder("ai-generating-code");
                removeAnimatedPlaceholder("ai-analyzing-statistical");
                removeAnimatedPlaceholder("ai-analyzing-transformation");
                removeAnimatedPlaceholder("ai-analyzing-cleaning");
                removeAnimatedPlaceholder("ai-analyzing-modeling");
                removeAnimatedPlaceholder("ai-analyzing-results");
                
                addMessage(data.message, "ai");
                
                // Transform stop button back to send button for non-streaming responses
                if (isAIResponding) {
                  transformToSendButton();
                }
              }
              break;
            case "stop_response":
              break;
            case "inserted":
              addMessage("Code inserted successfully!", "ai");
              break;
            case "transformation_agent_started":
              console.log(' Transformation agent started message received');
              handleTransformationAgentStarted(data.data || data);
              break;
            case "statistical_agent_started":
              console.log(' Statistical agent started message received');
              handleStatisticalAgentStarted(data.data || data);
              break;
            case "statistical_step_result":
              console.log(' Statistical step result received');
              handleStatisticalStepResult(data.data || data);
              break;
            case "visualization_agent_started":
              console.log(' Visualization agent started message received');
              handleVisualizationAgentStarted(data.data || data);
              break;
            case "visualization_step_result":
              console.log(' Visualization step result received');
              handleVisualizationStepResult(data.data || data);
              break;
            case "visualization_plot_analysis":
              console.log(' Visualization plot analysis received');
              if (data.success) {
                console.log(' Plot analysis completed successfully');
              } else {
                console.log(' Plot analysis failed:', data.message);
                addMessage(`**Plot Analysis Error:** ${data.message}`, 'ai');
              }
              break;
            case "executed":
              // Check if agent was stopped before processing execution results
              if (currentAgentWorkflow && currentAgentWorkflow.stopped) {
                console.log(' Agent was stopped, ignoring execution result');
                return;
              }
              
              if (data.status === "success") {
                // Format the output nicely for agent steps
                let outputText = "";
                if (data.output && Array.isArray(data.output)) {
                  outputText = data.output.join('\n');
                } else if (data.output) {
                  outputText = data.output;
                } else {
                  outputText = "No output";
                }
                
                // Store last output for context - smart extraction for token efficiency
                if (outputText && outputText !== "No output" && outputText.trim()) {
                  lastCodeOutput = extractSmartContext(outputText);
                } else {
                  lastCodeOutput = null;
                }
                
                // ALWAYS check for plots FIRST, regardless of other content
                const plotMatches = outputText.match(/PLOT_DATA:\s*([A-Za-z0-9+/=]+)/g);
                const analyzeMatch = outputText.match(/ANALYZE_PLOT:TRUE/);
                let cleanOutputText = outputText;
                let hasPlots = false;
                
                console.log(' Plot detection - plotMatches:', plotMatches ? plotMatches.length : 0, 'outputText length:', outputText.length);
                
                if (plotMatches && plotMatches.length > 0) {
                  hasPlots = true;
                  console.log(' Plots detected, displaying', plotMatches.length, 'plot(s)');
                  // Remove all PLOT_DATA markers from the output text
                  cleanOutputText = outputText.replace(/PLOT_DATA:\s*[A-Za-z0-9+/=]+\s*/g, '');
                  cleanOutputText = cleanOutputText.replace(/ANALYZE_PLOT:TRUE\s*/g, '');
                  cleanOutputText = cleanOutputText.trim();
                  
                  // Display each plot found
                  plotMatches.forEach((match, index) => {
                    // Extract just the base64 data part
                    const plotDataMatch = match.match(/PLOT_DATA:\s*([A-Za-z0-9+/=]+)/);
                    const plotData = plotDataMatch ? plotDataMatch[1] : '';
                    const plotNumber = plotMatches.length > 1 ? ` (${index + 1}/${plotMatches.length})` : '';
                    
                    // Determine if this is from visualization agent or regular chat
                    const isVisualizationAgent = currentAgentWorkflow && currentAgentWorkflow.type === 'visualization';
                    const plotTitle = isVisualizationAgent ? `**Plot from Visualization Agent${plotNumber}**` : `**Generated Plot${plotNumber}**`;
                    
                    const message = `${plotTitle}\n\n` +
                                   `data:image/png;base64,${plotData}`;
                    addVisualizationMessage(message, 'ai');
                  });
                  
                  // Update outputText to cleaned version for subsequent processing
                  outputText = cleanOutputText;
                }
                
                // Check if this is a custom transformation request (before checking agent output)
                if (outputText.includes('Custom Transformation Request') && outputText.includes('Sending custom transformation request to Claude')) {
                  console.log(' Detected custom transformation request in executed output, sending to Claude');
                  
                  // Display the custom transformation request in chat with formatting
                  const formattedOutput = outputText
                    .replace(/Custom Transformation Request/g, '**Custom Transformation Request**')
                    .replace(/Request: (.+?)(?=\n|$)/g, '**Request:** $1')
                    .replace(/Dataset: (.+?)(?=\n|$)/g, '**Dataset:** $1')
                    .replace(/Variables: (.+?)(?=\n|$)/g, '**Variables:** $1')
                    .replace(/Sending custom transformation request to Claude\.\.\./g, '**Sending custom transformation request to Claude...**')
                    .replace(/Claude will provide the transformation code based on your request\./g, '**Claude will provide the transformation code based on your request.**');
                  
                  addMessage(formattedOutput, 'ai');
                  
                  // Set flag to prevent duplicate requests
                  window.customTransformationInProgress = true;
                  
                  // Send custom transformation request to Claude
                  if (ws && ws.readyState === WebSocket.OPEN) {
                    // Extract the custom request from the output
                    const requestMatch = outputText.match(/Request: (.+?)\n/);
                    const customRequest = requestMatch ? requestMatch[1] : 'Custom transformation requested';
                    
                    // Create Claude prompt for custom transformation
                    const claudePrompt = `I need you to perform a custom data transformation based on the following request:

**Custom Transformation Request:**
${customRequest}

**Dataset Information:**
- Dataset: ${currentAgentWorkflow?.dataframe || 'Unknown'}
- Variables: ${currentAgentWorkflow?.dataframe ? 'Available in workspace' : 'Unknown'}

Please provide:
1. A detailed transformation plan
2. Executable R code to perform the transformations
3. Data quality checks and validation
4. Summary of changes made

Code only. Minimal chat. Provide executable R code that can be run directly.`;

                    // Send to Claude
                    ws.send(JSON.stringify({
                      action: 'chat_with_ai',
                      message: claudePrompt,
                      conversation_context: 'custom_transformation'
                    }));
                  }
                  break;
                }
                
                // Handle visualization step completion for workflow progression (plots already displayed above)
                if (hasPlots && currentAgentWorkflow && currentAgentWorkflow.type === 'visualization') {
                    console.log(' Processing visualization step completion for workflow progression');
                    
                    // Store result for final summary (without displaying again)
                    agentResults.push({
                      description: 'Generated Plot',
                      output: `Generated plot ${currentAgentWorkflow.currentStep - 1} of ${currentAgentWorkflow.totalSteps}`,
                      step: currentAgentWorkflow.currentStep - 1
                    });
                    
                    // Analyze this specific plot
                    analyzeCurrentVisualizationPlot();
                    
                    // Move to next step after a short delay to allow analysis to start
                    setTimeout(() => {
                      requestNextVisualizationStep();
                    }, 1000);
                }
                
                // Check if this is agent output
                if (currentAgentWorkflow && outputText.length > 0) {
                  // Store the result and code for final summary
                  const currentStepInfo = currentAgentWorkflow.workflowSteps[currentAgentWorkflow.currentStep - 1];
                  agentResults.push({
                    step: currentAgentWorkflow.currentStep,
                    operation: currentStepInfo?.operation,
                    description: currentStepInfo?.description,
                    output: outputText
                  });
                  
                  // Store the code that was executed
                  agentCodes.push({
                    step: currentAgentWorkflow.currentStep,
                    operation: currentStepInfo?.operation,
                    description: currentStepInfo?.description,
                    code: currentStepCode
                  });
                  
                  console.log(' Agent step completed. Current workflow state:', currentAgentWorkflow);
                  console.log(' Step comparison:', {
                    currentStep: currentAgentWorkflow.currentStep,
                    totalSteps: currentAgentWorkflow.totalSteps,
                    comparison: currentAgentWorkflow.currentStep < currentAgentWorkflow.totalSteps,
                    shouldContinue: currentAgentWorkflow.currentStep < currentAgentWorkflow.totalSteps
                  });
                  
                  if (currentAgentWorkflow.currentStep < currentAgentWorkflow.totalSteps) {
                    console.log(' Moving to next step in 1.5 seconds...');
                    // Move to next step after a brief delay
                    setTimeout(() => {
                      console.log(' Executing next step now!');
                      executeNextAgentStep();
                    }, 1000);
                  } else {
                    console.log(' Workflow steps complete!');
                    console.log(' Final workflow state:', {
                      currentStep: currentAgentWorkflow.currentStep,
                      totalSteps: currentAgentWorkflow.totalSteps,
                      agentType: currentAgentWorkflow.algorithms ? 'Modeling' : 
                                currentAgentWorkflow.transformationOptions ? 'Transformation' : 'Cleaning'
                    });
                    
                    // All agents end workflow normally
                    console.log(' Workflow complete!');
                    
                    // Store agent type before clearing workflow for final messaging
                    window.completedAgentType = currentAgentWorkflow.algorithms ? 'Modeling' : 
                                               currentAgentWorkflow.transformationOptions ? 'Transformation' : 
                                               currentAgentWorkflow.analysisOptions ? 'Statistical' : 'Cleaning';
                    
                    // All agents end workflow normally using unified function
                    finishAgentWorkflow();
                    
                    // Don't reset button yet - wait for AI response streaming to complete
                    // The button will be reset in finishStreaming() when streaming is done
                  }
                } else if (!currentAgentWorkflow) {
                  // Check if this is cleaning code execution
                  if (cleaningCodeExecuting) {
                    console.log(' Cleaning code executed successfully!');
                    // Code executed successfully, no need to check for errors
                    
                    // Determine agent type for appropriate messaging
                    let agentType = window.currentActiveAgentType || window.completedAgentType || 'Cleaning';
                    let operationType, nextSteps;
                    
                    switch (agentType) {
                      case 'Modeling':
                      operationType = 'modeled';
                      nextSteps = 'Check your environment for the trained models and results';
                        break;
                      case 'Transformation':
                        operationType = 'transformed';
                        nextSteps = 'Check your environment for the transformed dataset';
                        break;
                      case 'Statistical':
                      operationType = 'analyzed';
                      nextSteps = 'Check your environment for the statistical analysis results';
                        break;
                      case 'Cleaning':
                      default:
                        operationType = 'cleaned';
                        nextSteps = 'Check your environment for the cleaned dataset';
                        break;
                    }
                    
                    // Check if this is a normal chat auto-execute (not an agent workflow)
                    if (window.currentActiveAgentType === null && window.completedAgentType === null) {
                      // Normal chat auto-execute
                      let successMessage = `**Code Executed Successfully!**`;
                      if (outputText && outputText.trim() && outputText !== "No output") {
                        successMessage += `\n\n@@output\n${outputText}\n@@`;
                      }
                      addMessage(successMessage, 'ai');
                    } else {
                      // Agent workflow auto-execute
                      let successMessage = `**${agentType} Code Executed Successfully!**\n\nThe data has been ${operationType} according to Claude's recommendations.`;
                      if (outputText && outputText.trim() && outputText !== "No output") {
                        successMessage += `\n\n@@output\n${outputText}\n@@`;
                      }
                      addMessage(successMessage, 'ai');
                      addMessage(`**Next Steps:**\n- ${nextSteps}\n- Verify the results meet your expectations\n- The ${agentType.toLowerCase()} agent workflow is now complete!`, 'ai');
                    }
                    
                    // Reset cleaning code state
                    cleaningCodeIterationCount = 0;
                    cleaningCodeExecuting = false;
                    console.log(` ${agentType} code succeeded, resetting state`);
                    
                    // Clear the stored agent type
                    window.completedAgentType = null;
                    window.currentActiveAgentType = null;
                    
                    // Reset button after code execution completes (for auto-execute)
                    // Streaming has already completed, so we need to reset here
                    if (isAIResponding) {
                      isAIResponding = false;
                      transformToSendButton();
                    }
                  } else {
                    // Regular code execution, not agent
                    let successMessage = "**Code executed successfully!**";
                    if (outputText && outputText.trim() && outputText !== "No output") {
                      successMessage += `\n\n@@output\n${outputText}\n@@`;
                    }
                    addMessage(successMessage, "ai");
                    
                    // Reset AI responding flag and transform button back
                    if (isAIResponding) {
                      isAIResponding = false;
                      transformToSendButton();
                    }
                  }
                }
              } else {
                // Code execution failed
                if (cleaningCodeExecuting) {
                  // This is cleaning code that failed - trigger iteration
                  console.log(' Cleaning code execution failed, triggering error handling...');
                  // Pass the current step code that failed
                  handleCleaningCodeError(data.error, currentStepCode || "");
                } else {
                  // Regular code execution failed
                  addMessage("Code execution failed: " + data.error, "ai");
                  
                  // Reset AI responding flag and transform button back
                  if (isAIResponding) {
                    isAIResponding = false;
                    transformToSendButton();
                  }
                }
              }
              break;
            case "execute_and_fix":
              if (data.status === "success") {
                let successMessage = "**Code executed successfully!**";
                const outputText = data.output || "No output";
                if (outputText && outputText.trim() && outputText !== "No output") {
                  successMessage += `\n\n@@output\n${outputText}\n@@`;
                }
                addMessage(successMessage, "ai");
              } else if (data.status === "error_fixed") {
                addMessage("Code failed but AI provided a fix:\n\nOriginal error: " + data.original_error + "\n\nFixed code:\n```r\n" + data.fixed_code + "\n```", "ai");
              } else {
                addMessage("Code execution failed: " + data.error, "ai");
              }
              break;
            case "error":
              addMessage("Error: " + data.message, "ai");
              break;
            case "get_last_error":
              if (data.message) {
                addMessage(data.message, "ai");
              }
              // Reset AI responding flag and transform button back
              if (isAIResponding) {
                isAIResponding = false;
                transformToSendButton();
              }
              break;
            case "debug_info":
              // Skip the verbose progress updates - just show the AI fix directly
              break;
            case "debug_ai_response":
              // Remove all animated placeholders
              removeAnimatedPlaceholder("ai-debugging");
              removeAnimatedPlaceholder("ai-thinking");
              removeAnimatedPlaceholder("ai-generating-code");
              removeAnimatedPlaceholder("ai-analyzing-statistical");
              removeAnimatedPlaceholder("ai-analyzing-transformation");
              removeAnimatedPlaceholder("ai-analyzing-cleaning");
              removeAnimatedPlaceholder("ai-analyzing-modeling");
              removeAnimatedPlaceholder("ai-analyzing-results");
              
              if (data.streaming) {
                addStreamingChunk(data.chunk);
              } else {
                console.log("DEBUG: Finishing debug streaming");
                finishStreaming();
                // No buttons - just show the debug analysis
              }
              break;
            case "chat_with_ai":
              // Handle messages sent to the chat interface
              if (data.message) {
                // If this is the debugging start message, don't show the static message
                // (we already have the animated placeholder - it will be removed when streaming starts)
                if (data.message.includes("Debugging error")) {
                  // Don't add the static message - keep the animated placeholder until streaming starts
                  // The placeholder will be removed by addStreamingChunk when the first chunk arrives
                } else {
                addMessage(data.message, "ai");
                }
              }
              break;
            case "plot_analysis":
              // Check if operation was stopped
              if (operationStopped) {
                console.log(' Operation was stopped, ignoring plot analysis response');
                return;
              }
              
              if (data.success) {
                // Process plot analysis response properly
                const fullMessage = "**Plot Analysis Complete!**\n\n" + data.ai_interpretation;
                addPlotAnalysisMessage(fullMessage);
              } else {
                addMessage("**Plot Analysis Failed:** " + data.message, "ai");
              }
              
              // Reset AI responding flag and transform button back
              if (isAIResponding) {
                isAIResponding = false;
                transformToSendButton();
              }
              
              // Reset stop flag when analysis completes
              operationStopped = false;
              break;

            case "theme_info":
              // Apply RStudio theme with actual colors
              if (data.is_dark !== undefined) {
                applyTheme(data.is_dark, data.theme_name, data.colors);
              }
              break;

            // Agent-related cases
            case "completions":
              if (data.data) {
                completions = data.data;
                console.log(' Completions received:', completions);
              }
              break;
            case "dataframes":
              console.log('Handling dataframes action');
              // Populate all agents' dataframes to ensure consistency
              populateDataFrameSelect(data.data);
              populateTransformationDataFrameSelect(data.data);
              populateStatisticalDataFrameSelect(data.data);
              populateVizDataFrameSelect(data.data);
              populateModelingDataFrameSelect(data.data);
              break;
            case "objects":
              console.log('Handling objects action for explorer');
              // Populate explorer with all objects
              populateExplorerObjectSelect(data.data, data.objects_info);
              
              // If this is the first connection and we haven't shown welcome message yet
              if (window.showWelcomeMessage && !window.welcomeMessageShown) {
                window.showWelcomeMessage = false;
                // Get column names for dataframes using existing get_dataframe_info pattern
                generateWelcomeWithColumns(data.data, data.objects_info);
              }
              break;
            case "dataframe_explorer_data":
              console.log(' Explorer: Received explorer data:', data.data);
              if (data.data && data.data.exists) {
                // Determine object type - check for vectors (have values and length but no column_info)
                let objType = data.data.type || 'dataframe';
                if (data.data.values && data.data.length !== undefined && !data.data.column_info && !data.data.nrow) {
                  objType = 'vector';
                } else if (data.data.column_info && data.data.nrow && data.data.ncol) {
                  // Could be dataframe or matrix - check type field
                  if (data.data.type === 'matrix') {
                    objType = 'matrix';
                  } else {
                    objType = 'dataframe';
                  }
                }
                
                // Handle different object types
                if (objType === 'dataframe' || objType === 'matrix' || data.data.column_info) {
                  // Dataframe or Matrix - show grid view
                  const rowCount = data.data.nrow || 0;
                  const colCount = data.data.ncol || 0;
                  document.getElementById('explorer-df-dims').textContent = 
                    `${rowCount} rows  ${colCount} columns`;
                  
                  // Show summary panel only for dataframes (not matrices)
                  const summaryPanel = document.getElementById('explorer-summary-panel');
                  if (summaryPanel) {
                    if (objType === 'dataframe') {
                      summaryPanel.style.display = 'flex';
                    } else {
                      summaryPanel.style.display = 'none';
                    }
                  }
                  
                  // Show row header corner and headers for dataframes and matrices
                  const rowHeaderCorner = document.querySelector('.row-header-corner');
                  const rowHeaders = document.getElementById('grid-row-headers');
                  const columnHeaders = document.getElementById('grid-column-headers');
                  if (rowHeaderCorner) {
                    rowHeaderCorner.style.display = 'block';
                  }
                  if (rowHeaders) {
                    rowHeaders.style.display = 'block';
                  }
                  if (columnHeaders) {
                    columnHeaders.style.display = 'block';
                  }
                  
                  try {
                    if (data.data.column_info) {
                    renderExplorerSummary(data.data.column_info);
                    loadExplorerPage(1);
                    } else {
                      // Fallback if no column_info
                      renderObjectExplorer(data.data);
                    }
                  } catch (error) {
                    console.error(' Explorer: Error rendering:', error);
                    document.getElementById('explorer-status-text').textContent = 'Error rendering data: ' + error.message;
                  }
                } else {
                  // Other object types - hide summary panel
                  const summaryPanel = document.getElementById('explorer-summary-panel');
                  if (summaryPanel) {
                    summaryPanel.style.display = 'none';
                  }
                  
                  renderObjectExplorer(data.data);
                }
              } else {
                document.getElementById('explorer-status-text').textContent = 'Error: ' + (data.data.error || 'Object not found');
              }
              break;
            case "dataframe_chunk_filtered":
              console.log(' Explorer: Received chunk data:', data.data);
              if (data.data && data.data.exists) {
                try {
                  renderExplorerGrid(data.data.data, data.data.column_order, {
                    page: data.data.page,
                    total_pages: data.data.total_pages,
                    start_row: data.data.start_row,
                    end_row: data.data.end_row,
                    total_rows: data.data.total_rows,
                    filtered_rows: data.data.filtered_rows
                  });
                } catch (error) {
                  console.error(' Explorer: Error rendering grid:', error);
                  document.getElementById('explorer-status-text').textContent = 'Error rendering grid: ' + error.message;
                }
              } else {
                document.getElementById('explorer-status-text').textContent = 'Error: ' + (data.data.error || 'Failed to load data');
              }
              break;
            case "explorer_code":
              // Show code in modal or copy to clipboard
              const code = data.data.code;
              if (confirm(`Generated code:\n\n${code}\n\nCopy to clipboard?`)) {
                navigator.clipboard.writeText(code);
              }
              break;
            case "dataframe_info":
              console.log('Handling dataframe_info action');
              displayDataFrameInfo(data.data);
              // Also handle for modeling agent if that's the current context
              if (window.currentModelingDataframe) {
                handleModelingDataframeInfo(data.data);
              }
              // Also handle for statistical agent if that's the current context
              if (window.currentStatisticalDataframe) {
                handleStatisticalDataframeInfo(data.data);
              }
              // Also handle for visualization agent if that's the current context
              if (window.currentVisualizationDataframe) {
                handleVisualizationDataframeInfo(data.data);
              }
              // Handle welcome message column data collection
              if (window.pendingWelcomeColumns && !window.welcomeMessageShown) {
                const pending = window.pendingWelcomeColumns;
                if (data.data && data.data.name) {
                  // Extract column names from column_info object (keys are column names)
                  let columnNames = [];
                  if (data.data.column_info) {
                    columnNames = Object.keys(data.data.column_info);
                  } else if (data.data.columns) {
                    // Fallback to columns array if it exists
                    columnNames = Array.isArray(data.data.columns) ? data.data.columns : [];
                  } else if (data.data.numeric_cols || data.data.categorical_cols || data.data.date_cols) {
                    // Fallback: combine all column type arrays
                    columnNames = [
                      ...(data.data.numeric_cols || []),
                      ...(Array.isArray(data.data.categorical_cols) ? data.data.categorical_cols : Object.keys(data.data.categorical_cols || {})),
                      ...(Object.keys(data.data.date_cols || {}))
                    ];
                  }
                  
                  if (columnNames.length > 0) {
                    pending.columnData[data.data.name] = columnNames;
                    pending.received++;
                    console.log(` Welcome: Received columns for ${data.data.name} (${pending.received}/${pending.count})`);
                    
                    // When we have all column data, generate welcome message
                    if (pending.received >= pending.count) {
                      console.log(' Welcome: All column data received, generating welcome message');
                      const welcomeText = generatePersonalizedWelcome(pending.objects, pending.objectsInfo, pending.columnData);
                      typeMessage(welcomeText, "ai", 10);
                      // Add to conversation history
                      if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                          action: "add_to_conversation_history",
                          role: "ai",
                          message: welcomeText
                        }));
                      }
                      window.welcomeMessageShown = true;
                      window.pendingWelcomeColumns = null;
                    }
                  } else {
                    console.log(` Welcome: No columns found for ${data.data.name}`);
                  }
                }
              }
              break;
            case "dataframe_variables":
              console.log('Handling dataframe_variables action');
              renderVariableSelection(data.data);
              break;
            case "agent_started":
              console.log('Handling agent_started action');
              handleAgentStarted(data.data);
              break;
            case "agent_step":
              console.log('Handling agent_step action');
              handleAgentStep(data.data);
              break;
            case "transformation_agent_started":
              console.log('Handling transformation_agent_started action');
              handleTransformationAgentStarted(data.data);
              break;
            case "statistical_agent_started":
              console.log('Handling statistical_agent_started action');
              handleStatisticalAgentStarted(data.data);
              break;
            case "modeling_agent_started":
              console.log('Handling modeling_agent_started action');
              handleModelingAgentStarted(data.data);
              break;
            case "execute_code_response":
              console.log(' Received execute_code_response');
              console.log(' Code to execute:', data.code);
              
              // Store the code for later display
              currentStepCode = data.code;
              
              // Check if this is a custom transformation request
              if (data.code.includes('Custom Transformation Request') && data.code.includes('Sending custom transformation request to Claude')) {
                console.log(' Detected custom transformation request, sending to Claude');
                
                // Set flag to prevent duplicate requests
                window.customTransformationInProgress = true;
                
                // Send custom transformation request to Claude
                if (ws && ws.readyState === WebSocket.OPEN) {
                  // Extract the custom request from the code
                  const requestMatch = data.code.match(/Request: (.+?)\\n/);
                  const customRequest = requestMatch ? requestMatch[1] : 'Custom transformation requested';
                  
                  // Create Claude prompt for custom transformation
                  const claudePrompt = `I need you to perform a custom data transformation based on the following request:

**Custom Transformation Request:**
${customRequest}

**Dataset Information:**
- Dataset: ${currentAgentWorkflow?.dataframe || 'current dataset'}
- Variables: Available in the current workspace

Please provide:
1. **Transformation Plan**: What data transformations should be performed?
2. **R Code**: Complete, executable R code to perform the transformations
3. **Data Quality Checks**: How to verify the transformations worked correctly
4. **New Variables**: What new variables will be created?

**IMPORTANT**: This is a transformation agent request. Please provide complete, executable R code that can be run immediately. Focus on practical data transformations that address the custom request. Include all necessary libraries and error handling.

Code only. Minimal chat. Provide executable R code that performs the requested data transformations.`;

                  ws.send(JSON.stringify({
                    action: 'chat_with_ai',
                    message: claudePrompt,
                    conversation_context: 'custom_transformation',
                    agentType: 'transformation'
                  }));
                }
              } else {
                // Check if auto-execute is enabled before executing
                const autoExecute = isAutoExecuteEnabled();
                if (autoExecute) {
                // Automatically execute the next step's code
                if (ws && ws.readyState === WebSocket.OPEN) {
                    console.log(' Auto-execute enabled: Sending execute_code request');
                  ws.send(JSON.stringify({
                    action: 'execute_code',
                    code: data.code
                  }));
                } else {
                  console.log(' WebSocket not available for execute_code');
                  }
                } else {
                  console.log(' Auto-execute disabled: Code will not be executed automatically');
                  // Add the code as a message with execute button
                  addMessage(data.code, 'ai');
                }
              }
              break;
              
            case "claude_response":
              console.log(' Received Claude response:', data.conversation_context);
                            if (data.conversation_context === 'data_cleaning_agent_code') {
                handleCleaningCodeResponse(data.message, data.conversation_context);
              }
              break;
              
            case "ai_response":
              console.log(' Received AI response:', data);
              console.log(' Data structure:', JSON.stringify(data, null, 2));
              
              // Check if this is Claude's response to our cleaning code request
              // Detect code blocks with ```r, ```R, ```{r}, ```{R}, or plain ```
              if (data.message && hasCodeBlock(data.message)) {
                handleCleaningCodeResponse(data.message, data.conversation_context);
              } else if (data.chunk && hasCodeBlock(data.chunk)) {
                handleCleaningCodeResponse(data.chunk, data.conversation_context);
              } else if (data.finished && data.chunk && hasCodeBlock(data.chunk)) {
                handleCleaningCodeResponse(data.chunk, data.conversation_context);
              } else {
                console.log(' No R code detected in AI response');
              }
              break;
              
            case "last_error":
              console.log(' Received last error:', data.error);
              if (data.error && data.error !== 'No error') {
                handleCleaningCodeError(data.error, data.code);
              }
              break;
              
            case "claude_fixed_code":
              console.log(' Received Claude fixed code response');
              handleCleaningCodeResponse(data.message, 'data_cleaning_agent_code_fix');
              break;
              
            case "streaming_complete":
              console.log(' Streaming complete, checking for R code in final message');
              // Check if we have a complete message with R code - use same detection as ai_response
              if (window.lastCompleteMessage && hasCodeBlock(window.lastCompleteMessage)) {
                console.log(' Detected R code in complete streaming message');
                
                // Add a small delay to let the user see the complete message before execution
                // This prevents jarring UX where code executes while still reading
                setTimeout(() => {
                  console.log(' Handling code after brief display delay');
                  handleCleaningCodeResponse(window.lastCompleteMessage, 'data_cleaning_agent_code');
                }, 800); // 800ms delay to allow reading
              }
              break;
            case "stop_response":
              break;

          }
        };
        
        ws.onclose = function() {
          console.log("WebSocket disconnected");
          isConnected = false;
          document.getElementById("user-input").disabled = true;
          document.getElementById("send-button").disabled = true;
          document.getElementById("debug-error-button").disabled = true;
          
          // Clean up agent workflow state
          if (currentAgentWorkflow) {
            console.log(' Cleaning up agent workflow due to disconnect');
            currentAgentWorkflow = null;
            agentResults = [];
            agentCodes = [];
            currentStepCode = null;
          }
          
          // Clear pending requests and timeouts
          if (window.pendingAgentCodeRequest) {
            console.log(' Clearing pending agent code request');
            window.pendingAgentCodeRequest = null;
          }
          
          pendingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
          pendingTimeouts = [];
          
          // Reset agent type flags
          window.currentActiveAgentType = null;
          window.completedAgentType = null;
          
          // Reset iteration counters
          cleaningCodeIterationCount = 0;
          cleaningCodeExecuting = false;
          
          // Reset AI responding flag and transform button back
          isAIResponding = false;
          transformToSendButton();
          
          addMessage("Connection lost. Please restart the addin.", "ai");
        };
        
        ws.onerror = function(error) {
          console.error("WebSocket error:", error);
          addMessage("Failed to connect to RStudio. Please check if the server is running.", "ai");
        };
      }
      
      // Reusable function to create animated placeholder messages
      function createAnimatedPlaceholder(id, text) {
        const placeholder = document.createElement("div");
        placeholder.className = "message ai-message";
        placeholder.id = id;
        const textSpan = document.createElement("span");
        // Set as innerHTML to allow markdown processing
        textSpan.innerHTML = text;
        // Process markdown formatting (bold, italic, etc.)
        processMarkdownFormatting(textSpan);
        const dotsSpan = document.createElement("span");
        dotsSpan.className = "thinking-dots";
        placeholder.appendChild(textSpan);
        placeholder.appendChild(dotsSpan);
        document.getElementById("chat-container").appendChild(placeholder);
        
        // Animate the dots
        let dotCount = 0;
        const interval = setInterval(() => {
          dotCount = (dotCount + 1) % 4; // Cycle 0, 1, 2, 3
          dotsSpan.textContent = '.'.repeat(dotCount);
        }, 500); // Update every 500ms
        
        // Store interval ID so we can clear it when response arrives
        placeholder.dataset.intervalId = interval;
        return placeholder;
      }
      
      // Helper function to remove animated placeholder
      function removeAnimatedPlaceholder(id) {
        const placeholder = document.getElementById(id);
        if (placeholder) {
          if (placeholder.dataset.intervalId) {
            clearInterval(parseInt(placeholder.dataset.intervalId));
          }
          if (placeholder.parentNode) {
            placeholder.parentNode.removeChild(placeholder);
          }
        }
      }
      
      function debugLastError() {
        if (!isConnected) return;
        
        console.log("Requesting last error...");
        
        // Reset stop flag for new operation
        operationStopped = false;
        
        // Set AI responding flag
        isAIResponding = true;
        
        // Transform send button to stop button
        transformToStopButton();
        
        // Insert debugging placeholder with animated dots
        createAnimatedPlaceholder("ai-debugging", "Debugging error");
        
        const message = {
          action: "get_last_error"
        };
        
        ws.send(JSON.stringify(message));
        

      }
      
      function sendMessage() {
        const input = document.getElementById("user-input");
        const message = input.value.trim();
        if (!message || !isConnected) return;
        
        
        // Clear any tab completion suggestion
        hideCompletionSuggestion();
        
        // Add user message
        addMessage(message, "user");
        input.value = "";
        // Reset textarea height after sending
        if (input) {
          input.style.height = "24px";
        }
        
        // Insert AI placeholder while thinking with animated dots
        const thinking = document.createElement("div");
        thinking.className = "message ai-message";
        thinking.id = "ai-thinking";
        const thinkingText = document.createElement("span");
        thinkingText.textContent = "Thinking";
        const thinkingDots = document.createElement("span");
        thinkingDots.className = "thinking-dots";
        thinking.appendChild(thinkingText);
        thinking.appendChild(thinkingDots);
        const chatContainer = document.getElementById("chat-container");
        chatContainer.appendChild(thinking);
        
        // Smooth scroll to show "Thinking..." indicator
        chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
        
        // Animate the dots
        let dotCount = 0;
        const thinkingInterval = setInterval(() => {
          dotCount = (dotCount + 1) % 4; // Cycle 0, 1, 2, 3
          thinkingDots.textContent = '.'.repeat(dotCount);
        }, 500); // Update every 500ms
        
        // Store interval ID so we can clear it when response arrives
        thinking.dataset.intervalId = thinkingInterval;
        
        // Reset stop flag for new operation
        operationStopped = false;
        
        // Set AI responding flag when sending message
        isAIResponding = true;
        
        // Transform send button to stop button
        transformToStopButton();
        
        // Send to R via WebSocket (include last output for context if available)
        const chatPayload = {
          action: "chat_with_ai",
          message: message
        };
        if (lastCodeOutput) {
          chatPayload.last_output = lastCodeOutput;
        }
        ws.send(JSON.stringify(chatPayload));
        

      }
      

      
      // Transform stop button back to send button
      function transformToSendButton() {
        const sendBtn = document.getElementById('send-button');
        sendBtn.textContent = 'Send';
        sendBtn.className = 'send-button';
        sendBtn.onclick = sendMessage;
        isAIResponding = false;
        currentRequestId = null;
      }
      
      // Transform send button to stop button (generic, for chat/auto-execute/debug)
      function transformToStopButton() {
        const sendBtn = document.getElementById('send-button');
        if (sendBtn) {
          sendBtn.textContent = 'Stop';
          sendBtn.className = 'send-button stop-mode';
          sendBtn.onclick = stopCurrentOperation;
        }
      }
      
      // Transform send button to agent stop button
      function transformToAgentStopButton() {
        const sendBtn = document.getElementById('send-button');
        if (sendBtn) {
          sendBtn.textContent = 'Stop Agent';
          sendBtn.className = 'send-button stop-mode';
          sendBtn.onclick = stopAgentWorkflow;
          // Set AI responding flag when agent workflow starts
          isAIResponding = true;
        }
      }
      
      // Stop current operation (chat/auto-execute/debug)
      function stopCurrentOperation() {
        // Set stop flag to ignore incoming chunks
        operationStopped = true;
        
        // Clear all pending timeouts
        pendingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
        pendingTimeouts = [];
        
        // Clear streaming timeout
        if (streamingTimeout) {
          clearTimeout(streamingTimeout);
          streamingTimeout = null;
        }
        
        // Send stop message to backend
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'stop_response',
            message: 'User requested to stop the current operation'
          }));
        }
        
        // Remove current streaming message if it exists
        if (currentStreamingMessage) {
          currentStreamingMessage.remove();
          currentStreamingMessage = null;
        }
        
        // Reset streaming state
        currentStreamingMessage = null;
        
        // Reset cleaning code state
        cleaningCodeExecuting = false;
        cleaningCodeIterationCount = 0;
        
        // Remove thinking placeholder if it exists
        const thinkingPlaceholder = document.getElementById('ai-thinking');
        if (thinkingPlaceholder) {
          const intervalId = thinkingPlaceholder.dataset.intervalId;
          if (intervalId) {
            clearInterval(parseInt(intervalId));
          }
          thinkingPlaceholder.remove();
        }
        
        // Remove debugging placeholder if it exists
        const debugPlaceholder = document.getElementById('ai-debugging');
        if (debugPlaceholder) {
          debugPlaceholder.remove();
        }
        
        // Show stopped message
        addMessage('**Operation Stopped** - Request interrupted by user.', 'ai');
        
        // Reset AI responding flag
        isAIResponding = false;
        
        // Transform back to send button
        transformToSendButton();
      }
      
      // Stop agent workflow and reset everything
      function stopAgentWorkflow() {
        // Clear all pending timeouts
        pendingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
        pendingTimeouts = [];
        
        // Clear pending agent code requests to prevent race condition
        if (window.pendingAgentCodeRequest) {
          window.pendingAgentCodeRequest = null;
        }
        
        // Clear streaming timeout
        if (streamingTimeout) {
          clearTimeout(streamingTimeout);
          streamingTimeout = null;
        }
        
        // Set stop flag before clearing workflow
        if (currentAgentWorkflow) {
          currentAgentWorkflow.stopped = true;
          
          // Send stop message to backend
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              action: 'stop_agent',
              message: 'User requested to stop the agent workflow'
            }));
          }
          
          currentAgentWorkflow = null;
          agentResults = [];
          agentCodes = [];
          currentStepCode = null;
        }
        
        // Reset agent type flags
        window.currentActiveAgentType = null;
        window.completedAgentType = null;
        window.isAgentFinalCode = false;
        
        // Reset custom analysis flags
        window.customStatisticalAnalysisInProgress = false;
        window.customTransformationInProgress = false;
        
        // Reset streaming state
        currentStreamingMessage = null;
        
        // Reset cleaning code state
        cleaningCodeExecuting = false;
        cleaningCodeIterationCount = 0;
        
        // Show stopped message
        addMessage('**Agent Stopped** - Workflow interrupted by user.', 'ai');
        
        // Reset AI responding flag
        isAIResponding = false;
        
        // Transform back to send button
        transformToSendButton();
      }
      
      function addStreamingChunk(chunk) {
        if (!currentStreamingMessage) {
          // Remove all animated placeholders when streaming starts
          removeAnimatedPlaceholder("ai-thinking");
          removeAnimatedPlaceholder("ai-debugging");
          removeAnimatedPlaceholder("ai-generating-code");
          removeAnimatedPlaceholder("ai-analyzing-statistical");
          removeAnimatedPlaceholder("ai-analyzing-transformation");
          removeAnimatedPlaceholder("ai-analyzing-cleaning");
          removeAnimatedPlaceholder("ai-analyzing-modeling");
          removeAnimatedPlaceholder("ai-analyzing-results");
          
          console.log(' Streaming started');
          
          // Start new streaming message with streaming class
          currentStreamingMessage = document.createElement("div");
          currentStreamingMessage.className = "message ai-message streaming";
          
          // Create content container and cursor
          const contentSpan = document.createElement("span");
          contentSpan.className = "streaming-content";
          const cursor = document.createElement("span");
          cursor.className = "streaming-cursor";
          
          currentStreamingMessage.appendChild(contentSpan);
          currentStreamingMessage.appendChild(cursor);
          document.getElementById("chat-container").appendChild(currentStreamingMessage);
          
          // Store raw text content for incremental formatting
          currentStreamingMessage._rawText = "";
          currentStreamingMessage._lastRenderedLength = 0;
          
          // Set AI responding flag when streaming starts
          isAIResponding = true;
        }
        
        // Accumulate raw text content
        currentStreamingMessage._rawText += chunk;
        
        // Apply smart streaming formatting (ChatGPT/Gemini style)
        applySmartStreamingFormat(currentStreamingMessage);
        
        // Scroll to bottom smoothly
        const container = document.getElementById("chat-container");
        container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
        
        // Clear any existing timeout
        if (streamingTimeout) {
          clearTimeout(streamingTimeout);
        }
        
        // Set timeout to finish streaming if no more chunks
        streamingTimeout = setTimeout(() => {
          finishStreaming();
        }, 1000);
      }
      
      // Progressive streaming formatter - formats as content streams (like ChatGPT/Gemini)
      function applySmartStreamingFormat(messageDiv) {
        const rawContent = messageDiv._rawText || '';
        if (!rawContent) return;
        
        const contentSpan = messageDiv.querySelector('.streaming-content');
        if (!contentSpan) return;
        
        // Parse content into segments (text, code blocks, etc.)
        const segments = parseStreamingContent(rawContent);
        
        // Render each segment with appropriate formatting
        let html = '';
        segments.forEach((segment, index) => {
          html += renderStreamingSegment(segment);
        });
        
        // Clean up excessive breaks around block elements (code blocks, lists, etc.)
        // Code blocks have margin: 15px 0, so remove breaks before/after them
        html = html.replace(/(<br>){2,}(<div[^>]*class="code-block")/g, '<br>$2');
        html = html.replace(/(<\/div><\/div>)(<br>){2,}/g, '$1<br>');
        // Lists have margin-bottom, so remove breaks between consecutive list items
        html = html.replace(/(<\/div>)(<br>)+(<div[^>]*style="margin-left: 20px[^"]*">)/g, '$1$3');
        // Remove excessive breaks after lists when followed by code blocks
        html = html.replace(/(<\/div>)(<br>){2,}(<div[^>]*class="code-block")/g, '$1<br>$3');
        // Remove excessive breaks after code blocks when followed by lists
        html = html.replace(/(<\/div><\/div>)(<br>){2,}(<div[^>]*style="margin-left: 20px[^"]*">)/g, '$1<br>$3');
        
        // Update content
        contentSpan.innerHTML = html;
        
        // Move cursor to the right position
        const cursor = messageDiv.querySelector('.streaming-cursor');
        if (cursor) {
          // If last segment is incomplete, cursor is already in the right place
          // Otherwise, move it after the content
          const lastSegment = segments[segments.length - 1];
          if (!lastSegment || lastSegment.complete !== false) {
            // All segments complete, move cursor to end
            messageDiv.appendChild(cursor);
          }
        }
      }
      
      // Parse raw text into structured segments for rendering
      function parseStreamingContent(text) {
        const segments = [];
        let remaining = text;
        let pos = 0;
        
        while (pos < remaining.length) {
          // Check for code block start
          if (remaining.substring(pos).startsWith('```')) {
            // Find the end of code block
            const afterOpening = remaining.indexOf('\n', pos);
            let lang = afterOpening > pos ? remaining.substring(pos + 3, afterOpening).trim() : '';
            
            // Handle {r} or {R} format
            if (lang.startsWith('{') && lang.includes('}')) {
              lang = lang.replace(/\{([rR])\}/, '$1');
            }
            
            const closePos = remaining.indexOf('```', pos + 3);
            
            if (closePos !== -1) {
              // Complete code block
              const codeStart = afterOpening !== -1 && afterOpening < closePos ? afterOpening + 1 : pos + 3 + lang.length;
              const code = remaining.substring(codeStart, closePos);
              // Only treat as R if explicitly marked as r/R/{r}/{R}, otherwise keep original lang
              const isRLang = /^[rR]$|^\{[rR]\}$/.test(lang);
              const normalizedLang = isRLang ? 'r' : lang;
              segments.push({ type: 'code-block', lang: normalizedLang, content: code, complete: true });
              pos = closePos + 3;
            } else {
              // Incomplete code block (still being typed)
              const codeStart = afterOpening !== -1 ? afterOpening + 1 : pos + 3;
              const code = remaining.substring(codeStart);
              // Only treat as R if explicitly marked as r/R/{r}/{R}, otherwise keep original lang
              const isRLang = /^[rR]$|^\{[rR]\}$/.test(lang);
              const normalizedLang = isRLang ? 'r' : lang;
              segments.push({ type: 'code-block', lang: normalizedLang, content: code, complete: false });
              pos = remaining.length;
            }
            continue;
          }
          
          // Find the next special element
          let nextSpecial = remaining.length;
          let specialType = null;
          
          // Check for code block
          const codeBlockStart = remaining.indexOf('```', pos);
          if (codeBlockStart !== -1 && codeBlockStart < nextSpecial) {
            nextSpecial = codeBlockStart;
            specialType = 'code-block';
          }
          
          // Extract text segment up to next special element
          if (nextSpecial > pos) {
            const textSegment = remaining.substring(pos, nextSpecial);
            segments.push({ type: 'text', content: textSegment });
            pos = nextSpecial;
          }
          
          // If no special element found, we're done
          if (specialType === null && pos >= remaining.length) break;
        }
        
        return segments;
      }
      
      // Render a single segment with appropriate formatting
      function renderStreamingSegment(segment) {
        if (segment.type === 'code-block') {
          return renderStreamingCodeBlock(segment);
        }
        return renderStreamingText(segment.content);
      }
      
      // Render code block with proper styling during streaming
      // MUST match the exact format that processMessageContent creates to avoid visual jump
      function renderStreamingCodeBlock(segment) {
        // Create the exact same DOM structure as processMessageContent
        const codeDiv = document.createElement("div");
        codeDiv.className = "code-block";
        
        // Determine if this is R code (only if explicitly marked)
        const isRCode = segment.lang === 'r';
        
        // Create header
        const headerDiv = document.createElement("div");
        headerDiv.className = "code-block-header";
        
        const languageLabel = document.createElement("span");
        // Show appropriate label based on language
        if (isRCode) {
          languageLabel.textContent = "R Code";
        } else if (segment.lang) {
          languageLabel.textContent = segment.lang.charAt(0).toUpperCase() + segment.lang.slice(1);
        } else {
          languageLabel.textContent = "Output";
        }
        
        const actionsDiv = document.createElement("div");
        actionsDiv.className = "code-block-actions";
        
        const streamingLabel = document.createElement("span");
        streamingLabel.style.color = "var(--text-secondary)";
        streamingLabel.style.fontSize = "11px";
        streamingLabel.textContent = "streaming...";
        actionsDiv.appendChild(streamingLabel);
        
        headerDiv.appendChild(languageLabel);
        headerDiv.appendChild(actionsDiv);
        codeDiv.appendChild(headerDiv);
        
        // Create code content div - EXACTLY like processMessageContent
        const codeContent = document.createElement("div");
        codeContent.textContent = segment.content; // Use textContent, not innerHTML!
        codeDiv.appendChild(codeContent);
        
        // Add cursor if incomplete
        if (!segment.complete) {
          const cursor = document.createElement("span");
          cursor.className = "streaming-cursor";
          codeContent.appendChild(cursor);
        }
        
        return codeDiv.outerHTML;
      }
      
      // Render text with markdown formatting during streaming
      // ChatGPT-style: Tables FIRST, then inline formatting inside cells
      function renderStreamingText(text) {
        if (!text) return '';
        
        
        let result = text;
        
        // 1. TABLES FIRST (before inline formatting breaks the structure)
        const beforeTable = result;
        result = formatStreamingTablesWithInlineFormatting(result);
        
        
        // 2. INLINE FORMATTING (for non-table content)
        
        // Bold: **text** - only complete pairs
        result = result.replace(/\*\*([^*]+?)\*\*/g, (match, content) => {
          const escaped = escapeHtmlForStreaming(content);
          return `<strong>${escaped}</strong>`;
        });
        
        // Italic: *text* - only complete pairs, not adjacent to **
        result = result.replace(/(?<!\*)\*([^*\n]+?)\*(?!\*)/g, (match, content) => {
          const escaped = escapeHtmlForStreaming(content);
          return `<em>${escaped}</em>`;
        });
        
        // Inline code: `code` - only complete pairs
        result = result.replace(/`([^`\n]+?)`/g, (match, content) => {
          const escaped = escapeHtmlForStreaming(content);
          return `<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">${escaped}</code>`;
        });
        
        // 3. BLOCK FORMATTING
        
        // Headers - must start at beginning of line (can contain inline formatting)
        result = result.replace(/^### (.+)$/gm, (match, content) => {
          return `<h3 style="margin: 12px 0 6px 0; font-size: 1.1em; font-weight: 600;">${content}</h3>`;
        });
        result = result.replace(/^## (.+)$/gm, (match, content) => {
          return `<h2 style="margin: 14px 0 8px 0; font-size: 1.2em; font-weight: 600;">${content}</h2>`;
        });
        result = result.replace(/^# (.+)$/gm, (match, content) => {
          return `<h1 style="margin: 16px 0 10px 0; font-size: 1.3em; font-weight: 600;">${content}</h1>`;
        });
        
        // Horizontal rule
        result = result.replace(/^---+$/gm, '<hr style="border: none; border-top: 1px solid var(--border-color); margin: 12px 0;">');
        
        // Numbered lists (can contain inline formatting)
        result = result.replace(/^(\d+)\.\s+(.+)$/gm, (match, num, content) => {
          return `<div style="margin-left: 20px; margin-bottom: 2px;"><strong>${num}.</strong> ${content}</div>`;
        });
        
        // Bullet points (can contain inline formatting)
        result = result.replace(/^[-*]\s+(.+)$/gm, (match, content) => {
          return `<div style="margin-left: 20px; margin-bottom: 2px;"> ${content}</div>`;
        });
        
        // Convert multiple newlines to single break (reduce gaps)
        result = result.replace(/\n{3,}/g, '\n\n');
        
        // Convert newlines to breaks
        result = result.replace(/\n/g, '<br>');
        
        // Clean up excessive breaks
        result = result.replace(/(<br>){3,}/g, '<br><br>');
        
        // Reduce multiple breaks to single break before/after headers (headers have their own top/bottom spacing)
        result = result.replace(/(<br>){2,}(<h[1-6][^>]*>)/g, '<br>$2');
        result = result.replace(/(<\/h[1-6]>)(<br>){2,}/g, '$1<br>');
        
        // Reduce multiple breaks to single break before/after horizontal rules
        result = result.replace(/(<br>){2,}(<hr[^>]*>)/g, '<br>$2');
        result = result.replace(/(<\/hr>)(<br>){2,}/g, '$1<br>');
        
        // Reduce multiple breaks to single break before/after tables
        result = result.replace(/(<br>){2,}(<div[^>]*><table)/g, '<br>$2');
        result = result.replace(/(<\/table><\/div>)(<br>){2,}/g, '$1<br>');
        
        // Reduce multiple breaks to single break before lists (keep one for spacing from text above)
        result = result.replace(/(<br>){2,}(<div[^>]*style="margin-left: 20px[^"]*">)/g, '<br>$2');
        // Remove ALL breaks between consecutive list items (they have margin-bottom)
        result = result.replace(/(<\/div>)(<br>)+(<div[^>]*style="margin-left: 20px[^"]*">)/g, '$1$3');
        // Reduce multiple breaks to single break after list items when followed by other block elements
        result = result.replace(/(<\/div>)(<br>){2,}(<h[1-6][^>]*>)/g, '$1<br>$3');
        result = result.replace(/(<\/div>)(<br>){2,}(<hr[^>]*>)/g, '$1<br>$3');
        result = result.replace(/(<\/div>)(<br>){2,}(<div[^>]*><table)/g, '$1<br>$3');
        // Reduce multiple breaks after any closing div (handles list items and other block elements)
        // This catches breaks after the last item in a list before regular text
        result = result.replace(/(<\/div>)(<br>){2,}(?!<[hH]|<[hH][rR]|<div|<table)/g, '$1<br>');
        
        
        return result;
      }
      
      // Format tables with inline formatting support
      function formatStreamingTablesWithInlineFormatting(text) {
        // If text already contains <table tags, skip processing to avoid re-processing
        if (text.includes('<table')) {
          return text;
        }
        
        // Split text by <table> tags - only process parts that aren't already formatted
        const parts = [];
        let lastIndex = 0;
        // Match our formatted tables: <div style="overflow-x: auto; margin: 10px 0;"><table>...</table></div>
        const tableTagRegex = /<div[^>]*style="overflow-x: auto[^"]*"[^>]*>\s*<table[^>]*>[\s\S]*?<\/table>\s*<\/div>/gi;
        let match;
        
        while ((match = tableTagRegex.exec(text)) !== null) {
          // Add text before the table tag
          if (match.index > lastIndex) {
            parts.push({
              text: text.substring(lastIndex, match.index),
              isFormatted: false
            });
          }
          // Add the formatted table
          parts.push({
            text: match[0],
            isFormatted: true
          });
          lastIndex = match.index + match[0].length;
        }
        
        // Add remaining text
        if (lastIndex < text.length) {
          parts.push({
            text: text.substring(lastIndex),
            isFormatted: false
          });
        }
        
        // Process only unformatted parts
        const processedParts = parts.map(part => {
          if (part.isFormatted) {
            return part.text; // Already formatted, return as-is
          }
          
          // Process markdown tables in this part
          // Regex: header row, separator (any dashes/pipes/colons), data rows
          // Fixed: separator pattern now correctly matches multi-column tables like |---|---|
          const tableRegex = /(\|[^\n]+\|)\s*\n\s*(\|[\s\-:]+(?:\|[\s\-:]+)*\|)\s*\n\s*((?:\|[^\n]+\|\s*\n?)+)/g;
          return part.text.replace(tableRegex, (match, headerRow, separatorRow, dataRows) => {
            // Parse header
            const headers = headerRow.split('|').map(h => h.trim()).filter(h => h.length > 0);
            if (headers.length === 0) return match;
            
            // Parse data rows
            const rows = dataRows.trim().split('\n').filter(r => r.includes('|'));
            
            // Build table HTML
            let html = '<div style="overflow-x: auto; margin: 10px 0;"><table style="border-collapse: collapse; width: 100%; font-size: 0.9em;">';
            
            // Header
            html += '<thead><tr>';
            headers.forEach(h => {
              const formatted = formatTableCell(h);
              html += `<th style="border: 1px solid var(--border-color); padding: 6px 10px; text-align: left; background: var(--bg-secondary); font-weight: 600;">${formatted}</th>`;
            });
            html += '</tr></thead>';
            
            // Body
            html += '<tbody>';
            rows.forEach(row => {
              const cells = row.split('|').map(c => c.trim()).filter((c, i, arr) => i > 0 && i < arr.length - 1 || c.length > 0);
              if (cells[0] === '') cells.shift();
              if (cells[cells.length - 1] === '') cells.pop();
              
              if (cells.length > 0) {
                html += '<tr>';
                cells.forEach(cell => {
                  const formatted = formatTableCell(cell);
                  html += `<td style="border: 1px solid var(--border-color); padding: 6px 10px;">${formatted}</td>`;
                });
                html += '</tr>';
              }
            });
            html += '</tbody></table></div>';
            
            return html;
          });
        });
        
        return processedParts.join('');
      }
      
      // Format a table cell with inline markdown
      function formatTableCell(cell) {
        let result = cell;
        
        // Apply inline formatting to cell content
        // Bold: **text**
        result = result.replace(/\*\*([^*]+?)\*\*/g, (match, content) => {
          const escaped = escapeHtmlForStreaming(content);
          return `<strong>${escaped}</strong>`;
        });
        
        // Italic: *text*
        result = result.replace(/(?<!\*)\*([^*\n]+?)\*(?!\*)/g, (match, content) => {
          const escaped = escapeHtmlForStreaming(content);
          return `<em>${escaped}</em>`;
        });
        
        // Inline code: `code`
        result = result.replace(/`([^`\n]+?)`/g, (match, content) => {
          const escaped = escapeHtmlForStreaming(content);
          return `<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">${escaped}</code>`;
        });
        
        // If nothing was formatted, escape the whole thing
        if (!result.includes('<')) {
          result = escapeHtmlForStreaming(result);
        }
        
        return result;
      }
      
      
      
      // Escape HTML for streaming display
      function escapeHtmlForStreaming(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // Legacy function - kept for compatibility
      function applyStreamingFormatting(messageDiv) {
        applySmartStreamingFormat(messageDiv);
      }
      
      // Add Copy/Insert buttons to already-formatted code blocks
      function addCopyInsertButtonsToCodeBlocks(messageDiv, rawContent) {
        // Find all code blocks in the message
        const codeBlocks = messageDiv.querySelectorAll('.code-block');
        
        // Extract code blocks with their language info from raw content
        const codeBlockRegex = /```(\{?[rR]\}?|[a-zA-Z]*)?[\s\n]*([\s\S]*?)```/g;
        const codeInfos = [];
        let match;
        while ((match = codeBlockRegex.exec(rawContent)) !== null) {
          let lang = (match[1] || '').trim();
          let code = match[2];
          // Check if this is R code (r, R, {r}, {R})
          const isRCode = /^[rR]$|^\{[rR]\}$/.test(lang);
          // Clean up the code
          code = code.replace(/^\{[rR]\}\s*\n?/, '').replace(/^[rR]\s+/, '').trim();
          codeInfos.push({ code, isRCode });
        }
        
        codeBlocks.forEach((codeBlock, index) => {
          const header = codeBlock.querySelector('.code-block-header');
          if (!header) return;
          
          let actionsDiv = header.querySelector('.code-block-actions');
          if (!actionsDiv) {
            actionsDiv = document.createElement('div');
            actionsDiv.className = 'code-block-actions';
            header.appendChild(actionsDiv);
          }
          
          // Clear existing content (like "streaming..." label)
          actionsDiv.innerHTML = '';
          
          // Get the code and language info for this block
          const codeInfo = codeInfos[index] || { code: codeBlock.textContent || '', isRCode: false };
          const cleanCode = codeInfo.code;
          const isRCode = codeInfo.isRCode;
          
          const copyButton = document.createElement("button");
          copyButton.className = "copy-button";
          copyButton.textContent = "Copy";
          copyButton.onclick = function() {
            copyToClipboard(cleanCode, copyButton);
          };
          
          actionsDiv.appendChild(copyButton);
          
          // Only add Insert button for R code blocks
          if (isRCode) {
            const insertButton = document.createElement("button");
            insertButton.className = "copy-button";
            insertButton.textContent = "Insert at Cursor";
            insertButton.onclick = function() {
              insertCode(cleanCode);
            };
            actionsDiv.appendChild(insertButton);
          }
        });
      }
      
      // Convert streaming raw text to final HTML format
      // Preserves newlines inside code blocks, converts to <br> outside
      function convertStreamingToFinalFormat(rawContent) {
        if (!rawContent) return '';
        
        let result = '';
        let pos = 0;
        
        // Find all code blocks and process them separately
        const codeBlockRegex = /```(\w*)\n?([\s\S]*?)```/g;
        let match;
        let lastIndex = 0;
        
        while ((match = codeBlockRegex.exec(rawContent)) !== null) {
          // Process text before this code block
          const textBefore = rawContent.substring(lastIndex, match.index);
          result += escapeAndFormatText(textBefore);
          
          // Add code block marker that processMessageContent can detect
          // Use a special format that preserves the structure
          const lang = match[1] || 'r';
          const code = match[2];
          // Keep code blocks in markdown format for processMessageContent to handle
          result += '```' + lang + '\n' + code + '```';
          
          lastIndex = match.index + match[0].length;
        }
        
        // Process remaining text after last code block
        if (lastIndex < rawContent.length) {
          const textAfter = rawContent.substring(lastIndex);
          result += escapeAndFormatText(textAfter);
        }
        
        return result;
      }
      
      // Escape HTML and convert newlines to <br> for non-code text
      function escapeAndFormatText(text) {
        if (!text) return '';
        
        // Escape HTML special characters
        const div = document.createElement('div');
        div.textContent = text;
        let escaped = div.innerHTML;
        
        // Convert newlines to <br>
        escaped = escaped.replace(/\n/g, '<br>');
        
        return escaped;
      }
      
      function applyBasicFormatting(messageDiv) {
        // Legacy function - kept for compatibility
        applyStreamingFormatting(messageDiv);
      }
      
      function processMarkdownFormatting(messageDiv) {
        let content = messageDiv.innerHTML;
        
        // Process markdown formatting
        // Headers (must be processed before other formatting to avoid conflicts)
        content = content.replace(/^### (.*)$/gm, '<h3 style="margin-top: 16px; margin-bottom: 8px; font-size: 1.1em; font-weight: 600; color: var(--text-color);">$1</h3>');
        content = content.replace(/^## (.*)$/gm, '<h2 style="margin-top: 20px; margin-bottom: 12px; font-size: 1.3em; font-weight: 600; color: var(--text-color);">$1</h2>');
        content = content.replace(/^# (.*)$/gm, '<h1 style="margin-top: 24px; margin-bottom: 16px; font-size: 1.5em; font-weight: 600; color: var(--text-color);">$1</h1>');
        
        // Bold text
        content = content.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // Italic text
        content = content.replace(/\*(.*?)\*/g, '<em>$1</em>');
        
        // Numbered lists
        content = content.replace(/^(\d+\.\s+)(.*)$/gm, '<div style="margin-left: 20px; white-space: normal; word-wrap: break-word; word-break: normal; hyphens: none;"><strong>$1</strong>$2</div>');
        
        // Bullet points
        content = content.replace(/^[-*]\s+(.*)$/gm, '<div style="margin-left: 20px; white-space: normal; word-wrap: break-word; word-break: normal; hyphens: none;"> $1</div>');
        
        // Inline code (backticks) - must be processed before tables to avoid conflicts
        content = content.replace(/`([^`]+)`/g, '<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">$1</code>');
        
        // Markdown tables (must be processed before inline code to avoid conflicts)
        // Matches tables with format: | Header 1 | Header 2 |\n|--------|--------|\n| Cell 1 | Cell 2 |
        content = content.replace(/(\|[^\n]+\|\n(?:\|[\s\-:]+\|\n)?(?:\|[^\n]+\|\n?)+)/g, (match) => {
          const lines = match.trim().split('\n').filter(line => line.trim() && line.includes('|'));
          if (lines.length < 2) return match; // Need at least header and one data row
          
          // Check if second line is a separator (contains only dashes, colons, spaces, and pipes)
          const secondLine = lines[1].trim();
          const isSeparator = /^[\|\s\-:]+$/.test(secondLine);
          
          // Parse header (first line if separator exists, otherwise first line is header)
          const headerLine = lines[0];
          const headers = headerLine.split('|').map(h => h.trim()).filter(h => h.length > 0);
          
          if (headers.length === 0) return match; // Invalid table
          
          // Get data rows (skip header and separator if present)
          const dataStartIndex = isSeparator ? 2 : 1;
          const dataRows = lines.slice(dataStartIndex);
          
          // Build table HTML
          let tableHtml = '<div style="overflow-x: auto; margin: 16px 0;"><table style="border-collapse: collapse; width: 100%; max-width: 100%;">';
          
          // Header row
          tableHtml += '<thead><tr>';
          headers.forEach(header => {
            tableHtml += `<th style="border: 1px solid var(--border-color); padding: 8px 12px; text-align: left; background-color: var(--bg-secondary); font-weight: 600; white-space: nowrap;">${header}</th>`;
          });
          tableHtml += '</tr></thead>';
          
          // Data rows
          tableHtml += '<tbody>';
          dataRows.forEach(row => {
            const cells = row.split('|').map(c => c.trim());
            // Remove empty cells at start/end (from leading/trailing |)
            if (cells.length > 0 && cells[0] === '') cells.shift();
            if (cells.length > 0 && cells[cells.length - 1] === '') cells.pop();
            
            if (cells.length > 0) {
              tableHtml += '<tr>';
              // Match number of cells to headers (pad or truncate)
              const paddedCells = cells.slice(0, headers.length);
              while (paddedCells.length < headers.length) paddedCells.push('');
              
              paddedCells.forEach(cell => {
                tableHtml += `<td style="border: 1px solid var(--border-color); padding: 8px 12px;">${cell || '&nbsp;'}</td>`;
              });
              tableHtml += '</tr>';
            }
          });
          tableHtml += '</tbody></table></div>';
          
          return tableHtml;
        });
        
        // Inline code (but not code blocks) - only single backticks
        // Make sure we don't match triple backticks (```)
        content = content.replace(/(?<!`)`([^`]+)`(?!`)/g, '<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">$1</code>');
        
        messageDiv.innerHTML = content;
      }
      
      function finishStreaming() {
        // Check if operation was stopped
        if (operationStopped) {
          // Reset the flag for next operation
          operationStopped = false;
          return;
        }
        
        console.log(' Streaming complete');
        
        if (currentStreamingMessage) {
          // Remove streaming class and cursor
          currentStreamingMessage.classList.remove('streaming');
          const allCursors = currentStreamingMessage.querySelectorAll('.streaming-cursor');
          allCursors.forEach(c => c.remove());
          
          // Get raw text content for R code detection
          const rawContent = currentStreamingMessage._rawText || '';
          window.lastCompleteMessage = rawContent;
          
          // DON'T destroy the formatted HTML - just enhance it!
          // Remove "streaming..." text from code block headers
          const streamingLabels = currentStreamingMessage.querySelectorAll('.code-block-actions span');
          streamingLabels.forEach(label => {
            if (label.textContent.includes('streaming...')) {
              label.remove();
            }
          });
          
          // Add Copy/Insert buttons to code blocks
          addCopyInsertButtonsToCodeBlocks(currentStreamingMessage, rawContent);
          
          currentStreamingMessage = null;
        }
        
        // Clear custom analysis flags if they were set
        if (window.customStatisticalAnalysisInProgress) {
          console.log(' Custom statistical analysis completed, clearing flag');
          window.customStatisticalAnalysisInProgress = false;
        }
        if (window.customTransformationInProgress) {
          console.log(' Custom transformation completed, clearing flag');
          window.customTransformationInProgress = false;
        }
        
        if (streamingTimeout) {
          clearTimeout(streamingTimeout);
          streamingTimeout = null;
        }
        
        // Reset AI responding flag and transform button back (if not an agent workflow)
        if (isAIResponding && !currentAgentWorkflow) {
          isAIResponding = false;
          transformToSendButton();
        }
        
        // Reset stop flag when streaming completes normally
        operationStopped = false;
        
        // Check if there's a pending agent code request and send it
        if (window.pendingAgentCodeRequest) {
          console.log(' Sending pending agent code request...');
          const request = window.pendingAgentCodeRequest;
          
          // Helper function to escape template literal content
          const escapeTemplateLiteral = (str) => {
            if (!str) return '';
            return String(str)
              .replace(/\\/g, '\\\\')  // Escape backslashes first
              .replace(/`/g, '\\`')    // Escape backticks
              .replace(/\${/g, '\\${'); // Escape ${ sequences
          };
          
          // Add informative message to let user know code generation is starting
          const agentTypeDisplay = request.agentType.charAt(0).toUpperCase() + request.agentType.slice(1);
          createAnimatedPlaceholder("ai-generating-code", `**Generating ${agentTypeDisplay} Code** Now requesting executable R code based on the analysis above`);
          
          // Add a small delay to let user read the message before sending the code request
          const delayTimeout = setTimeout(() => {
            // Check again if request is still pending (user might have stopped/cleared it)
            if (!window.pendingAgentCodeRequest) {
              console.log(' Pending code request was cancelled, skipping');
              return;
            }
            let codeText = `Data ${escapeTemplateLiteral(request.operationType)} steps output:
${request.agentResults.map(result => `
${escapeTemplateLiteral(result.description)}:
${escapeTemplateLiteral(result.output)}
`).join('\n')}

Previous Claude chat summary:
[Your analysis above]

IMPORTANT: Use the EXACT methods selected by the user:`;

          if (request.agentType === 'modeling') {
            // Modeling agent specific instructions
            codeText += `\n\nModeling Configuration:
- Target Variable: ${request.currentAgentWorkflow?.targetVariable}
- Selected Algorithms: ${Object.entries(request.currentAgentWorkflow?.algorithms || {})
  .filter(([key, value]) => value)
  .map(([key, value]) => key)
  .join(', ')}

Provide R code to:
1. Train the selected models
2. Evaluate model performance
3. Generate predictions
4. Create visualizations for model interpretation

Code only. Minimal chat.`;
          } else if (request.agentType === 'statistical') {
            // Statistical agent specific instructions
            const selectedOps = [];
            if (request.currentAgentWorkflow?.analysisOptions?.basicStatistics) selectedOps.push('Basic Statistics & Distributions');
            if (request.currentAgentWorkflow?.analysisOptions?.groupComparisons) selectedOps.push('Group Comparisons');
            if (request.currentAgentWorkflow?.analysisOptions?.categoricalTests) selectedOps.push('Categorical Tests');
            if (request.currentAgentWorkflow?.analysisOptions?.beforeAfterAnalysis) selectedOps.push('Before/After Analysis');
            if (request.currentAgentWorkflow?.analysisOptions?.effectSizeAnalysis) selectedOps.push('Effect Size Analysis');
            if (request.currentAgentWorkflow?.analysisOptions?.powerAnalysis) selectedOps.push('Power Analysis');
            if (request.currentAgentWorkflow?.analysisOptions?.multipleTestingCorrection) selectedOps.push('Multiple Testing Correction');
            
            codeText += `\n\nStatistical Analysis Configuration:
- Dataset: ${request.currentAgentWorkflow?.dataframe}
- Selected Operations: ${selectedOps.join(', ')}

Provide R code to:
1. Reproduce the statistical analyses shown above
2. Create informative visualizations (histograms, boxplots, qq-plots, etc.)
3. Generate summary tables and reports
4. Save key results as variables for further use

Include comments explaining each step. Code only. Minimal chat.`;
          } else if (request.agentType === 'transformation') {
            // Transformation agent specific instructions
            const selectedOps = [];
            if (request.currentAgentWorkflow?.transformationOptions?.dataTypes) selectedOps.push('Data Types');
            if (request.currentAgentWorkflow?.transformationOptions?.missingValues) selectedOps.push('Missing Values');
            if (request.currentAgentWorkflow?.transformationOptions?.duplicates) selectedOps.push('Duplicates');
            if (request.currentAgentWorkflow?.transformationOptions?.outliers) selectedOps.push('Outliers');
            if (request.currentAgentWorkflow?.transformationOptions?.columnNames) selectedOps.push('Column Names');
            if (request.currentAgentWorkflow?.transformationOptions?.mathematicalTransformations) selectedOps.push('Mathematical Transformations');
            if (request.currentAgentWorkflow?.transformationOptions?.mergingCombining) selectedOps.push('Merging & Combining');
            if (request.currentAgentWorkflow?.transformationOptions?.aggregationGrouping) selectedOps.push('Aggregation & Grouping');
            if (request.currentAgentWorkflow?.transformationOptions?.statisticalTransformations) selectedOps.push('Statistical Transformations');
            if (request.currentAgentWorkflow?.transformationOptions?.textTransformations) selectedOps.push('Text Transformations');
            if (request.currentAgentWorkflow?.transformationOptions?.spatialTransformations) selectedOps.push('Spatial Transformations');
            if (request.currentAgentWorkflow?.transformationOptions?.customTransformations) selectedOps.push('Custom Transformations');
            
            codeText += `\n\nData Transformation Configuration:
- Dataset: ${request.currentAgentWorkflow?.dataframe}
- Selected Operations: ${selectedOps.join(', ')}

Provide R code to:
1. Apply the data transformations shown above
2. Create a cleaned/transformed version of the dataset
3. Generate data quality reports and summaries
4. Save the transformed dataset with a clear name (e.g., ${request.currentAgentWorkflow?.dataframe}_transformed)

Include comments explaining each transformation step. Code only. Minimal chat.`;
          } else if (request.agentType === 'cleaning') {
            // Data cleaning agent specific instructions
            const selectedOps = [];
            const cleaningOptions = request.currentAgentWorkflow?.cleaningOptions || {};
            const methodOptions = request.currentAgentWorkflow?.methodOptions || {};
            
            if (cleaningOptions.dataTypes) selectedOps.push('Data Types');
            if (cleaningOptions.missingValues) {
              const method = methodOptions.missingValues || 'dont';
              selectedOps.push(`Missing Values (${method})`);
            }
            if (cleaningOptions.duplicates) selectedOps.push('Duplicates');
            if (cleaningOptions.outliers) {
              const method = methodOptions.outliers || 'iqr';
              selectedOps.push(`Outliers (${method})`);
            }
            if (cleaningOptions.columnNames) {
              const method = methodOptions.columnNames || 'snake_case';
              selectedOps.push(`Column Names (${method})`);
            }
            
            codeText += `\n\nData Cleaning Configuration:
- Dataset: ${request.currentAgentWorkflow?.dataframe}
- Selected Operations: ${selectedOps.join(', ')}

Provide R code to ONLY perform the selected operations listed above. Do not include operations that were not selected.

Guidelines:
1. If no issues were found (e.g., no missing values, no outliers), return a simple confirmation message instead of unnecessary code
2. Create a cleaned version only if actual cleaning was performed
3. Include comments explaining each step
4. Code only. Minimal chat.`;
          } else if (request.agentType === 'modeling') {
            // Modeling agent specific instructions
            const selectedAlgos = [];
            const algorithms = request.currentAgentWorkflow?.algorithms || {};
            
            if (algorithms.linearRegression) selectedAlgos.push('Linear Regression');
            if (algorithms.logisticRegression) selectedAlgos.push('Logistic Regression');
            if (algorithms.decisionTrees) selectedAlgos.push('Decision Trees');
            if (algorithms.randomForest) selectedAlgos.push('Random Forest');
            if (algorithms.svm) selectedAlgos.push('SVM');
            if (algorithms.knn) selectedAlgos.push('K-NN');
            if (algorithms.naiveBayes) selectedAlgos.push('Naive Bayes');
            if (algorithms.clustering) selectedAlgos.push('Clustering');
            if (algorithms.dimensionalityReduction) selectedAlgos.push('Dimensionality Reduction');
            
            codeText += `\n\nModeling Configuration:
- Dataset: ${request.currentAgentWorkflow?.dataframe}
- Target Variable: ${request.currentAgentWorkflow?.targetVariable || 'auto-detected'}
- Selected Algorithms: ${selectedAlgos.join(', ')}

Provide R code to:
1. Build and train the selected models
2. Evaluate model performance with appropriate metrics
3. Generate visualizations (confusion matrix, ROC curves, feature importance, etc.)
4. Compare models and recommend the best approach

Include comments explaining each step. Code only. Minimal chat.`;
          } else {
            // Unknown agent type - generic instructions
            codeText += `\n\nProvide R code based on the analysis results above. Code only. Minimal chat.`;
          }
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            // Set AI responding flag for the second message
            isAIResponding = true;
            
            // Mark that this is agent-generated final code
            window.isAgentFinalCode = true;
            
            ws.send(JSON.stringify({
              action: 'chat_with_ai',
              message: codeText,
              conversation_context: `data_${request.agentType}_agent_code`
            }));
          }
          
            // Clear the pending request
            window.pendingAgentCodeRequest = null;
            
            // Don't reset the button yet - wait for the second response to complete
          }, 1500); // Wait 1.5 seconds for user to read the message
          
          // Store timeout so it can be cleared if needed
          pendingTimeouts.push(delayTimeout);
          
          return;
        }
        
        // Transform stop button back to send button when streaming finishes
        if (isAIResponding) {
          transformToSendButton();
        }
      }
      
      // Dynamic resize function for chat container
      function resizeChatContainer() {
        const chatContainer = document.getElementById("chat-container");
        if (chatContainer) {
          const viewportHeight = window.innerHeight;
          const availableHeight = viewportHeight - 250; // Account for header, input, margins
          chatContainer.style.height = Math.max(250, Math.min(availableHeight, viewportHeight * 0.6)) + "px";
        }
      }
      
      // Add resize listener
      window.addEventListener('resize', resizeChatContainer);
      
      // Initial resize
      document.addEventListener('DOMContentLoaded', resizeChatContainer);
      

      
      function processMessageContent(messageDiv) {
        let rawContent = messageDiv.innerHTML;
        
        // Decode HTML entities (backticks might be encoded)
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawContent;
        let decodedContent = tempDiv.textContent || tempDiv.innerText || rawContent;
        
        // Check both raw and decoded for code blocks
        // More flexible regex: handles ```r, ```R, ```{r}, ```{R}, or plain ``` (no language specified)
        // Also handles variations with/without newlines and whitespace
        const rawRegex = /```(?:\s*[rR]|\s*\{[rR]\}|\s*[a-zA-Z]*)?[\s\S]*?```/i;
        const decodedRegex = /```(?:\s*[rR]|\s*\{[rR]\}|\s*[a-zA-Z]*)?[\s\S]*?```/i;
        
        const rawHasCodeBlock = rawRegex.test(rawContent);
        const decodedHasCodeBlock = decodedRegex.test(decodedContent);
        
        // Use whichever content has the code blocks
        const content = rawHasCodeBlock ? rawContent : decodedContent;
        const hasMarkdownCodeBlock = rawHasCodeBlock || decodedHasCodeBlock;
        // Only detect HTML code blocks that are actual blocks, not inline code
        const hasHTMLCodeBlock = /<code[^>]*>[\s\S]*?<\/code>/.test(content) && 
                                !content.includes('<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">');
        
        if (hasMarkdownCodeBlock || hasHTMLCodeBlock) {
          // Clear the message div
          messageDiv.innerHTML = "";
          
          // Split by markdown code blocks - handles both with and without newline after r/R
          // This regex matches: ```r, ```R, ```r\n, ```R\n, ```{r}, ```{R}, ```{r}\n, ```{R}\n, or plain ``` followed by content and closing ```
          // Match: ``` followed by optional language identifier (r/R/{r}/{R}/other), optionally followed by newline or whitespace, then content, then closing ```
          const splitRegex = /(```(?:\s*[rR]|\s*\{[rR]\}|\s*[a-zA-Z]*)?(?:\n|\s)*[\s\S]*?```)/gi;
          let parts = content.split(splitRegex);
          
          // If no markdown blocks found, try HTML code blocks
          if (parts.length === 1) {
            parts = content.split(/(<code[^>]*>[\s\S]*?<\/code>)/g);
          }
          
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            
            // Check if this is an R code block specifically
            const isRCodeBlock = (part.startsWith("```{r}") || part.startsWith("```{R}") ||
                                part.startsWith("```{r}\n") || part.startsWith("```{R}\n") ||
                                part.startsWith("```{r} ") || part.startsWith("```{R} ") ||
                                part.startsWith("```r\n") || part.startsWith("```R\n") ||
                                part.startsWith("```r ") || part.startsWith("```R ") ||
                                (part.startsWith("```r") && part.endsWith("```")) ||
                                (part.startsWith("```R") && part.endsWith("```")));
            
            // Check if this is any code block (including non-R)
            const isCodeBlock = isRCodeBlock ||
                                (part.startsWith("```") && part.endsWith("```") && part.length > 6) ||
                                (part.includes("<code") && part.includes("</code>"));
            
            if (isCodeBlock) {
              // This is a code block - style it
              const codeDiv = document.createElement("div");
              codeDiv.className = "code-block";
              
              // Create header with copy button
              const headerDiv = document.createElement("div");
              headerDiv.className = "code-block-header";
              
              const languageLabel = document.createElement("span");
              // Determine appropriate label
              if (isRCodeBlock) {
                languageLabel.textContent = "R Code";
              } else if (part.startsWith("```")) {
                // Extract language from ```language format
                const langMatch = part.match(/^```([a-zA-Z]+)/);
                if (langMatch && langMatch[1]) {
                  languageLabel.textContent = langMatch[1].charAt(0).toUpperCase() + langMatch[1].slice(1);
                } else {
                  languageLabel.textContent = "Output";
                }
              } else {
                languageLabel.textContent = "Code";
              }
              
              const actionsDiv = document.createElement("div");
              actionsDiv.className = "code-block-actions";
              
              const copyButton = document.createElement("button");
              copyButton.className = "copy-button";
              copyButton.textContent = "Copy";
              copyButton.onclick = function() {
                // Use the cleaned code for copying, not the original HTML
                copyToClipboard(cleanCode, copyButton);
              };
              
              headerDiv.appendChild(languageLabel);
              actionsDiv.appendChild(copyButton);
              
              // Only add Insert button for R code blocks
              if (isRCodeBlock) {
                const insertButton = document.createElement("button");
                insertButton.className = "copy-button";
                insertButton.textContent = "Insert at Cursor";
                insertButton.onclick = function() {
                  insertCode(cleanCode);
                };
                actionsDiv.appendChild(insertButton);
              }
              
              headerDiv.appendChild(actionsDiv);
              codeDiv.appendChild(headerDiv);
              
              // Create code content div - extract just the code
              const codeContent = document.createElement("div");
              let cleanCode;
              if (part.startsWith("```{r}") || part.startsWith("```{R}") || part.startsWith("```{r}\n") || part.startsWith("```{R}\n") || part.startsWith("```{r} ")) {
                // R Markdown format with curly braces - remove ```{r} or ```{R} (with optional newline/space) at start and ``` at end
                cleanCode = part.replace(/^```\{[rR]\}[\s\n]*/, "").replace(/```$/, "");
              } else if (part.startsWith("```r\n") || part.startsWith("```r ")) {
                // Markdown format - remove ```r\n or ```r  at start and ``` at end
                cleanCode = part.replace(/^```r[\s\n]+/, "").replace(/```$/, "");
              } else if (part.startsWith("```R\n") || part.startsWith("```R ")) {
                // Markdown format - remove ```R\n or ```R  at start and ``` at end
                cleanCode = part.replace(/^```R[\s\n]+/, "").replace(/```$/, "");
              } else if (part.startsWith("```r") && part.endsWith("```")) {
                // Markdown format without newline after r
                cleanCode = part.replace(/^```r/, "").replace(/```$/, "");
              } else if (part.startsWith("```R") && part.endsWith("```")) {
                // Markdown format without newline after R
                cleanCode = part.replace(/^```R/, "").replace(/```$/, "");
              } else if (part.startsWith("```") && part.endsWith("```")) {
                // Plain code block without language identifier - remove ``` at start and end
                // Also handle cases with language identifiers like ```python, ```javascript, etc.
                // Only remove language identifier if followed by whitespace/newline (not part of code)
                cleanCode = part.replace(/^```(?:[a-zA-Z]+[\s\n]+)?/, "").replace(/```$/, "");
              } else {
                // HTML format - extract clean text from nested HTML
                // Create a temporary div to parse HTML and extract text
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = part;
                cleanCode = tempDiv.textContent || tempDiv.innerText || '';
                
                // If that didn't work, try manual removal
                if (!cleanCode || cleanCode.trim() === '') {
                  cleanCode = part.replace(/<code[^>]*>/g, "").replace(/<\/code>/g, "");
                  cleanCode = cleanCode.replace(/<[^>]*>/g, "");
                  cleanCode = cleanCode.replace(/style="[^"]*"/g, "");
                }
              }
              
              // Remove any remaining artifacts like single quotes or language identifiers
              cleanCode = cleanCode.replace(/^['"]?r['"]?\s*/, ""); // Remove 'r', "r", or r at start
              cleanCode = cleanCode.replace(/^\s*['"]?r['"]?\s*/, ""); // Remove with whitespace
              
              // Remove any remaining "R" at the start
              cleanCode = cleanCode.replace(/^R\s*/, "");
              cleanCode = cleanCode.replace(/^r\s*/, "");
              
              // Remove {r} or {R} if it appears at the start (should have been removed but just in case)
              cleanCode = cleanCode.replace(/^\{[rR]\}\s*\n?/, "");
              cleanCode = cleanCode.replace(/^\s*\{[rR]\}\s*\n?/, "");
              
              // Decode HTML entities
              cleanCode = cleanCode.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
              
              codeContent.textContent = cleanCode;
              codeDiv.appendChild(codeContent);
              
              messageDiv.appendChild(codeDiv);
            } else if (part.trim()) {
              // This is regular text - clean up any leftover backticks and add it
              const textDiv = document.createElement("div");
              let cleanText = part;
              
              // Remove any leftover backticks from markdown processing
              cleanText = cleanText.replace(/^``\s*/, ""); // Remove leading backticks
              cleanText = cleanText.replace(/\s*``$/, ""); // Remove trailing backticks
              cleanText = cleanText.replace(/``/g, ""); // Remove any remaining backticks
              
              textDiv.innerHTML = cleanText;
              // Apply markdown formatting to the text part
              processMarkdownFormatting(textDiv);
              messageDiv.appendChild(textDiv);
            }
          }
          
          return;
        }
        
        console.log("DEBUG: No code blocks found, processing markdown");
        // If no code blocks, just process markdown formatting
        processMarkdownFormatting(messageDiv);
      }
      
      // Function to get welcome message with column names using existing get_dataframe_info pattern
      function generateWelcomeWithColumns(objects, objectsInfo) {
        console.log(' Welcome: generateWelcomeWithColumns called', { objects, objectsInfo });
        // First, identify dataframes
        const dataframes = [];
        objects.forEach(objName => {
          const objInfo = objectsInfo && objectsInfo[objName] ? objectsInfo[objName] : null;
          if (objInfo && objInfo.category === 'dataframe') {
            dataframes.push(objName);
          }
        });
        
        console.log(' Welcome: Found dataframes', dataframes);
        
        // Request column names for up to 3 dataframes using existing get_dataframe_info
        const selectedDataframes = dataframes.slice(0, 3);
        
        if (selectedDataframes.length === 0) {
          console.log(' Welcome: No dataframes found, generating simple welcome');
          // No dataframes, just generate welcome message
          const welcomeText = generatePersonalizedWelcome(objects, objectsInfo, {});
          typeMessage(welcomeText, "ai", 10);
          // Add to conversation history
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              action: "add_to_conversation_history",
              role: "ai",
              message: welcomeText
            }));
          }
          window.welcomeMessageShown = true;
          return;
        }
        
        console.log(' Welcome: Requesting column info for', selectedDataframes);
        
        // Store data for welcome message generation
        window.pendingWelcomeColumns = {
          count: selectedDataframes.length,
          received: 0,
          columnData: {},
          objects: objects,
          objectsInfo: objectsInfo
        };
        
        // Request column names for each dataframe using existing pattern
        selectedDataframes.forEach(dfName => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            console.log(` Welcome: Requesting get_dataframe_info for ${dfName}`);
            ws.send(JSON.stringify({
              action: "get_dataframe_info",
              dataframe: dfName
            }));
          }
        });
      }
      
      // Function to generate personalized welcome message based on available objects
      function generatePersonalizedWelcome(objects, objectsInfo, columnData = {}) {
        if (!objects || objects.length === 0) {
          return " Hi! I'm your RStudio AI assistant. I can help you write code, analyze data, create visualizations, debug errors, and more. What would you like to work on?";
        }
        
        // Categorize objects by type
        const dataframes = [];
        const lists = [];
        const vectors = [];
        const matrices = [];
        const otherObjects = [];
        
        objects.forEach(objName => {
          const objInfo = objectsInfo && objectsInfo[objName] ? objectsInfo[objName] : null;
          const category = objInfo ? objInfo.category : 'other';
          
          if (category === 'dataframe') {
            dataframes.push(objName);
          } else if (category === 'list') {
            lists.push(objName);
          } else if (category === 'vector') {
            vectors.push(objName);
          } else if (category === 'matrix') {
            matrices.push(objName);
          } else if (category !== 'function' && category !== 'environment') {
            otherObjects.push(objName);
          }
        });
        
        // Take up to 3 objects (prioritize dataframes, then lists, then others)
        const selectedObjects = [];
        const selectedCategories = [];
        
        if (dataframes.length > 0) {
          const count = Math.min(3, dataframes.length);
          selectedObjects.push(...dataframes.slice(0, count));
          selectedCategories.push(...new Array(count).fill('dataframe'));
        }
        if (selectedObjects.length < 3 && lists.length > 0) {
          const remaining = 3 - selectedObjects.length;
          const count = Math.min(remaining, lists.length);
          selectedObjects.push(...lists.slice(0, count));
          selectedCategories.push(...new Array(count).fill('list'));
        }
        if (selectedObjects.length < 3 && vectors.length > 0) {
          const remaining = 3 - selectedObjects.length;
          const count = Math.min(remaining, vectors.length);
          selectedObjects.push(...vectors.slice(0, count));
          selectedCategories.push(...new Array(count).fill('vector'));
        }
        if (selectedObjects.length < 3 && matrices.length > 0) {
          const remaining = 3 - selectedObjects.length;
          const count = Math.min(remaining, matrices.length);
          selectedObjects.push(...matrices.slice(0, count));
          selectedCategories.push(...new Array(count).fill('matrix'));
        }
        if (selectedObjects.length < 3 && otherObjects.length > 0) {
          const remaining = 3 - selectedObjects.length;
          const count = Math.min(remaining, otherObjects.length);
          selectedObjects.push(...otherObjects.slice(0, count));
          selectedCategories.push(...new Array(count).fill('other'));
        }
        
        // Count total objects (excluding functions and environments)
        const totalObjects = dataframes.length + lists.length + vectors.length + matrices.length + otherObjects.length;
        const hasMore = totalObjects > selectedObjects.length;
        
        // Determine what to call the collection
        const dataframeCount = dataframes.length;
        let collectionType = "objects";
        if (dataframeCount > 0) {
          if (dataframeCount === 1) {
            collectionType = "dataset";
          } else {
            collectionType = "datasets";
          }
        } else if (lists.length > 0 || vectors.length > 0 || matrices.length > 0) {
          collectionType = "data objects";
        }
        
        // Create message with bullet points
        if (selectedObjects.length === 0) {
          return " Hi! I'm your RStudio AI assistant. I can help you write code, analyze data, create visualizations, debug errors, and more. What would you like to work on?";
        } else {
          let message = ` Hi! I'm your RStudio AI assistant. I see you have a few ${collectionType}:\n\n`;
          
          // Add bullet points for selected objects with their types and sizes
          selectedObjects.forEach((objName, index) => {
            const category = selectedCategories[index];
            const objInfo = objectsInfo && objectsInfo[objName] ? objectsInfo[objName] : null;
            const sizeInfo = objInfo && objInfo.size_info ? objInfo.size_info : null;
            
            let typeLabel = '';
            let sizeLabel = '';
            
            if (category === 'dataframe') {
              typeLabel = ' (dataframe)';
              if (sizeInfo && sizeInfo.nrow !== undefined && sizeInfo.ncol !== undefined) {
                sizeLabel = ` - ${sizeInfo.nrow} rows  ${sizeInfo.ncol} columns`;
              }
              message += ` ${objName}${typeLabel}${sizeLabel}\n`;
              
              // Add column names as indented bullet points using existing pattern
              // Use columnData if available (from get_dataframe_info), otherwise try sizeInfo
              const columns = columnData && columnData[objName] ? columnData[objName] : null;
              
              if (columns) {
                // Get column names array and limit to 5
                let columnNames = [];
                if (Array.isArray(columns)) {
                  columnNames = columns.slice(0, 5);
                } else if (typeof columns === 'object') {
                  // If it's an object (column_info format), use keys
                  columnNames = Object.keys(columns).slice(0, 5);
                }
                
                // Add as indented bullet points (using 4 spaces - will be converted to &nbsp; in escapeHtml)
                columnNames.forEach(colName => {
                  message += `     ${colName}\n`;
                });
              }
            } else if (category === 'list') {
              typeLabel = ' (list)';
              if (sizeInfo && sizeInfo.length !== undefined) {
                sizeLabel = ` - length ${sizeInfo.length}`;
              }
              message += ` ${objName}${typeLabel}${sizeLabel}\n`;
            } else if (category === 'vector') {
              typeLabel = ' (vector)';
              if (sizeInfo && sizeInfo.length !== undefined) {
                sizeLabel = ` - length ${sizeInfo.length}`;
              }
              message += ` ${objName}${typeLabel}${sizeLabel}\n`;
            } else if (category === 'matrix') {
              typeLabel = ' (matrix)';
              if (sizeInfo && sizeInfo.nrow !== undefined && sizeInfo.ncol !== undefined) {
                sizeLabel = ` - ${sizeInfo.nrow} rows  ${sizeInfo.ncol} columns`;
              }
              message += ` ${objName}${typeLabel}${sizeLabel}\n`;
            } else {
              message += ` ${objName}${typeLabel}${sizeLabel}\n`;
            }
          });
          
          // Add "and more" as regular text if there are additional objects
          if (hasMore) {
            message += "\nand more\n";
          }
          
          message += "\nI can help you analyze them, create visualizations, debug errors, and more. What would you like to work on?";
          
          return message;
        }
      }
      
      // Function to escape HTML characters and preserve newlines
      function escapeHtml(text) {
        // First, preserve leading spaces before bullet points by converting them to a placeholder
        // We'll replace them back after HTML escaping
        const spacePlaceholder = '___SPACE___';
        let processedText = text.replace(/\n(\s+)()/g, function(match, spaces, bullet) {
          // Replace each space with placeholder
          return '\n' + spacePlaceholder.repeat(spaces.length) + bullet;
        });
        
        const div = document.createElement('div');
        div.textContent = processedText;
        // Convert newlines to <br> tags
        let html = div.innerHTML.replace(/\n/g, '<br>');
        // Replace placeholders with &nbsp;
        html = html.replace(new RegExp(spacePlaceholder, 'g'), '&nbsp;');
        return html;
      }
      
      // Function to type out a message character by character
      function typeMessage(content, role, speed = 20) {
        const container = document.getElementById("chat-container");
        const messageDiv = document.createElement("div");
        messageDiv.className = "message " + role + "-message";
        messageDiv.innerHTML = "";
        container.appendChild(messageDiv);
        
        let index = 0;
        const typeInterval = setInterval(() => {
          if (index < content.length) {
            // Escape HTML and preserve newlines
            const textSoFar = content.substring(0, index + 1);
            messageDiv.innerHTML = escapeHtml(textSoFar);
            index++;
            // Scroll to bottom as we type
            container.scrollTop = container.scrollHeight;
          } else {
            clearInterval(typeInterval);
            // After typing is complete, process markdown if it's an AI message
            if (role === "ai") {
              processMarkdownFormatting(messageDiv);
            }
          }
        }, speed);
      }
      
      function addMessage(content, role) {
        const container = document.getElementById("chat-container");
        const messageDiv = document.createElement("div");
        messageDiv.className = "message " + role + "-message";
        
        if (role === "ai") {
          // Check for output blocks first - format: @@output\n...content...\n@@
          // Process all output blocks in the message
          const outputBlockRegex = /@@output\n([\s\S]*?)\n@@/g;
          const outputMatches = [];
          let match;
          
          // Collect all output block matches
          while ((match = outputBlockRegex.exec(content)) !== null) {
            outputMatches.push({
              index: match.index,
              length: match[0].length,
              content: match[1]
            });
          }
          
          if (outputMatches.length > 0) {
            // Process content with output blocks
            let lastIndex = 0;
            
            outputMatches.forEach((outputMatch, idx) => {
              // Add text before this output block
              const beforeOutput = content.substring(lastIndex, outputMatch.index);
              if (beforeOutput.trim()) {
                const textDiv = document.createElement("div");
                textDiv.innerHTML = beforeOutput;
                processMarkdownFormatting(textDiv);
                messageDiv.appendChild(textDiv);
              }
              
              // Add output block
              const outputDiv = document.createElement("div");
              outputDiv.className = "output-block";
              
              // Create header
              const headerDiv = document.createElement("div");
              headerDiv.className = "output-block-header";
              const outputLabel = document.createElement("span");
              outputLabel.textContent = "Output";
              headerDiv.appendChild(outputLabel);
              outputDiv.appendChild(headerDiv);
              
              // Add output content
              const outputContentDiv = document.createElement("div");
              outputContentDiv.textContent = outputMatch.content;
              outputDiv.appendChild(outputContentDiv);
              
              messageDiv.appendChild(outputDiv);
              
              lastIndex = outputMatch.index + outputMatch.length;
            });
            
            // Add remaining text after last output block
            const afterOutput = content.substring(lastIndex);
            if (afterOutput.trim()) {
              const textDiv = document.createElement("div");
              textDiv.innerHTML = afterOutput;
              processMarkdownFormatting(textDiv);
              messageDiv.appendChild(textDiv);
            }
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            return;
          }
          
          // More precise code block detection - only for actual R code blocks
          // Check for code blocks - handles ```r, ```R, ```{r}, ```{R}, or plain ```
          if (content.includes("```r") || content.includes("```R") || /```[\s\S]*?```/.test(content)) {
            const start = content.indexOf("```");
            const end = content.lastIndexOf("```");
            if (start !== -1 && end !== -1 && end > start) {
              const beforeCode = content.substring(0, start);
              const codeBlock = content.substring(start + 3, end);
              const afterCode = content.substring(end + 3);
              
              // Add text before code
              if (beforeCode.trim()) {
                const textDiv = document.createElement("div");
                textDiv.textContent = beforeCode;
                messageDiv.appendChild(textDiv);
              }
              
              // Add code block
              const codeDiv = document.createElement("div");
              codeDiv.className = "code-block";
              
              // Create header with copy button
              const headerDiv = document.createElement("div");
              headerDiv.className = "code-block-header";
              
              const languageLabel = document.createElement("span");
              languageLabel.textContent = "R Code";
              
              // Clean up the code block - remove {r} and other prefixes
              let cleanCode = codeBlock;
              // Remove common prefixes
              if (cleanCode.startsWith("{r}")) {
                cleanCode = cleanCode.substring(3);
              } else if (cleanCode.startsWith("r}")) {
                cleanCode = cleanCode.substring(2);
              } else if (cleanCode.startsWith("r")) {
                cleanCode = cleanCode.substring(1);
              } else if (cleanCode.startsWith("```r")) {
                cleanCode = cleanCode.substring(4);
              } else if (cleanCode.startsWith("```")) {
                cleanCode = cleanCode.substring(3);
              }
              
              // Remove any remaining "R" at the start
              cleanCode = cleanCode.replace(/^R\s*/, "");
              cleanCode = cleanCode.replace(/^r\s*/, "");
              
              // Decode HTML entities
              cleanCode = cleanCode.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
              cleanCode = cleanCode.trim();
              
              const copyButton = document.createElement("button");
              copyButton.className = "copy-button";
              copyButton.textContent = "Copy";
              copyButton.onclick = function() {
                copyToClipboard(cleanCode, copyButton);
              };
              
              headerDiv.appendChild(languageLabel);
              headerDiv.appendChild(copyButton);
              codeDiv.appendChild(headerDiv);
              
              codeDiv.textContent = cleanCode;
              
              // Add buttons
              const buttonContainer = document.createElement("div");
              buttonContainer.style.marginTop = "10px";
              
              const insertButton = document.createElement("button");
              insertButton.className = "insert-button";
              insertButton.textContent = "Insert";
              insertButton.onclick = function() {
                insertCode(cleanCode);
              };
              
              const executeButton = document.createElement("button");
              executeButton.className = "insert-button";
              executeButton.style.backgroundColor = "#17a2b8";
              executeButton.textContent = "Execute & Fix";
              executeButton.onclick = function() {
                executeAndFix(cleanCode);
              };
              
              buttonContainer.appendChild(insertButton);
              buttonContainer.appendChild(executeButton);
              
              messageDiv.appendChild(codeDiv);
              messageDiv.appendChild(buttonContainer);
              
              // Add text after code
              if (afterCode.trim()) {
                const textDiv = document.createElement("div");
                let cleanText = afterCode;
                
                // Remove any leftover backticks from markdown processing
                cleanText = cleanText.replace(/^``\s*/, ""); // Remove leading backticks
                cleanText = cleanText.replace(/\s*``$/, ""); // Remove trailing backticks
                cleanText = cleanText.replace(/``/g, ""); // Remove any remaining backticks
                
                textDiv.textContent = cleanText;
                messageDiv.appendChild(textDiv);
              }
            } else {
              messageDiv.innerHTML = content;
              processMarkdownFormatting(messageDiv);
            }
          } else {
            messageDiv.innerHTML = content;
            processMarkdownFormatting(messageDiv);
          }
        } else {
          messageDiv.innerHTML = content;
          processMarkdownFormatting(messageDiv);
        }
        
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
      }
      
      // Specialized function for visualization agent messages with image support
      function addVisualizationMessage(content, role) {
        const container = document.getElementById("chat-container");
        const messageDiv = document.createElement("div");
        messageDiv.className = "message " + role + "-message";
        
        if (content.includes("data:image/png;base64,")) {
          // Handle mixed content (text + images)
          const parts = content.split(/(data:image\/png;base64,[A-Za-z0-9+/=]+)/);
          
          parts.forEach(part => {
            if (part.startsWith('data:image/png;base64,')) {
              // Create image element
              const img = document.createElement('img');
              console.log(' Creating image with data URL length:', part.length);
              console.log(' Data URL preview:', part.substring(0, 100) + '...');
              img.src = part;
              img.style.maxWidth = '100%';
              img.style.height = 'auto';
              img.style.borderRadius = '8px';
              img.style.margin = '10px 0';
              img.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
              img.style.border = '1px solid #e0e0e0';
              messageDiv.appendChild(img);
            } else if (part.trim()) {
              // Add text content with markdown support
              const textDiv = document.createElement('div');
              textDiv.innerHTML = part.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
              messageDiv.appendChild(textDiv);
            }
          });
        } else {
          // Use original addMessage logic for non-image content
          return addMessage(content, role);
        }
        
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
      }
      
      function insertCode(code) {
        if (!isConnected) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Send insert request via WebSocket
        ws.send(JSON.stringify({
          action: "insert_code",
          code: code
        }));
      }
      
      function executeAndFix(code) {
        if (!isConnected) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Send execute and fix request via WebSocket
        ws.send(JSON.stringify({
          action: "execute_and_fix",
          code: code
        }));
      }
      
      function newConversation() {
        if (!isConnected) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Clean up any active agent workflows
        if (currentAgentWorkflow) {
          console.log(' Cleaning up active agent workflow for new conversation');
          currentAgentWorkflow = null;
          agentResults = [];
          agentCodes = [];
          currentStepCode = null;
        }
        
        // Clear pending requests and timeouts
        if (window.pendingAgentCodeRequest) {
          console.log(' Clearing pending agent code request');
          window.pendingAgentCodeRequest = null;
        }
        
        pendingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
        pendingTimeouts = [];
        
        // Reset agent type flags
        window.currentActiveAgentType = null;
        window.completedAgentType = null;
        window.isAgentFinalCode = false;
        window.customStatisticalAnalysisInProgress = false;
        window.customTransformationInProgress = false;
        
        // Reset streaming state
        currentStreamingMessage = null;
        if (streamingTimeout) {
          clearTimeout(streamingTimeout);
          streamingTimeout = null;
        }
        
        // Reset iteration counters
        cleaningCodeIterationCount = 0;
        cleaningCodeExecuting = false;
        
        // Reset AI responding flag and ensure button is in correct state
        isAIResponding = false;
        transformToSendButton();
        
        // Clear the chat container
        const container = document.getElementById("chat-container");
        container.innerHTML = '<div class="message ai-message">New conversation started. Your R workspace context is still available!</div>';
        
        // Send new conversation request to clear history on backend
        ws.send(JSON.stringify({
          action: "new_conversation"
        }));
        
        // Clear the input field
        document.getElementById("user-input").value = "";
        
        // Scroll to bottom
        container.scrollTop = container.scrollHeight;
        
        // Switch back to chat tab if not already there
        const chatTab = document.getElementById("chat-tab");
        if (!chatTab.classList.contains("active")) {
          // Hide all tab contents
          document.querySelectorAll('.tab-content').forEach(tab => {
            tab.classList.remove('active');
          });
          
          // Remove active class from all tab buttons
          document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
          });
          
          // Show chat tab content
          document.getElementById("chat-tab").classList.add("active");
          
          // Add active class to chat button
          document.querySelector('.tab-btn[onclick="switchTab(\'chat\')"]').classList.add('active');
        }
      }
      
      function applyDebugFix(lineNumber, newCode) {
        if (!isConnected) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Send the fix to be applied
        ws.send(JSON.stringify({
          action: "apply_debug_fix",
          line_number: lineNumber,
          new_code: newCode
        }));
        
        addMessage(`Applying fix to line ${lineNumber}...`, "user");
      }
      
      function declineDebugFix() {
        addMessage("Fix declined", "user");
      }
      
      // Tab completion state
      let completions = { dataframes: [], functions: [], variables: [] };
      let completionSuggestion = null;
      let currentCompletion = null;
      let completionPrefix = "";
      
      // Request completions from backend
      function requestCompletions() {
        if (!isConnected || !ws) return;
        ws.send(JSON.stringify({ action: "get_completions" }));
      }
      
      // Create inline completion suggestion overlay
      function createCompletionSuggestion() {
        if (completionSuggestion) {
          completionSuggestion.remove();
        }
        
        const userInput = document.getElementById("user-input");
        if (!userInput) return;
        
        const inputRow = userInput.parentElement;
        if (!inputRow) return;
        
        completionSuggestion = document.createElement("div");
        completionSuggestion.id = "completion-suggestion";
        completionSuggestion.style.cssText = `
          position: absolute;
          pointer-events: none;
          color: #888;
          font-family: inherit;
          font-size: inherit;
          line-height: inherit;
          padding: 0;
          margin: 0;
          white-space: pre-wrap;
          word-wrap: break-word;
          z-index: 1;
          background: var(--input-bg);
          border: none;
          overflow: hidden;
          display: none;
        `;
        
        inputRow.style.position = "relative";
        inputRow.appendChild(completionSuggestion);
        
        // Ensure input is above suggestion
        userInput.style.position = "relative";
        userInput.style.zIndex = "2";
      }
      
      // Show inline completion suggestion
      function showCompletionSuggestion(prefix) {
        if (!completionSuggestion) createCompletionSuggestion();
        
        const userInput = document.getElementById("user-input");
        if (!userInput) return;
        
        completionPrefix = prefix.toLowerCase();
        currentCompletion = null;
        
        // Filter and combine all completions
        const allItems = [
          ...completions.dataframes.map(name => ({ name, type: "dataframe" })),
          ...completions.functions.map(name => ({ name, type: "function" })),
          ...completions.variables.map(name => ({ name, type: "variable" }))
        ].filter(item => item.name.toLowerCase().startsWith(completionPrefix));
        
        if (allItems.length === 0) {
          hideCompletionSuggestion();
          return;
        }
        
        // Sort: dataframes first, then functions, then variables
        allItems.sort((a, b) => {
          const typeOrder = { dataframe: 0, function: 1, variable: 2 };
          if (typeOrder[a.type] !== typeOrder[b.type]) {
            return typeOrder[a.type] - typeOrder[b.type];
          }
          return a.name.localeCompare(b.name);
        });
        
        // Use the first matching completion
        currentCompletion = allItems[0].name;
        
        // Get the text and cursor position
        const text = userInput.value;
        const cursorPos = userInput.selectionStart;
        const beforeText = text.substring(0, cursorPos);
        const suggestionText = currentCompletion.substring(prefix.length);
        
        if (suggestionText.length === 0) {
          hideCompletionSuggestion();
          return;
        }
        
        // Calculate cursor position for multi-line support
        const computedStyle = window.getComputedStyle(userInput);
        const inputRect = userInput.getBoundingClientRect();
        const inputRow = userInput.parentElement;
        const containerRect = inputRow.getBoundingClientRect();
        
        // Create a mirror div to measure text position accurately
        const mirror = document.createElement("div");
        const mirrorStyle = window.getComputedStyle(userInput);
        mirror.style.cssText = `
          position: absolute;
          visibility: hidden;
          white-space: pre-wrap;
          word-wrap: break-word;
          font-family: ${mirrorStyle.fontFamily};
          font-size: ${mirrorStyle.fontSize};
          padding: ${mirrorStyle.padding};
          border: ${mirrorStyle.border};
          box-sizing: ${mirrorStyle.boxSizing};
          width: ${inputRect.width}px;
          line-height: ${mirrorStyle.lineHeight};
          overflow: hidden;
        `;
        mirror.textContent = beforeText;
        document.body.appendChild(mirror);
        
        // Create a range to measure cursor position
        const range = document.createRange();
        const textNode = mirror.firstChild;
        if (textNode) {
          range.setStart(textNode, 0);
          range.setEnd(textNode, Math.min(beforeText.length, textNode.textContent.length));
        }
        
        // Get line height
        const lineHeight = parseFloat(computedStyle.lineHeight) || parseFloat(computedStyle.fontSize) * 1.4;
        
        // Calculate which line the cursor is on
        const linesBeforeCursor = beforeText.split('\n');
        const currentLineIndex = linesBeforeCursor.length - 1;
        const currentLineText = linesBeforeCursor[currentLineIndex];
        
        // Measure width of text on current line before cursor
        const measureSpan = document.createElement("span");
        measureSpan.style.cssText = `
          position: absolute;
          visibility: hidden;
          white-space: pre;
          font-family: ${computedStyle.fontFamily};
          font-size: ${computedStyle.fontSize};
        `;
        measureSpan.textContent = currentLineText;
        document.body.appendChild(measureSpan);
        const textWidth = measureSpan.offsetWidth;
        document.body.removeChild(measureSpan);
        
        // Calculate position offsets
        const paddingTop = parseFloat(computedStyle.paddingTop) || 8;
        const paddingLeft = parseFloat(computedStyle.paddingLeft) || 8;
        const verticalOffset = currentLineIndex * lineHeight;
        const horizontalOffset = textWidth;
        
        // Set suggestion overlay content - ONLY show the suggestion text (not duplicate all text)
        const suggestionColor = document.body.classList.contains('dark-theme') || window.matchMedia('(prefers-color-scheme: dark)').matches ? '#666' : '#999';
        completionSuggestion.innerHTML = '<span style="color: ' + suggestionColor + ';">' + 
          suggestionText.replace(/ /g, '&nbsp;').replace(/\n/g, '<br>') + '</span>';
        
        // Position suggestion exactly at cursor location
        completionSuggestion.style.top = (inputRect.top - containerRect.top + verticalOffset + paddingTop) + "px";
        completionSuggestion.style.left = (inputRect.left - containerRect.left + horizontalOffset + paddingLeft) + "px";
        completionSuggestion.style.width = "auto";
        completionSuggestion.style.height = "auto";
        completionSuggestion.style.display = "block";
        completionSuggestion.style.whiteSpace = "pre";
        
        // Match input styling for text rendering (but transparent background)
        completionSuggestion.style.fontFamily = computedStyle.fontFamily;
        completionSuggestion.style.fontSize = computedStyle.fontSize;
        completionSuggestion.style.lineHeight = computedStyle.lineHeight;
        completionSuggestion.style.padding = "0";
        completionSuggestion.style.margin = "0";
        completionSuggestion.style.border = "none";
        completionSuggestion.style.outline = "none";
        completionSuggestion.style.background = "transparent";
        completionSuggestion.style.boxSizing = "content-box";
        
        // Clean up
        document.body.removeChild(mirror);
      }
      
      // Hide completion suggestion
      function hideCompletionSuggestion() {
        if (completionSuggestion) {
          completionSuggestion.style.display = "none";
        }
        currentCompletion = null;
        completionPrefix = "";
      }
      
      // Accept completion suggestion
      function acceptCompletion() {
        if (!currentCompletion) return;
        
        const userInput = document.getElementById("user-input");
        if (!userInput) return;
        
        const text = userInput.value;
        const cursorPos = userInput.selectionStart;
        
        // Find the start of the current word
        let start = cursorPos;
        while (start > 0 && /[a-zA-Z0-9_.]/.test(text[start - 1])) {
          start--;
        }
        
        // Replace the prefix with the full name
        const before = text.substring(0, start);
        const after = text.substring(cursorPos);
        userInput.value = before + currentCompletion + after;
        
        // Set cursor after the inserted name
        const newPos = start + currentCompletion.length;
        userInput.setSelectionRange(newPos, newPos);
        userInput.focus();
        
        hideCompletionSuggestion();
      }
      
      // Handle Enter key
      const userInput = document.getElementById("user-input");
      if (userInput) {
        // Request completions on connection
        if (isConnected) {
          requestCompletions();
        }
        
        userInput.addEventListener("keydown", function(e) {
          // Handle Tab key to accept completion
          if (e.key === "Tab" && currentCompletion) {
            e.preventDefault();
            acceptCompletion();
            return;
          }
          
          // Hide suggestion on Escape
          if (e.key === "Escape") {
            hideCompletionSuggestion();
            return;
          }
          
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
          // Allow Shift+Enter for new lines
        });
        
        // Handle input changes for autocomplete
        userInput.addEventListener("input", function() {
          const text = this.value;
          const cursorPos = this.selectionStart;
          
          // Find the current word being typed
          let start = cursorPos;
          while (start > 0 && /[a-zA-Z0-9_.]/.test(text[start - 1])) {
            start--;
          }
          
          const currentWord = text.substring(start, cursorPos);
          
          // Show completion suggestion if word is at least 3 characters
          if (currentWord.length >= 3 && /^[a-zA-Z]/.test(currentWord)) {
            showCompletionSuggestion(currentWord);
          } else {
            hideCompletionSuggestion();
          }
        });
        
        // Update suggestion position on scroll/resize
        userInput.addEventListener("scroll", function() {
          if (currentCompletion && completionSuggestion) {
            const inputRect = userInput.getBoundingClientRect();
            const inputRow = userInput.parentElement;
            const containerRect = inputRow.getBoundingClientRect();
            completionSuggestion.style.top = (inputRect.top - containerRect.top) + "px";
            completionSuggestion.style.left = (inputRect.left - containerRect.left) + "px";
          }
        });
        
        // Update suggestion on selection change
        userInput.addEventListener("selectionchange", function() {
          if (currentCompletion && completionSuggestion) {
            const text = userInput.value;
            const cursorPos = userInput.selectionStart;
            const start = cursorPos;
            let wordStart = start;
            while (wordStart > 0 && /[a-zA-Z0-9_.]/.test(text[wordStart - 1])) {
              wordStart--;
            }
            const currentWord = text.substring(wordStart, cursorPos);
            if (currentWord.length >= 3 && /^[a-zA-Z]/.test(currentWord)) {
              showCompletionSuggestion(currentWord);
            } else {
              hideCompletionSuggestion();
            }
          }
        });
        
        // Auto-resize textarea - only expand when text wraps to a new line
        userInput.addEventListener("input", function() {
          // Reset height to auto to get accurate scrollHeight
          this.style.height = "auto";
          
          // Calculate single-line height: base height (24px) + padding (8px top + 8px bottom = 16px) + line height
          // Single line scrollHeight should be around 40-42px with padding and line height
          const singleLineHeight = 40;
          
          // Only expand if content has wrapped (scrollHeight exceeds single-line height)
          if (this.scrollHeight > singleLineHeight) {
            this.style.height = Math.min(this.scrollHeight, 150) + "px";
          } else {
            // Keep at base height when content fits on one line
            this.style.height = "24px";
          }
        });
        
        // Close completion suggestion when clicking outside
        document.addEventListener("click", function(e) {
          const completionSuggestionEl = document.getElementById("completion-suggestion");
          const userInputEl = document.getElementById("user-input");
          if (completionSuggestionEl && !completionSuggestionEl.contains(e.target) && e.target !== userInputEl) {
            hideCompletionSuggestion();
          }
        });
      }
      
      // Handle Enter key for access code
      document.getElementById("access-code").addEventListener("keypress", function(e) {
        if (e.key === "Enter") {
          validateAccess();
        }
      });
      
      // Add password toggle functionality for access code
      document.getElementById('toggleAccessCode').addEventListener('click', function() {
        const accessCodeInput = document.getElementById('access-code');
        const toggleButton = this;
        
        if (accessCodeInput.type === 'password') {
          accessCodeInput.type = 'text';
          toggleButton.textContent = 'Hide';
          toggleButton.title = 'Hide access code';
        } else {
          accessCodeInput.type = 'password';
          toggleButton.textContent = 'Show';
          toggleButton.title = 'Show access code';
        }
      });
      
      // Apply RStudio theme with actual colors
      function applyTheme(isDark, themeName, colors = {}) {
        console.log("Applying theme:", isDark ? "dark" : "light", "Theme:", themeName);
        console.log("RStudio colors:", colors);
        
        const root = document.documentElement;
        
        if (colors && Object.keys(colors).length > 0) {
          // Use actual RStudio colors
          root.style.setProperty('--bg-primary', colors.background || (isDark ? '#1e1e1e' : '#ffffff'));
          root.style.setProperty('--bg-secondary', colors.console_background || (isDark ? '#2d2d2d' : '#f8f9fa'));
          root.style.setProperty('--bg-card', colors.console_background || (isDark ? '#3c3c3c' : '#ffffff'));
          root.style.setProperty('--text-primary', colors.foreground || (isDark ? '#ffffff' : '#2c3e50'));
          root.style.setProperty('--text-secondary', colors.console_foreground || (isDark ? '#cccccc' : '#6c757d'));
          root.style.setProperty('--border-color', isDark ? '#555555' : '#dee2e6');
          root.style.setProperty('--input-bg', colors.console_background || (isDark ? '#2d2d2d' : '#ffffff'));
          root.style.setProperty('--code-bg', colors.background || (isDark ? '#1e1e1e' : '#f8f9fa'));
          root.style.setProperty('--rgent-primary', isDark ? '#ff8c42' : '#ff6b35');
          root.style.setProperty('--rgent-accent', isDark ? '#5dade2' : '#3498db');
        } else {
          // Fallback to basic theme detection
          if (isDark) {
            // Dark theme
            root.style.setProperty('--bg-primary', '#1e1e1e');
            root.style.setProperty('--bg-secondary', '#2d2d2d');
            root.style.setProperty('--bg-card', '#3c3c3c');
            root.style.setProperty('--text-primary', '#ffffff');
            root.style.setProperty('--text-secondary', '#cccccc');
            root.style.setProperty('--border-color', '#555555');
            root.style.setProperty('--input-bg', '#2d2d2d');
            root.style.setProperty('--code-bg', '#1e1e1e');
            root.style.setProperty('--rgent-primary', '#ff8c42');
            root.style.setProperty('--rgent-accent', '#5dade2');
          } else {
            // Light theme
            root.style.setProperty('--bg-primary', '#ffffff');
            root.style.setProperty('--bg-secondary', '#f8f9fa');
            root.style.setProperty('--bg-card', '#ffffff');
            root.style.setProperty('--text-primary', '#2c3e50');
            root.style.setProperty('--text-secondary', '#6c757d');
            root.style.setProperty('--border-color', '#dee2e6');
            root.style.setProperty('--input-bg', '#ffffff');
            root.style.setProperty('--code-bg', '#f8f9fa');
            root.style.setProperty('--rgent-primary', '#ff6b35');
            root.style.setProperty('--rgent-accent', '#3498db');
          }
        }
        
        // Apply theme to body
        document.body.classList.toggle('dark-theme', isDark);
        document.body.classList.toggle('light-theme', !isDark);
      }
      
      // Early theme detection on page load
      function detectInitialTheme() {
        // Check if user prefers dark mode
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        console.log("Initial theme detection:", prefersDark ? "dark" : "light");
        
        // Apply basic theme immediately
        applyTheme(prefersDark, "System Theme");
      }
      
      // Call early theme detection when page loads
      document.addEventListener('DOMContentLoaded', detectInitialTheme);
      
      // Connect to WebSocket immediately on page load to receive access_code_loaded before user interaction
      document.addEventListener('DOMContentLoaded', function() {
        connectWebSocket();
        
        // Ensure explorer dropdown is hidden on page load
        const explorerDropdown = document.getElementById('explorer-dataframe-select-dropdown');
        if (explorerDropdown) {
          console.log(' DOMContentLoaded: Hiding explorer dropdown');
          explorerDropdown.style.display = 'none';
          explorerDropdown.style.visibility = 'hidden';
          explorerDropdown.style.opacity = '0';
          explorerDropdown.style.pointerEvents = 'none';
        }
        
        // Initialize mode status (set initial state without showing message)
        const toggle = document.getElementById('auto-execute-toggle');
        if (toggle) {
          lastModeStatus = toggle.checked ? 'auto' : 'ask';
        }
      });
      
      // Analyze Last Plot functionality
      function analyzeLastPlot() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          alert("Not connected to RStudio");
          return;
        }
        
        // Reset stop flag for new operation
        operationStopped = false;
        
        // Set AI responding flag
        isAIResponding = true;
        
        // Transform send button to stop button
        transformToStopButton();
        
        // Add initial message showing we're starting analysis
        addMessage("**Starting Plot Analysis:**\n\nStep 1: Scanning R history for plot commands:", "ai");
        
        // Send the analyze request
        ws.send(JSON.stringify({
          action: "analyze_last_plot"
        }));
        

      }
      
      // Special function for plot analysis messages
      function addPlotAnalysisMessage(content) {
        const container = document.getElementById("chat-container");
        const messageDiv = document.createElement("div");
        messageDiv.className = "message ai-message";
        
        // Set the content and process it properly
        messageDiv.innerHTML = content;
        
        // Process markdown formatting first
        processMarkdownFormatting(messageDiv);
        
        // Then process for code blocks with only Copy/Insert buttons
        processPlotAnalysisContent(messageDiv);
        
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
      }
      
      // Special processing for plot analysis content (no Execute & Fix)
      function processPlotAnalysisContent(messageDiv) {
        // Check if operation was stopped
        if (operationStopped) {
          console.log(' Operation was stopped, ignoring plot analysis processing');
          return;
        }
        
        const content = messageDiv.innerHTML;
        
        // More precise code block detection - only create blocks for actual code blocks
        // Handles ```r, ```R, ```{r}, ```{R}, plain ```, and variations with whitespace
        const hasMarkdownCodeBlock = /```(?:\s*[rR]|\s*\{[rR]\}|\s*[a-zA-Z]*)?[\s\S]*?```/i.test(content);
        
        // Only detect HTML code blocks that are actual blocks, not inline code
        const hasHTMLCodeBlock = /<code[^>]*>[\s\S]*?<\/code>/.test(content) && 
                                !content.includes('<code style="background-color: var(--code-bg); padding: 2px 4px; border-radius: 3px;">');
        
        if (hasMarkdownCodeBlock || hasHTMLCodeBlock) {
          // Clear the message div
          messageDiv.innerHTML = "";
          
          // Try to split by markdown code blocks first - handles various formats
          let parts = content.split(/(```(?:\s*[rR]|\s*\{[rR]\}|\s*[a-zA-Z]*)?(?:\n|\s)*[\s\S]*?```)/gi);
          
          // If no markdown blocks found, try HTML code blocks
          if (parts.length === 1) {
            parts = content.split(/(<code[^>]*>[\s\S]*?<\/code>)/g);
          }
          
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            
            // Check if this is specifically R code
            const isRCodeBlock = (part.startsWith("```r\n") && part.endsWith("```")) || 
                (part.startsWith("```R\n") && part.endsWith("```")) ||
                (part.startsWith("```r ") && part.endsWith("```")) ||
                (part.startsWith("```R ") && part.endsWith("```")) ||
                (part.startsWith("```r") && part.endsWith("```")) ||
                (part.startsWith("```R") && part.endsWith("```")) ||
                (part.startsWith("```{r}") && part.endsWith("```")) ||
                (part.startsWith("```{R}") && part.endsWith("```"));
            
            // Check if this is any code block
            const isCodeBlock = isRCodeBlock ||
                (part.startsWith("```") && part.endsWith("```") && part.length > 6) ||
                (part.includes("<code") && part.includes("</code>"));
            
            if (isCodeBlock) {
              // This is a code block - style it with only Copy/Insert buttons
              const codeDiv = document.createElement("div");
              codeDiv.className = "code-block";
              
              // Create header with copy button
              const headerDiv = document.createElement("div");
              headerDiv.className = "code-block-header";
              
              const languageLabel = document.createElement("span");
              // Determine appropriate label
              if (isRCodeBlock) {
                languageLabel.textContent = "R Code";
              } else if (part.startsWith("```")) {
                // Extract language from ```language format
                const langMatch = part.match(/^```([a-zA-Z]+)/);
                if (langMatch && langMatch[1]) {
                  languageLabel.textContent = langMatch[1].charAt(0).toUpperCase() + langMatch[1].slice(1);
                } else {
                  languageLabel.textContent = "Output";
                }
              } else {
                languageLabel.textContent = "Code";
              }
              
              const actionsDiv = document.createElement("div");
              actionsDiv.className = "code-block-actions";
              
              const copyButton = document.createElement("button");
              copyButton.className = "copy-button";
              copyButton.textContent = "Copy";
              copyButton.onclick = function() {
                copyToClipboard(cleanCode, copyButton);
              };
              
              headerDiv.appendChild(languageLabel);
              actionsDiv.appendChild(copyButton);
              
              // Only add Insert button for R code blocks
              if (isRCodeBlock) {
                const insertButton = document.createElement("button");
                insertButton.className = "copy-button";
                insertButton.textContent = "Insert at Cursor";
                insertButton.onclick = function() {
                  insertCode(cleanCode);
                };
                actionsDiv.appendChild(insertButton);
              }
              
              headerDiv.appendChild(actionsDiv);
              codeDiv.appendChild(headerDiv);
              
              // Create code content div - extract just the code
              const codeContent = document.createElement("div");
              let cleanCode;
              if (part.startsWith("```{r}") || part.startsWith("```{R}") || part.startsWith("```{r}\n") || part.startsWith("```{R}\n") || part.startsWith("```{r} ")) {
                // R Markdown format with curly braces - remove ```{r} or ```{R} (with optional newline/space) at start and ``` at end
                cleanCode = part.replace(/^```\{[rR]\}[\s\n]*/, "").replace(/```$/, "");
              } else if (part.startsWith("```r\n") || part.startsWith("```r ")) {
                // Markdown format - remove ```r\n or ```r  at start and ``` at end
                cleanCode = part.replace(/^```r[\s\n]+/, "").replace(/```$/, "");
              } else if (part.startsWith("```R\n") || part.startsWith("```R ")) {
                // Markdown format - remove ```R\n or ```R  at start and ``` at end
                cleanCode = part.replace(/^```R[\s\n]+/, "").replace(/```$/, "");
              } else if (part.startsWith("```r") && part.endsWith("```")) {
                // Markdown format without newline after r
                cleanCode = part.replace(/^```r/, "").replace(/```$/, "");
              } else if (part.startsWith("```R") && part.endsWith("```")) {
                // Markdown format without newline after R
                cleanCode = part.replace(/^```R/, "").replace(/```$/, "");
              } else if (part.startsWith("```") && part.endsWith("```")) {
                // Plain code block without language identifier - remove ``` at start and end
                // Only remove language identifier if followed by whitespace/newline (not part of code)
                cleanCode = part.replace(/^```(?:[a-zA-Z]+[\s\n]+)?/, "").replace(/```$/, "");
              } else {
                // HTML format - extract clean text from nested HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = part;
                cleanCode = tempDiv.textContent || tempDiv.innerText || '';
                
                // If that didn't work, try manual removal
                if (!cleanCode || cleanCode.trim() === '') {
                  cleanCode = part.replace(/<code[^>]*>/g, "").replace(/<\/code>/g, "");
                  cleanCode = cleanCode.replace(/<[^>]*>/g, "");
                  cleanCode = cleanCode.replace(/style="[^"]*"/g, "");
                }
              }
              
              // Remove any remaining artifacts
              cleanCode = cleanCode.replace(/^['"]?r['"]?\s*/, "");
              cleanCode = cleanCode.replace(/^\s*['"]?r['"]?\s*/, "");
              cleanCode = cleanCode.replace(/^R\s*/, "");
              cleanCode = cleanCode.replace(/^r\s*/, "");
              
              // Remove {r} or {R} if it appears at the start (should have been removed but just in case)
              cleanCode = cleanCode.replace(/^\{[rR]\}\s*\n?/, "");
              cleanCode = cleanCode.replace(/^\s*\{[rR]\}\s*\n?/, "");
              
              cleanCode = cleanCode.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
              
              codeContent.textContent = cleanCode;
              codeDiv.appendChild(codeContent);
              
              messageDiv.appendChild(codeDiv);
            } else if (part.trim()) {
              // This is regular text - clean up any leftover backticks and add it
              const textDiv = document.createElement("div");
              let cleanText = part;
              
              // Remove any leftover backticks from markdown processing
              cleanText = cleanText.replace(/^``\s*/, "");
              cleanText = cleanText.replace(/\s*``$/, "");
              cleanText = cleanText.replace(/``/g, "");
              
              textDiv.innerHTML = cleanText;
              processMarkdownFormatting(textDiv);
              messageDiv.appendChild(textDiv);
            }
          }
        } else {
          // If no code blocks, just process markdown formatting
          processMarkdownFormatting(messageDiv);
        }
      }
      
      // ===== AGENT FUNCTIONS =====
      
      // Enable agents tab when connected
      function enableAgentsTab() {
        const agentsTabBtn = document.getElementById('agents-tab-btn');
        if (agentsTabBtn) {
          agentsTabBtn.style.display = 'block';
        }
      }
      
      // Switch tabs (including agents)
      function switchTab(tabName) {
        console.log(' switchTab called with:', tabName);
        
        // Prevent switching to guide tab (now opened as modal)
        if (tabName === 'guide') {
          openGuideModal();
          return;
        }
        
        // Hide all tabs
        const tabs = document.querySelectorAll('.tab-content');
        const buttons = document.querySelectorAll('.tab-btn');
        
        tabs.forEach(tab => {
          const tabId = tab.id;
          const wasActive = tab.classList.contains('active');
          tab.classList.remove('active');
          // Ensure inactive tabs are completely hidden
          if (!tab.classList.contains('active')) {
            tab.style.display = 'none';
          }
          console.log(`  Tab ${tabId}: wasActive=${wasActive}, now active=${tab.classList.contains('active')}, display=${tab.style.display}`);
        });
        buttons.forEach(btn => btn.classList.remove('active'));
        
        // Hide all agent configs and views when switching away from agents tab
        if (tabName !== 'agents') {
          // Hide all agent configs
          const configs = ['cleaning-config', 'transformation-config', 'statistical-config', 'modeling-config', 'visualization-config'];
          configs.forEach(id => {
            const config = document.getElementById(id);
            if (config) config.style.display = 'none';
          });
          
          // Hide agent selection view if it exists
          const agentSelection = document.getElementById('agent-selection');
          if (agentSelection) agentSelection.style.display = 'none';
        }
        
        // Hide explorer dropdown, button, and wrapper when switching away from explorer tab
        const explorerDropdown = document.getElementById('explorer-dataframe-select-dropdown');
        const explorerButton = document.getElementById('explorer-dataframe-select-button');
        const explorerWrapper = document.getElementById('explorer-dataframe-select-wrapper');
        const explorerTab = document.getElementById('explorer-tab');
        const isExplorerActive = tabName === 'explorer';
        
        console.log('  Explorer tab state:', {
          tabName,
          isExplorerActive,
          explorerTabExists: !!explorerTab,
          explorerTabActive: explorerTab ? explorerTab.classList.contains('active') : false,
          explorerTabDisplay: explorerTab ? explorerTab.style.display : 'N/A',
          dropdownExists: !!explorerDropdown,
          buttonExists: !!explorerButton,
          wrapperExists: !!explorerWrapper,
          dropdownDisplay: explorerDropdown ? explorerDropdown.style.display : 'N/A',
          dropdownVisibility: explorerDropdown ? explorerDropdown.style.visibility : 'N/A'
        });
        
        if (tabName !== 'explorer') {
          // Hide dropdown, button, and wrapper when switching away from explorer
          if (explorerDropdown) {
            console.log('  Hiding explorer dropdown (switching away from explorer)');
            explorerDropdown.style.display = 'none';
            explorerDropdown.style.visibility = 'hidden';
            explorerDropdown.style.opacity = '0';
            explorerDropdown.style.pointerEvents = 'none';
          }
          if (explorerButton) {
            explorerButton.style.display = 'none';
            explorerButton.style.visibility = 'hidden';
            explorerButton.style.opacity = '0';
            explorerButton.style.pointerEvents = 'none';
          }
          if (explorerWrapper) {
            explorerWrapper.style.display = 'none';
            explorerWrapper.style.visibility = 'hidden';
            explorerWrapper.style.opacity = '0';
            explorerWrapper.style.pointerEvents = 'none';
          }
        } else {
          // When switching to explorer, ensure dropdown, button, and wrapper are visible
          if (explorerWrapper) {
            explorerWrapper.style.display = 'block';
            explorerWrapper.style.visibility = 'visible';
            explorerWrapper.style.opacity = '1';
            explorerWrapper.style.pointerEvents = 'auto';
          }
          if (explorerButton) {
            explorerButton.style.display = 'flex';
            explorerButton.style.visibility = 'visible';
            explorerButton.style.opacity = '1';
            explorerButton.style.pointerEvents = 'auto';
          }
          if (explorerDropdown) {
            console.log('  Showing explorer dropdown (switching to explorer)');
            explorerDropdown.style.visibility = 'visible';
            explorerDropdown.style.opacity = '1';
            explorerDropdown.style.pointerEvents = 'auto';
            // Keep display as 'none' until button is clicked
            if (explorerDropdown.style.display !== 'block') {
              explorerDropdown.style.display = 'none';
            }
          }
        }
        
        // Show selected tab
        const selectedTab = document.getElementById(tabName + '-tab');
        const selectedButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
        
        if (selectedTab) {
          selectedTab.classList.add('active');
          selectedTab.style.display = 'block';
          // Ensure proper containment for explorer tab
          if (tabName === 'explorer') {
            selectedTab.style.overflow = 'hidden';
          }
          console.log(`  Selected tab ${tabName}-tab: active=${selectedTab.classList.contains('active')}, display=${selectedTab.style.display}`);
        }
        if (selectedButton) selectedButton.classList.add('active');
        
        // Special handling for agents tab
        if (tabName === 'agents') {
          showAgentSelection();
        }
        
        // Special handling for usage tab
        if (tabName === 'usage') {
          loadStats();
        }
        
        // Special handling for explorer tab
        if (tabName === 'explorer') {
          loadExplorerDataframes();
        }
      }
      
      // Show agent selection view
      function showAgentSelection() {
        document.getElementById('agent-selection').style.display = 'flex';
        document.getElementById('cleaning-config').style.display = 'none';
        document.getElementById('transformation-config').style.display = 'none';
        document.getElementById('statistical-config').style.display = 'none';
        document.getElementById('modeling-config').style.display = 'none';
        
        // Reset the header and prompt to default
        const header = document.getElementById('agents-main-header');
        const prompt = document.getElementById('agent-selection-prompt');
        const backBtn = document.getElementById('back-to-agents-btn');
        if (header) {
          header.textContent = 'AI Agents';
        }
        if (prompt) {
          prompt.textContent = 'Select an agent to get started';
          prompt.style.display = 'block';
        }
        if (backBtn) {
          backBtn.style.display = 'none';
        }
      }
      
      // Select an agent
      function selectAgent(agentType) {
        // Update the main header with the selected agent name
        const header = document.getElementById('agents-main-header');
        const prompt = document.getElementById('agent-selection-prompt');
        const backBtn = document.getElementById('back-to-agents-btn');
        
        if (agentType === 'cleaning') {
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('cleaning-config').style.display = 'block';
          header.textContent = 'Data Cleaning Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          loadDataFramesMain();
        } else if (agentType === 'transformation') {
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('transformation-config').style.display = 'block';
          header.textContent = 'Data Transformation Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          loadTransformationDataFrames();
          
          // Set up transformation agent checkbox interactions
          setupTransformationCheckboxInteractions();
          // FIXED: Add missing event listener setup
          addTransformationOptionListeners();
        } else if (agentType === 'statistical') {
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('statistical-config').style.display = 'block';
          header.textContent = 'Statistical Analysis Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          loadStatisticalDataFrames();
          
          // Set up statistical agent checkbox interactions
          setupStatisticalCheckboxInteractions();
          // Add event listener setup
          addStatisticalOptionListeners();
        } else if (agentType === 'modeling') {
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('modeling-config').style.display = 'block';
          header.textContent = 'Modeling Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          loadModelingDataFrames();
          
          // Set up modeling agent checkbox interactions
          setupModelingCheckboxInteractions();
          // Add event listener setup
          addModelingOptionListeners();
        } else if (agentType === 'visualization') {
          console.log(' Setting up visualization agent...');
          document.getElementById('agent-selection').style.display = 'none';
          document.getElementById('visualization-config').style.display = 'block';
          header.textContent = 'Visualization Agent';
          prompt.style.display = 'none';
          backBtn.style.display = 'block';
          
          // Load dataframes for visualization
          loadVisualizationDataFrames();
        }
      }
      
      // Load available DataFrames for main config
      function loadDataFramesMain() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Load available DataFrames for transformation config
      function loadTransformationDataFrames() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Load available DataFrames for statistical config
      function loadStatisticalDataFrames() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Load available DataFrames for modeling config
      function loadModelingDataFrames() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Update DataFrame info when selection changes
      function updateDataFrameInfo() {
        const select = document.getElementById('dataframe-select');
        const selectedDF = select.value;
        const infoDiv = document.getElementById('dataframe-info');
        const startBtn = document.getElementById('start-cleaning-btn');
        
        if (selectedDF) {
          // Request DataFrame info from R
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: selectedDF
            }));
          }
          startBtn.disabled = false;
        } else {
          infoDiv.style.display = 'none';
          startBtn.disabled = true;
        }
      }
      
      // Start cleaning agent
      function startCleaningAgent() {
        const dataframe = document.getElementById('dataframe-select').value;
        const naHandling = document.querySelector('input[name="na-handling"]:checked').value;
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        // Close modal
        closeAgentConfigModal();
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // Send agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_cleaning_agent',
            dataframe: dataframe,
            na_handling: naHandling
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
        }
      }
      
      // Start statistical analysis agent
      function startStatisticalAgent() {
        console.log(' Starting statistical analysis agent...');
        const dataframe = document.getElementById('statistical-dataframe-select').value;
        
        console.log(' Selected dataframe:', dataframe);
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        // Collect statistical analysis options
        const analysisOptions = {
          basicStatistics: document.getElementById('check-basic-statistics').checked,
          groupComparisons: document.getElementById('check-group-comparisons').checked,
          categoricalTests: document.getElementById('check-categorical-tests').checked,
          beforeAfterAnalysis: document.getElementById('check-before-after-analysis').checked,
          effectSizeAnalysis: document.getElementById('check-effect-size-analysis').checked,
          powerAnalysis: document.getElementById('check-power-analysis').checked,
          multipleTestingCorrection: document.getElementById('check-multiple-testing-correction').checked,
          customStatisticalAnalysis: document.getElementById('check-custom-statistical-analysis').checked
        };
        
        // Check if at least one option is selected
        if (!Object.values(analysisOptions).some(option => option)) {
          alert('Please select at least one statistical analysis type');
          return;
        }
        
        // Collect method options and variables
        const methodOptions = {};
        const variables = {};
        const customInputs = {};
        
        // Group comparisons
        if (analysisOptions.groupComparisons) {
          const groupCompSelect = document.getElementById('group-comparisons-select');
          methodOptions.groupComparisons = groupCompSelect.value;
          
          if (groupCompSelect.value === 'other') {
            customInputs.groupComparisons = document.getElementById('group-comparisons-custom-input').value.trim();
            if (!customInputs.groupComparisons) {
              alert('Please specify custom group comparison test');
              return;
            }
          }
          
          const continuousVar = document.getElementById('statistical-continuous-var').value;
          const groupingVar = document.getElementById('statistical-grouping-var').value;
          
          if (!continuousVar || !groupingVar) {
            alert('Please select both continuous and grouping variables for group comparisons');
            return;
          }
          
          variables.continuous_variable = continuousVar;
          variables.grouping_variable = groupingVar;
        }
        
        // Before/after analysis
        if (analysisOptions.beforeAfterAnalysis) {
          const beforeAfterSelect = document.getElementById('before-after-select');
          methodOptions.beforeAfterAnalysis = beforeAfterSelect.value;
          
          if (beforeAfterSelect.value === 'other') {
            customInputs.beforeAfterAnalysis = document.getElementById('before-after-custom-input').value.trim();
            if (!customInputs.beforeAfterAnalysis) {
              alert('Please specify custom before/after analysis');
              return;
            }
          }
          
          const beforeVar = document.getElementById('statistical-before-var').value;
          const afterVar = document.getElementById('statistical-after-var').value;
          
          if (!beforeVar || !afterVar) {
            alert('Please select both before and after variables for before/after analysis');
            return;
          }
          
          variables.before_variable = beforeVar;
          variables.after_variable = afterVar;
        }
        
        // Power analysis
        if (analysisOptions.powerAnalysis) {
          const powerSelect = document.getElementById('power-analysis-select');
          methodOptions.powerAnalysis = powerSelect.value;
          
          if (powerSelect.value === 'other') {
            customInputs.powerAnalysis = document.getElementById('power-analysis-custom-input').value.trim();
            if (!customInputs.powerAnalysis) {
              alert('Please specify custom power level');
              return;
            }
          }
        }
        

        
        // Categorical tests
        if (analysisOptions.categoricalTests) {
          const categoricalSelect = document.getElementById('categorical-tests-select');
          methodOptions.categoricalTests = categoricalSelect.value;
          
          if (categoricalSelect.value === 'other') {
            customInputs.categoricalTests = document.getElementById('categorical-tests-custom-input').value.trim();
            if (!customInputs.categoricalTests) {
              alert('Please specify custom categorical test');
              return;
            }
          }
          
          const catVar1 = document.getElementById('categorical-var1').value;
          const catVar2 = document.getElementById('categorical-var2').value;
          
          if (!catVar1 || !catVar2) {
            alert('Please select both categorical variables for categorical tests');
            return;
          }
          
          variables.categorical_variable1 = catVar1;
          variables.categorical_variable2 = catVar2;
        }
        
        // Effect size analysis
        if (analysisOptions.effectSizeAnalysis) {
          const effectSizeSelect = document.getElementById('effect-size-select');
          methodOptions.effectSizeAnalysis = effectSizeSelect.value;
          
          if (effectSizeSelect.value === 'other') {
            customInputs.effectSizeAnalysis = document.getElementById('effect-size-custom-input').value.trim();
            if (!customInputs.effectSizeAnalysis) {
              alert('Please specify custom effect size calculation');
              return;
            }
          }
        }
        
        // Multiple testing correction
        if (analysisOptions.multipleTestingCorrection) {
          const multipleTestingSelect = document.getElementById('multiple-testing-select');
          methodOptions.multipleTestingCorrection = multipleTestingSelect.value;
          
          if (multipleTestingSelect.value === 'other') {
            customInputs.multipleTestingCorrection = document.getElementById('multiple-testing-custom-input').value.trim();
            if (!customInputs.multipleTestingCorrection) {
              alert('Please specify custom multiple testing correction method');
              return;
            }
          }
        }
        
        // Custom statistical analysis
        if (analysisOptions.customStatisticalAnalysis) {
          customInputs.customStatisticalAnalysis = document.getElementById('custom-statistical-analysis-input').value.trim();
          if (!customInputs.customStatisticalAnalysis) {
            alert('Please describe your custom statistical analysis requirements');
            return;
          }
        }
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // FIXED: Hide statistical config when switching to chat
        const statisticalConfig = document.getElementById('statistical-config');
        if (statisticalConfig) {
          statisticalConfig.style.display = 'none';
        }
        
        // Send statistical analysis agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_statistical_agent',
            dataframe: dataframe,
            analysis_options: analysisOptions,
            method_options: methodOptions,
            variables: variables,
            custom_inputs: customInputs
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          // Switch to chat tab to show the statistical analysis workflow
          switchTab('chat');
        }
      }
      
      // Start modeling agent
      function startModelingAgent() {
        console.log(' Starting modeling agent...');
        const dataframe = document.getElementById('modeling-dataframe-select').value;
        const targetVariable = document.getElementById('modeling-target-variable').value;
        
        console.log(' Selected dataframe:', dataframe);
        console.log(' Target variable:', targetVariable);
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        if (!targetVariable) {
          alert('Please select a target variable for supervised learning');
          return;
        }
        
        // Collect modeling algorithms
        const algorithms = {
          dimensionalityReduction: document.getElementById('check-dimensionality-reduction').checked,
          linearRegression: document.getElementById('check-linear-regression').checked,
          logisticRegression: document.getElementById('check-logistic-regression').checked,
          multinomialRegression: document.getElementById('check-multinomial-regression').checked,
          randomForest: document.getElementById('check-random-forest').checked,
          xgboost: document.getElementById('check-xgboost').checked
        };
        
        // Collect additional options
        const options = {
          featureEngineering: document.getElementById('check-feature-engineering').checked,
          modelInterpretability: document.getElementById('check-model-interpretability').checked,
          claudePlots: document.getElementById('check-claude-plots').checked,
          customModeling: document.getElementById('check-custom-modeling').checked
        };
        
        // Check if at least one algorithm is selected (including custom modeling)
        const hasStandardAlgorithm = Object.values(algorithms).some(algorithm => algorithm);
        const hasCustomModeling = options.customModeling;
        
        if (!hasStandardAlgorithm && !hasCustomModeling) {
          alert('Please select at least one machine learning algorithm');
          return;
        }
        
        // Collect method options for dimensionality reduction
        if (algorithms.dimensionalityReduction) {
          const drSelect = document.getElementById('dimensionality-reduction-select');
          options.dimensionalityReductionMethod = drSelect.value;
        }
        
        // Collect custom modeling inputs
        const customInputs = {};
        if (options.customModeling) {
          customInputs.customModeling = document.getElementById('custom-modeling-input').value.trim();
          if (!customInputs.customModeling) {
            alert('Please describe your custom modeling requirements');
            return;
          }
        }
        
        // Collect selected variables
        const selectedVariables = getSelectedVariables();
        console.log(' Selected variables being sent:', selectedVariables);
        
        // Send modeling agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_modeling_agent',
            dataframe: dataframe,
            target_variable: targetVariable,
            algorithms: algorithms,
            options: options,
            custom_inputs: customInputs,
            selected_variables: selectedVariables
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          // Switch to chat tab to show the modeling workflow
          switchTab('chat');
          
          // Hide modeling config when switching to chat
          const modelingConfig = document.getElementById('modeling-config');
          if (modelingConfig) {
            modelingConfig.style.display = 'none';
          }
        }
      }
      
      // Start transformation agent
      function startTransformationAgent() {
        console.log(' Starting transformation agent...');
        const dataframe = document.getElementById('transformation-dataframe-select').value;
        
        console.log(' Selected dataframe:', dataframe);
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        // Collect transformation options
        const transformationOptions = {
          distributionAnalysis: document.getElementById('check-distribution-analysis').checked,
          mathematicalTransformations: document.getElementById('check-mathematical-transformations').checked,
          newVariables: document.getElementById('check-new-variables').checked,
          categoricalTransformations: document.getElementById('check-categorical-transformations').checked,
          dateTimeTransformations: document.getElementById('check-datetime-transformations').checked,
          mergingCombining: document.getElementById('check-merging-combining').checked,
          aggregationGrouping: document.getElementById('check-aggregation-grouping').checked,
          statisticalTransformations: document.getElementById('check-statistical-transformations').checked,
          textTransformations: document.getElementById('check-text-transformations').checked,
          spatialTransformations: document.getElementById('check-spatial-transformations').checked,
          customTransformations: document.getElementById('check-custom-transformations').checked
        };
        
        // Check if at least one option is selected
        if (!Object.values(transformationOptions).some(option => option)) {
          alert('Please select at least one transformation operation');
          return;
        }
        
        // Collect method options and custom inputs
        const methodOptions = {};
        const customInputs = {};
        
        // Mathematical transformations
        if (transformationOptions.mathematicalTransformations) {
          const mathSelect = document.getElementById('math-transformations-select');
          methodOptions.mathematicalTransformations = mathSelect.value;
          if (mathSelect.value === 'other') {
            customInputs.mathematicalTransformations = document.getElementById('math-transformations-custom-input').value.trim();
            if (!customInputs.mathematicalTransformations) {
              alert('Please specify custom mathematical transformation');
              return;
            }
          }
        }
        
        // New variables
        if (transformationOptions.newVariables) {
          const newVarSelect = document.getElementById('new-variables-select');
          methodOptions.newVariables = newVarSelect.value;
          if (newVarSelect.value === 'other') {
            customInputs.newVariables = document.getElementById('new-variables-custom-input').value.trim();
            if (!customInputs.newVariables) {
              alert('Please specify custom variable creation');
              return;
            }
          }
        }
        
        // Categorical transformations
        if (transformationOptions.categoricalTransformations) {
          const catSelect = document.getElementById('categorical-transformations-select');
          methodOptions.categoricalTransformations = catSelect.value;
          if (catSelect.value === 'other') {
            customInputs.categoricalTransformations = document.getElementById('categorical-transformations-custom-input').value.trim();
            if (!customInputs.categoricalTransformations) {
              alert('Please specify custom categorical transformation');
              return;
            }
          }
        }
        
        // Date/time transformations
        if (transformationOptions.dateTimeTransformations) {
          const dateSelect = document.getElementById('datetime-transformations-select');
          methodOptions.dateTimeTransformations = dateSelect.value;
          if (dateSelect.value === 'other') {
            customInputs.dateTimeTransformations = document.getElementById('datetime-transformations-custom-input').value.trim();
            if (!customInputs.dateTimeTransformations) {
              alert('Please specify custom date/time transformation');
              return;
            }
          }
        }
        
        // Merging & combining
        if (transformationOptions.mergingCombining) {
          const mergeSelect = document.getElementById('merging-combining-select');
          methodOptions.mergingCombining = mergeSelect.value;
          if (mergeSelect.value === 'other') {
            customInputs.mergingCombining = document.getElementById('merging-combining-custom-input').value.trim();
            if (!customInputs.mergingCombining) {
              alert('Please specify custom merging operation');
              return;
            }
          }
        }
        
        // Aggregation & grouping
        if (transformationOptions.aggregationGrouping) {
          const aggSelect = document.getElementById('aggregation-grouping-select');
          methodOptions.aggregationGrouping = aggSelect.value;
          if (aggSelect.value === 'other') {
            customInputs.aggregationGrouping = document.getElementById('aggregation-grouping-custom-input').value.trim();
            if (!customInputs.aggregationGrouping) {
              alert('Please specify custom aggregation');
              return;
            }
          }
        }
        
        // Statistical transformations
        if (transformationOptions.statisticalTransformations) {
          const statSelect = document.getElementById('statistical-transformations-select');
          methodOptions.statisticalTransformations = statSelect.value;
          if (statSelect.value === 'other') {
            customInputs.statisticalTransformations = document.getElementById('statistical-transformations-custom-input').value.trim();
            if (!customInputs.statisticalTransformations) {
              alert('Please specify custom statistical transformation');
              return;
            }
          }
        }
        
        // Text transformations
        if (transformationOptions.textTransformations) {
          const textSelect = document.getElementById('text-transformations-select');
          methodOptions.textTransformations = textSelect.value;
          if (textSelect.value === 'other') {
            customInputs.textTransformations = document.getElementById('text-transformations-custom-input').value.trim();
            if (!customInputs.textTransformations) {
              alert('Please specify custom text transformation');
              return;
            }
          }
        }
        
        // Spatial transformations
        if (transformationOptions.spatialTransformations) {
          const spatialSelect = document.getElementById('spatial-transformations-select');
          methodOptions.spatialTransformations = spatialSelect.value;
          if (spatialSelect.value === 'other') {
            customInputs.spatialTransformations = document.getElementById('spatial-transformations-custom-input').value.trim();
            if (!customInputs.spatialTransformations) {
              alert('Please specify custom spatial transformation');
              return;
            }
          }
        }
        
        // Custom transformations
        if (transformationOptions.customTransformations) {
          customInputs.customTransformations = document.getElementById('custom-transformations-custom-input').value.trim();
          if (!customInputs.customTransformations) {
            alert('Please specify custom transformation code');
            return;
          }
        }
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // FIXED: Hide transformation config when switching to chat
        const transformationConfig = document.getElementById('transformation-config');
        if (transformationConfig) {
          transformationConfig.style.display = 'none';
        }
        
        // Collect selected variables
        const selectedVariables = getSelectedVariables();
        
        // Send transformation agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_transformation_agent',
            dataframe: dataframe,
            transformation_options: transformationOptions,
            method_options: methodOptions,
            custom_inputs: customInputs,
            selected_variables: selectedVariables
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          // Switch to chat tab to show the transformation workflow
          switchTab('chat');
        }
      }
      
      // Handle agent-related WebSocket messages - COMPLETELY NEW FUNCTION NAME
      function handleAgentMessageNEW(data) {
        console.log(' NEW FUNCTION: handleAgentMessageNEW called!');
        console.log('Handling agent message:', data);
        console.log(' DEBUG: handleAgentMessageNEW called with action:', data.action);
        console.log(' CACHE BUST: This is the COMPLETELY NEW version!');
        console.log(' FORCE REFRESH: If you see this, the new code is running!');
        switch(data.action) {
                    case 'dataframes':
            console.log('Populating dataframes:', data.data);
            // Always populate all agents to avoid race conditions with tab switching
            try {
              console.log(' Populating cleaning agent...');
              populateDataFrameSelect(data.data);
              console.log(' populateDataFrameSelect completed successfully');
              
              console.log(' Populating transformation agent...');
              populateTransformationDataFrameSelect(data.data);
              console.log(' populateTransformationDataFrameSelect completed successfully');
              
              console.log(' Populating statistical agent...');
              populateStatisticalDataFrameSelect(data.data);
              console.log(' populateStatisticalDataFrameSelect completed successfully');
              
              console.log(' Populating modeling agent...');
              populateModelingDataFrameSelect(data.data);
              console.log(' populateModelingDataFrameSelect completed successfully');
              
              console.log(' All agents populated successfully');
            } catch (error) {
              console.error(' Error populating all agents:', error);
              console.error(' Error details:', error.message);
            }
            break;
          case 'dataframe_info':
            displayDataFrameInfo(data.data);
            // Also handle for modeling agent if that's the current context
            if (window.currentModelingDataframe) {
              handleModelingDataframeInfo(data.data);
            }
            // Also handle for statistical agent if that's the current context
            if (window.currentStatisticalDataframe) {
              handleStatisticalDataframeInfo(data.data);
            }
            break;
          case 'agent_started':
            handleAgentStarted(data.data);
            break;
          case 'transformation_agent_started':
            handleTransformationAgentStarted(data.data);
            break;
          case 'statistical_agent_started':
            handleStatisticalAgentStarted(data.data);
            break;
          case 'modeling_agent_started':
            handleModelingAgentStarted(data.data);
            break;
          case 'agent_step':
            handleAgentStep(data.data);
            break;
          case 'execute_code_response':
            console.log(' Received execute_code_response');
            console.log(' Code to execute:', data.code);
            
            // Store the code for later display
            currentStepCode = data.code;
            
            // Check if this is a custom transformation request
            if (data.code.includes(' Custom Transformation Request') && data.code.includes(' Sending custom transformation request to Claude')) {
              console.log(' Detected custom transformation request, sending to Claude');
              
              // Set flag to prevent duplicate requests
              window.customTransformationInProgress = true;
              
              // Send custom transformation request to Claude
              if (ws && ws.readyState === WebSocket.OPEN) {
                // Extract the custom request from the code
                const requestMatch = data.code.match(/Request: (.+?)\\n/);
                const customRequest = requestMatch ? requestMatch[1] : 'Custom transformation requested';
                
                // Create Claude prompt for custom transformation
                const claudePrompt = `I need you to perform a custom data transformation based on the following request:

**Custom Transformation Request:**
${customRequest}

**Dataset Information:**
- Dataset: ${currentAgentWorkflow?.dataframe || 'Unknown'}
- Variables: ${currentAgentWorkflow?.dataframe ? 'Available in workspace' : 'Unknown'}

Please provide:
1. A detailed transformation plan
2. Executable R code to perform the transformations
3. Data quality checks and validation
4. Summary of changes made

Code only. Minimal chat. Provide executable R code that can be run directly.`;

                // Send to Claude
                ws.send(JSON.stringify({
                  action: 'chat_with_ai',
                  message: claudePrompt,
                  conversation_context: 'custom_transformation'
                }));
              }
              break;
            }
            
            // Check if auto-execute is enabled before executing
            const autoExecute = isAutoExecuteEnabled();
            if (autoExecute) {
            // Automatically execute the next step's code
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log(' Auto-execute enabled: Sending execute_code request');
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: data.code
              }));
            } else {
              console.log(' WebSocket not available for execute_code');
              }
            } else {
              console.log(' Auto-execute disabled: Code will not be executed automatically');
              // Add the code as a message with execute button
              addMessage(data.code, 'ai');
            }
            break;
        }
      }
      
      // Populate DataFrame dropdown for main config
      function populateDataFrameSelect(dataframes) {
        console.log('populateDataFrameSelect called with:', dataframes);
        const select = document.getElementById('dataframe-select-main');
        const startBtn = document.getElementById('start-agent-btn');
        
        console.log('Select element found:', select);
        console.log('Start button found:', startBtn);
        
        if (!select) {
          console.error('dataframe-select-main element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log('Adding dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
          console.log('Final select innerHTML:', select.innerHTML);
        } else {
          console.error('dataframes is not an array:', dataframes);
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (startBtn) {
            startBtn.disabled = !this.value;
          }
          if (this.value) {
            // Uncheck all cleaning options when new dataframe is selected
            uncheckAllCleaningOptions();
            updateDataFrameInfoMain(this.value);
            // Populate variable selection
            populateVariableSelection(this.value);
          } else {
            const infoDiv = document.getElementById('dataframe-info-main');
            if (infoDiv) {
              infoDiv.style.display = 'none';
            }
            // Clear variable selection
            clearVariableSelection();
            // Reset button text
            const startBtn = document.getElementById('start-agent-btn');
            if (startBtn) {
              startBtn.textContent = 'Select a DataFrame';
              startBtn.disabled = true;
            }
          }
        };
        
      }
      
      // Variable Selection Functions
      function populateVariableSelection(dataframe, excludeTargetVariable = null) {
        console.log('Populating variable selection for:', dataframe);
        if (excludeTargetVariable) {
          console.log('Excluding target variable:', excludeTargetVariable);
        }
        
        // Request variable information from backend
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframe_variables',
            dataframe: dataframe,
            exclude_target_variable: excludeTargetVariable
          }));
        }
      }
      
      function clearVariableSelection() {
        const containers = document.querySelectorAll('[id$="-variable-container"]');
        containers.forEach(container => {
          container.innerHTML = '';
        });
      }
      
      function selectAllVariablesForOperation(operation) {
        const container = document.getElementById(`${operation}-variable-container`);
        if (container) {
          const checkboxes = container.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            checkbox.checked = true;
          });
        }
      }
      
      function selectNumericVariablesForOperation(operation) {
        const container = document.getElementById(`${operation}-variable-container`);
        if (container) {
          const checkboxes = container.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            const variableItem = checkbox.closest('.variable-checkbox-item');
            const typeSpan = variableItem.querySelector('.variable-type');
            if (typeSpan && typeSpan.textContent.includes('numeric')) {
              checkbox.checked = true;
            } else {
              checkbox.checked = false;
            }
          });
        }
      }
      
      function selectCategoricalVariablesForOperation(operation) {
        const container = document.getElementById(`${operation}-variable-container`);
        if (container) {
          const checkboxes = container.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            const variableItem = checkbox.closest('.variable-checkbox-item');
            const typeSpan = variableItem.querySelector('.variable-type');
            if (typeSpan && typeSpan.textContent.includes('categorical')) {
              checkbox.checked = true;
            } else {
              checkbox.checked = false;
            }
          });
        }
      }
      
      function selectNoneVariablesForOperation(operation) {
        const container = document.getElementById(`${operation}-variable-container`);
        if (container) {
          const checkboxes = container.querySelectorAll('input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            checkbox.checked = false;
          });
        }
      }
      
      function renderVariableSelection(variables) {
        console.log('Rendering variable selection with variables:', variables);
        const containers = document.querySelectorAll('[id$="-variable-container"]');
        
        containers.forEach(container => {
          container.innerHTML = '';
          
          if (!variables || variables.length === 0) {
            container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No variables found</div>';
            return;
          }
          
          variables.forEach(variable => {
            const item = document.createElement('div');
            item.className = 'variable-checkbox-item';
            
            const typeClass = variable.type === 'numeric' ? 'numeric' : 'categorical';
            
            item.innerHTML = `
              <input type="checkbox" id="var-${variable.name}" checked>
              <div class="variable-info">
                <span class="variable-name">${variable.name}</span>
                <span class="variable-type ${typeClass}">(${variable.type})</span>
              </div>
            `;
            
            container.appendChild(item);
          });
        });
      }
      
      function getSelectedVariables() {
        const selectedVars = {};
        
        // Get variables for cleaning operations
        const cleaningOperations = ['data-types', 'missing-values', 'duplicates', 'outliers', 'column-names'];
        
        cleaningOperations.forEach(operation => {
          const container = document.getElementById(`${operation}-variable-container`);
          if (container) {
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const vars = [];
            
            checkboxes.forEach(checkbox => {
              const varName = checkbox.id.replace('var-', '');
              const typeSpan = checkbox.parentElement.querySelector('.variable-type');
              const varType = typeSpan ? typeSpan.textContent.replace(/[()]/g, '') : 'unknown';
              
              vars.push({
                name: varName,
                type: varType
              });
            });
            
            selectedVars[operation] = vars;
          }
        });
        
        // Get variables for transformation operations
        const transformationOperations = ['mathematical', 'new-variables', 'categorical', 'datetime', 'merging', 'aggregation', 'statistical', 'text', 'spatial', 'custom'];
        
        transformationOperations.forEach(operation => {
          const container = document.getElementById(`${operation}-variable-container`);
          if (container) {
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const vars = [];
            
            checkboxes.forEach(checkbox => {
              const varName = checkbox.id.replace('var-', '');
              const typeSpan = checkbox.parentElement.querySelector('.variable-type');
              const varType = typeSpan ? typeSpan.textContent.replace(/[()]/g, '') : 'unknown';
              
              vars.push({
                name: varName,
                type: varType
              });
            });
            
            selectedVars[operation] = vars;
          }
        });
        
        // Get variables for modeling operations
        const modelingOperations = ['dimensionality-reduction', 'linear-regression', 'logistic-regression', 'multinomial-regression', 'random-forest', 'xgboost', 'feature-engineering', 'custom-modeling'];
        
        modelingOperations.forEach(operation => {
          const container = document.getElementById(`${operation}-variable-container`);
          if (container) {
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const vars = [];
            
            checkboxes.forEach(checkbox => {
              const varName = checkbox.id.replace('var-', '');
              const typeSpan = checkbox.parentElement.querySelector('.variable-type');
              const varType = typeSpan ? typeSpan.textContent.replace(/[()]/g, '') : 'unknown';
              
              vars.push({
                name: varName,
                type: varType
              });
            });
            
            selectedVars[operation] = vars;
          }
        });
        
        return selectedVars;
      }
      

      
      // Populate DataFrame dropdown for transformation config
      function populateTransformationDataFrameSelect(dataframes) {
        console.log(' populateTransformationDataFrameSelect called with:', dataframes);
        const select = document.getElementById('transformation-dataframe-select');
        const startBtn = document.getElementById('start-transformation-btn');
        
        console.log(' Transformation select found:', select);
        console.log(' Transformation start button found:', startBtn);
        
        if (!select) {
          console.error('transformation-dataframe-select element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log(' Adding transformation dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
          console.log(' Final transformation select innerHTML:', select.innerHTML);
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (this.value) {
            updateTransformationDataFrameInfo();
            // FIXED: Update start button state after dataframe info is loaded
            setTimeout(() => updateTransformationStartButton(), 100);
          } else {
            const checklist = document.getElementById('transformation-checklist');
            if (checklist) {
              checklist.style.display = 'none';
            }
            // FIXED: Disable start button when no dataframe selected
            if (startBtn) {
              startBtn.disabled = true;
              startBtn.textContent = 'Select a DataFrame first';
              startBtn.title = 'Please select a DataFrame to continue';
            }
          }
        };
      }
      
      // Populate DataFrame dropdown for statistical config
      function populateStatisticalDataFrameSelect(dataframes) {
        console.log(' populateStatisticalDataFrameSelect called with:', dataframes);
        const select = document.getElementById('statistical-dataframe-select');
        const startBtn = document.getElementById('start-statistical-btn');
        
        console.log(' Statistical select found:', select);
        console.log(' Statistical start button found:', startBtn);
        
        if (!select) {
          console.error('statistical-dataframe-select element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log(' Adding statistical dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
          console.log(' Final statistical select innerHTML:', select.innerHTML);
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (this.value) {
            updateStatisticalDataFrameInfo();
            // FIXED: Update start button state after dataframe info is loaded
            setTimeout(() => updateStatisticalStartButton(), 100);
          } else {
            const checklist = document.getElementById('statistical-checklist');
            if (checklist) {
              checklist.style.display = 'none';
            }
            // FIXED: Disable start button when no dataframe selected
            if (startBtn) {
              startBtn.disabled = true;
              startBtn.textContent = 'Select a DataFrame first';
              startBtn.title = 'Please select a DataFrame to continue';
            }
          }
        };
      }
      
      // Populate DataFrame dropdown for modeling config
      function populateModelingDataFrameSelect(dataframes) {
        console.log(' populateModelingDataFrameSelect called with:', dataframes);
        const select = document.getElementById('modeling-dataframe-select');
        const startBtn = document.getElementById('start-modeling-btn');
        
        console.log(' Modeling select found:', select);
        console.log(' Modeling start button found:', startBtn);
        
        if (!select) {
          console.error('modeling-dataframe-select element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log(' Adding modeling dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
          console.log(' Final modeling select innerHTML:', select.innerHTML);
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (this.value) {
            updateModelingDataFrameInfo();
            // Update start button state after dataframe info is loaded
            setTimeout(() => updateModelingStartButton(), 100);
          } else {
            const checklist = document.getElementById('modeling-checklist');
            if (checklist) {
              checklist.style.display = 'none';
            }
            // Disable start button when no dataframe selected
            if (startBtn) {
              startBtn.disabled = true;
              startBtn.textContent = 'Select a DataFrame first';
              startBtn.title = 'Please select a DataFrame to continue';
            }
          }
        };
      }
      
      // Populate variable dropdowns for modeling analysis
      function populateModelingVariableDropdowns(dataframeName) {
        if (!dataframeName) return;
        
        try {
          // Store the current dataframe name for when we receive the info
          window.currentModelingDataframe = dataframeName;
          
          // Get dataframe info from R
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: dataframeName
            }));
          }
          
          // Provide immediate fallback with placeholder variables while we wait for real data
          // This ensures the UI is functional even if dataframe info doesn't arrive
          const continuousVars = ['Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width'];
          const categoricalVars = ['Species'];
          
          // Store variable types globally for algorithm filtering (will be updated when real data arrives)
          window.modelingVariableTypes = {};
          continuousVars.forEach(varName => {
            window.modelingVariableTypes[varName] = {
              type: 'numeric'
            };
          });
          categoricalVars.forEach(varName => {
            window.modelingVariableTypes[varName] = {
              type: 'categorical',
              categories: 3 // Placeholder
            };
          });
          
          // Populate target variable dropdown immediately
          const targetDropdown = document.getElementById('modeling-target-variable');
          if (targetDropdown) {
            targetDropdown.innerHTML = '<option value="">-- Select Target Variable --</option>';
            
            // Add continuous variables
            continuousVars.forEach(varName => {
              const option = document.createElement('option');
              option.value = varName;
              option.textContent = `${varName} (numeric)`;
              targetDropdown.appendChild(option);
            });
            
            // Add categorical variables
            categoricalVars.forEach(varName => {
              const option = document.createElement('option');
              option.value = varName;
              option.textContent = `${varName} (categorical)`;
              targetDropdown.appendChild(option);
            });
          }
          
        } catch (error) {
          console.error('Error populating modeling variable dropdowns:', error);
        }
      }
      
      // Handle dataframe info specifically for modeling agent
      function handleModelingDataframeInfo(dataframeInfo) {
        try {
          if (!dataframeInfo || !window.currentModelingDataframe) return;
          
          console.log(' Processing dataframe info for modeling:', dataframeInfo);
          
          // Check if we have proper column info to update the variables
          const hasColumns = dataframeInfo.columns || dataframeInfo.column_info;
          if (!hasColumns) {
            console.log(' No column info in dataframe response, keeping placeholder variables');
            return; // Keep the placeholder variables that were already populated
          }
          
          // Store variable types and category counts globally for algorithm filtering
          const newVariableTypes = {};
          
          const targetDropdown = document.getElementById('modeling-target-variable');
          if (targetDropdown) {
            // Clear existing options except the first
            targetDropdown.innerHTML = '<option value="">-- Select Target Variable --</option>';
            
            // Process each column from the dataframe info
            const columns = dataframeInfo.columns || dataframeInfo.column_info || {};
            Object.entries(columns).forEach(([varName, colInfo]) => {
              const colType = colInfo.type || colInfo.class || 'unknown';
              
              if (colType === 'numeric' || colType === 'integer' || colType === 'double') {
                // Store as numeric
                newVariableTypes[varName] = {
                  type: 'numeric',
                  min: colInfo.min,
                  max: colInfo.max,
                  mean: colInfo.mean
                };
                
                // Add to dropdown
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = `${varName} (numeric)`;
                targetDropdown.appendChild(option);
                
              } else if (colType === 'factor' || colType === 'character' || colType === 'categorical') {
                // Count unique categories
                const uniqueCount = colInfo.unique_count || colInfo.unique || colInfo.levels?.length || 2;
                
                // Store as categorical with category count
                newVariableTypes[varName] = {
                  type: 'categorical',
                  categories: uniqueCount,
                  levels: colInfo.levels || []
                };
                
                // Add to dropdown with category count
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = `${varName} (categorical, ${uniqueCount} categories)`;
                targetDropdown.appendChild(option);
                
              } else {
                // Unknown type - treat as categorical with unknown count
                newVariableTypes[varName] = {
                  type: 'categorical',
                  categories: 2 // Default fallback
                };
                
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = `${varName} (${colType})`;
                targetDropdown.appendChild(option);
              }
            });
            
            // Only update if we successfully processed some variables
            if (Object.keys(newVariableTypes).length > 0) {
              window.modelingVariableTypes = newVariableTypes;
              console.log(' Updated modeling variable types with real data:', window.modelingVariableTypes);
            } else {
              console.log(' No variables processed from dataframe info, keeping placeholders');
            }
          }
          
        } catch (error) {
          console.error('Error handling modeling dataframe info:', error);
          console.log(' Keeping placeholder variables due to error');
        }
      }
      
      // Update algorithm options based on target variable type
      function updateAlgorithmOptions() {
        const targetVariable = document.getElementById('modeling-target-variable').value;
        
        if (!targetVariable || !window.modelingVariableTypes) {
          // Hide all algorithms if no target selected
          showAllAlgorithms();
          return;
        }
        
        const targetInfo = window.modelingVariableTypes[targetVariable];
        const targetType = typeof targetInfo === 'string' ? targetInfo : targetInfo.type;
        
        // Algorithm groups to show/hide based on target type
        const regressionOnlyGroups = ['linear-regression-group'];
        const binaryClassificationGroups = ['logistic-regression-group'];
        const multiClassificationGroups = ['multinomial-regression-group'];
        // Random Forest and XGBoost work for both regression and classification
        
        if (targetType === 'numeric') {
          // For numeric targets: show regression algorithms, hide classification-only
          showAlgorithmGroups(regressionOnlyGroups);
          hideAlgorithmGroups([...binaryClassificationGroups, ...multiClassificationGroups]);
          console.log(' Numeric target selected - showing regression algorithms');
          
        } else if (targetType === 'categorical') {
          // Hide regression algorithms for categorical targets
          hideAlgorithmGroups(regressionOnlyGroups);
          
          // Check number of categories for intelligent algorithm suggestions
          const categoryCount = targetInfo.categories || 2; // Default to 2 if unknown
          
          if (categoryCount === 2) {
            // Binary classification: show logistic regression, hide multinomial
            showAlgorithmGroups(binaryClassificationGroups);
            hideAlgorithmGroups(multiClassificationGroups);
            console.log(' Binary classification target (2 categories) - showing logistic regression');
            
          } else if (categoryCount > 2) {
            // Multi-class classification: show multinomial, hide logistic regression
            showAlgorithmGroups(multiClassificationGroups);
            hideAlgorithmGroups(binaryClassificationGroups);
            console.log(` Multi-class classification target (${categoryCount} categories) - showing multinomial regression`);
            
          } else {
            // Unknown category count: show both classification algorithms
            showAlgorithmGroups([...binaryClassificationGroups, ...multiClassificationGroups]);
            console.log(' Categorical target (unknown categories) - showing all classification algorithms');
          }
        }
        
        // Update the start button state since algorithm availability changed
        updateModelingStartButton();
        
        // Refresh variable selection to exclude the new target variable
        const dataframe = document.getElementById('modeling-dataframe-select').value;
        if (dataframe) {
          populateVariableSelection(dataframe, targetVariable);
        }
      }
      
      // Helper function to show algorithm groups
      function showAlgorithmGroups(groupIds) {
        groupIds.forEach(groupId => {
          const group = document.getElementById(groupId);
          if (group) {
            group.style.display = 'block';
          }
        });
      }
      
      // Helper function to hide algorithm groups and uncheck them
      function hideAlgorithmGroups(groupIds) {
        groupIds.forEach(groupId => {
          const group = document.getElementById(groupId);
          if (group) {
            group.style.display = 'none';
            // Uncheck the algorithm if it was selected
            const checkbox = group.querySelector('input[type="checkbox"]');
            if (checkbox) {
              checkbox.checked = false;
            }
          }
        });
      }
      
      // Show all algorithms (when no target is selected)
      function showAllAlgorithms() {
        const allAlgorithmGroups = ['linear-regression-group', 'logistic-regression-group', 'multinomial-regression-group'];
        showAlgorithmGroups(allAlgorithmGroups);
      }
      
      // Populate variable dropdowns for statistical analysis
      function populateStatisticalVariableDropdowns(dataframeName) {
        if (!dataframeName) return;
        
        try {
          // Get dataframe info from R
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: dataframeName
            }));
          }
          
          // Clear dropdowns and show loading state - real data will populate when response arrives
          const allDropdowns = [
            'statistical-continuous-var',
            'statistical-before-var',
            'statistical-after-var',
            'nonparametric-continuous-var',
            'statistical-grouping-var',
            'nonparametric-grouping-var',
            'categorical-var1',
            'categorical-var2'
          ];
          
          allDropdowns.forEach(dropdownId => {
            const dropdown = document.getElementById(dropdownId);
            if (dropdown) {
              dropdown.innerHTML = '<option value="">-- Loading variables... --</option>';
            }
          });
          
        } catch (error) {
          console.error('Error populating statistical variable dropdowns:', error);
        }
      }
      
      // Handle statistical dataframe info response and populate variable dropdowns with real data
      function handleStatisticalDataframeInfo(dataframeInfo) {
        try {
          if (!dataframeInfo || !window.currentStatisticalDataframe) return;
          
          console.log(' Processing dataframe info for statistical agent:', dataframeInfo);
          
          // Check if we have proper column info to update the variables
          const hasColumns = dataframeInfo.columns || dataframeInfo.column_info;
          if (!hasColumns) {
            console.log(' No column info in dataframe response for statistical agent, keeping loading state');
            return; // Keep the loading state - real column info will come later
          }
          
          // Store detailed variable information globally for guidance system
          window.statisticalVariableInfo = {};
          
          // Separate variables by type with detailed info
          const continuousVars = [];
          const categoricalVars = [];
          
          // Get columns from either structure
          const columns = dataframeInfo.columns || dataframeInfo.column_info || {};
          
          Object.entries(columns).forEach(([varName, colInfo]) => {
            const colType = colInfo.type || colInfo.class || 'unknown';
            
            // Store detailed info for guidance system
            window.statisticalVariableInfo[varName] = {
              type: colType,
              min: colInfo.min,
              max: colInfo.max,
              mean: colInfo.mean,
              levels: colInfo.levels,
              unique_count: colInfo.unique_count,
              na_count: colInfo.na_count
            };
            
            if (colType === 'numeric' || colType === 'integer' || colType === 'double') {
              continuousVars.push({
                name: varName,
                type: colType,
                min: colInfo.min,
                max: colInfo.max,
                mean: colInfo.mean
              });
            } else if (colType === 'categorical' || colType === 'factor' || colType === 'character' || colType === 'logical') {
              categoricalVars.push({
                name: varName,
                type: colType,
                levels: colInfo.levels || [],
                unique_count: colInfo.unique_count
              });
            }
          });
          
          console.log(' Statistical agent variables - Continuous:', continuousVars, 'Categorical:', categoricalVars);
          
          // Populate continuous variable dropdowns
          const continuousDropdowns = [
            'statistical-continuous-var',
            'statistical-before-var',
            'statistical-after-var',
            'nonparametric-continuous-var'
          ];
          
          continuousDropdowns.forEach(dropdownId => {
            const dropdown = document.getElementById(dropdownId);
            if (dropdown) {
              dropdown.innerHTML = '<option value="">-- Select Variable --</option>';
              continuousVars.forEach(varInfo => {
                const option = document.createElement('option');
                option.value = varInfo.name;
                
                // Enhanced display with type indicators
                let displayText = `${varInfo.name} (${varInfo.type})`;
                if (varInfo.min !== undefined && varInfo.max !== undefined) {
                  displayText += ` [${varInfo.min?.toFixed(1)} - ${varInfo.max?.toFixed(1)}]`;
                } else if (varInfo.mean !== undefined) {
                  displayText += ` (mean: ${varInfo.mean?.toFixed(1)})`;
                }
                
                option.textContent = displayText;
                dropdown.appendChild(option);
              });
            }
          });
          
          // Populate categorical variable dropdowns
          const categoricalDropdowns = [
            'statistical-grouping-var',
            'nonparametric-grouping-var',
            'categorical-var1',
            'categorical-var2'
          ];
          
          categoricalDropdowns.forEach(dropdownId => {
            const dropdown = document.getElementById(dropdownId);
            if (dropdown) {
              dropdown.innerHTML = '<option value="">-- Select Variable --</option>';
              categoricalVars.forEach(varInfo => {
                const option = document.createElement('option');
                option.value = varInfo.name;
                
                // Enhanced display with level indicators
                let displayText = `${varInfo.name} (${varInfo.type})`;
                if (varInfo.levels && varInfo.levels.length > 0) {
                  displayText += ` [${varInfo.levels.length} levels: ${varInfo.levels.slice(0, 2).join(', ')}${varInfo.levels.length > 2 ? '...' : ''}]`;
                } else if (varInfo.unique_count !== undefined) {
                  displayText += ` [${varInfo.unique_count} unique values]`;
                }
                
                option.textContent = displayText;
                dropdown.appendChild(option);
              });
            }
          });
          
          console.log(' Statistical agent variable dropdowns updated with real data');
          
        } catch (error) {
          console.error('Error handling statistical dataframe info:', error);
        }
      }
      
      // Dynamic guidance system for group comparison test selection
      function updateGroupComparisonGuidance() {
        try {
          const testTypeSelect = document.getElementById('group-comparisons-select');
          const continuousVar = document.getElementById('statistical-continuous-var').value;
          const groupingVar = document.getElementById('statistical-grouping-var').value;
          const guidanceDiv = document.getElementById('group-comparison-guidance');
          const guidanceText = document.getElementById('guidance-text');
          
          if (!continuousVar || !groupingVar || !window.statisticalVariableInfo) {
            guidanceDiv.style.display = 'none';
            return;
          }
          
          const contInfo = window.statisticalVariableInfo[continuousVar];
          const groupInfo = window.statisticalVariableInfo[groupingVar];
          
          if (!contInfo || !groupInfo) {
            guidanceDiv.style.display = 'none';
            return;
          }
          
          // Determine number of groups
          const numGroups = groupInfo.levels ? groupInfo.levels.length : groupInfo.unique_count || 2;
          
          // Generate intelligent recommendations
          let recommendation = '';
          let suggestedTest = '';
          
          if (numGroups === 2) {
            recommendation = `Two groups detected (${groupInfo.levels ? groupInfo.levels.join(' vs ') : 'binary variable'}). `;
            if (testTypeSelect.value === 'automatic') {
              recommendation += 'Recommended: Independent t-test (parametric) or Mann-Whitney U (non-parametric).';
              suggestedTest = 'independent_ttest';
            }
          } else if (numGroups >= 3) {
            recommendation = `${numGroups} groups detected. `;
            if (testTypeSelect.value === 'automatic') {
              recommendation += 'Recommended: One-way ANOVA (parametric) or Kruskal-Wallis (non-parametric).';
              suggestedTest = 'one_way_anova';
            }
          }
          
          // Add data distribution info
          if (contInfo.min !== undefined && contInfo.max !== undefined) {
            recommendation += ` Data range: ${contInfo.min.toFixed(1)} - ${contInfo.max.toFixed(1)}.`;
          }
          
          // Validate current selection
          const currentTest = testTypeSelect.value;
          let validation = '';
          
          if (currentTest === 'independent_ttest' && numGroups !== 2) {
            validation = '  Warning: Independent t-test requires exactly 2 groups.';
          } else if (currentTest === 'welch_ttest' && numGroups !== 2) {
            validation = '  Warning: Welch\'s t-test requires exactly 2 groups.';
          } else if (currentTest === 'mann_whitney' && numGroups !== 2) {
            validation = '  Warning: Mann-Whitney U test requires exactly 2 groups.';
          } else if ((currentTest === 'one_way_anova' || currentTest === 'kruskal_wallis') && numGroups < 3) {
            validation = '  Warning: This test is designed for 3+ groups.';
          }
          
          guidanceText.textContent = recommendation + validation;
          guidanceDiv.style.display = 'block';
          
          // Auto-suggest test if on automatic mode
          if (testTypeSelect.value === 'automatic' && suggestedTest) {
            // Don't change the dropdown, just show the recommendation
          }
          
        } catch (error) {
          console.error('Error updating group comparison guidance:', error);
        }
      }
      
      // Update DataFrame info for main config
      function updateDataFrameInfoMain(dfName) {
        console.log(' updateDataFrameInfoMain called with:', dfName);
        const startBtn = document.getElementById('start-agent-btn');
        const cleaningChecklist = document.getElementById('cleaning-checklist');
        
        console.log(' Start button found:', startBtn);
        console.log(' Cleaning checklist found:', cleaningChecklist);
        
        if (startBtn) {
          startBtn.disabled = false;
          startBtn.textContent = ' Start Cleaning Agent';
          console.log(' Start button enabled');
        }
        
        // Show cleaning checklist
        if (cleaningChecklist) {
          cleaningChecklist.style.display = 'block';
          console.log(' Cleaning checklist shown');
        } else {
          console.error(' Cleaning checklist not found!');
        }
        
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframe_info',
            dataframe: dfName
          }));
        }
      }
      
      // Update DataFrame info for transformation config
      function updateTransformationDataFrameInfo() {
        const select = document.getElementById('transformation-dataframe-select');
        const startBtn = document.getElementById('start-transformation-btn');
        const checklist = document.getElementById('transformation-checklist');
        
        if (select.value) {
          // Show transformation checklist
          if (checklist) {
            checklist.style.display = 'block';
          }
          
          // Populate variable selection
          populateVariableSelection(select.value);
          
          // Get dataframe info
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: select.value
            }));
          }
          
          // FIXED: Don't enable start button here - let updateTransformationStartButton handle it
          // This ensures proper validation of checkbox selections
        } else {
          // Disable start button and hide checklist
          if (startBtn) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          }
          if (checklist) {
            checklist.style.display = 'none';
          }
        }
      }
      
      // Update DataFrame info for statistical config
      function updateStatisticalDataFrameInfo() {
        const select = document.getElementById('statistical-dataframe-select');
        const startBtn = document.getElementById('start-statistical-btn');
        const checklist = document.getElementById('statistical-checklist');
        
        if (select.value) {
          // Show statistical checklist
          if (checklist) {
            checklist.style.display = 'block';
          }
          
          // Set current statistical dataframe for response handling
          window.currentStatisticalDataframe = select.value;
          
          // Get dataframe info
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: select.value
            }));
          }
          
          // Populate variable dropdowns for statistical analysis (will show loading state)
          populateStatisticalVariableDropdowns(select.value);
          
          // FIXED: Don't enable start button here - let updateStatisticalStartButton handle it
          // This ensures proper validation of checkbox selections
        } else {
          // Clear current statistical dataframe
          window.currentStatisticalDataframe = null;
          
          // Disable start button and hide checklist
          if (startBtn) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          }
          if (checklist) {
            checklist.style.display = 'none';
          }
          
          // Clear variable selection
          clearVariableSelection();
        }
      }
      
      // Update DataFrame info for modeling config
      function updateModelingDataFrameInfo() {
        const select = document.getElementById('modeling-dataframe-select');
        const startBtn = document.getElementById('start-modeling-btn');
        const checklist = document.getElementById('modeling-checklist');
        const targetSection = document.getElementById('target-variable-section');
        
        if (select.value) {
          // Show modeling checklist
          if (checklist) {
            checklist.style.display = 'block';
          }
          
          // Show target variable section for supervised learning
          if (targetSection) {
            targetSection.style.display = 'block';
          }
          
          // Get dataframe info
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: select.value
            }));
          }
          
          // Populate variable dropdowns for modeling analysis
          populateModelingVariableDropdowns(select.value);
          
          // Populate variable selection (exclude target variable for modeling)
          const targetVariable = document.getElementById('modeling-target-variable').value;
          populateVariableSelection(select.value, targetVariable);
          
          // Don't enable start button here - let updateModelingStartButton handle it
        } else {
          // Disable start button and hide checklist
          if (startBtn) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          }
          if (checklist) {
            checklist.style.display = 'none';
          }
          if (targetSection) {
            targetSection.style.display = 'none';
          }
          
          // Clear variable selection
          clearVariableSelection();
        }
      }
      
      // Update modeling start button state
      function updateModelingStartButton() {
        const startBtn = document.getElementById('start-modeling-btn');
        const targetVariable = document.getElementById('modeling-target-variable').value;
        
        if (!startBtn) return;
        
        // Check if at least one algorithm is selected
        const algorithms = [
          'check-dimensionality-reduction',
          'check-linear-regression',
          'check-logistic-regression',
          'check-multinomial-regression',
          'check-random-forest',
          'check-xgboost',
          'check-custom-modeling'
        ];
        
        const hasAlgorithm = algorithms.some(id => document.getElementById(id).checked);
        
        // Always require target variable for supervised learning
        const hasTarget = targetVariable;
        
        if (hasAlgorithm && hasTarget) {
          startBtn.disabled = false;
          startBtn.textContent = ' Start Modeling Agent';
          startBtn.title = 'Click to start the modeling agent';
        } else {
          startBtn.disabled = true;
          if (!hasAlgorithm) {
            startBtn.textContent = 'Select algorithms first';
            startBtn.title = 'Please select at least one machine learning algorithm';
          } else if (!hasTarget) {
            startBtn.textContent = 'Select target variable first';
            startBtn.title = 'Please select a target variable for supervised learning';
          } else {
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          }
        }
      }
      
      // Start cleaning agent (simplified)
      function startCleaningAgentSimple() {
        const dataframe = document.getElementById('dataframe-select-main').value;
        
        if (!dataframe) {
          alert('Please select a DataFrame');
          return;
        }
        
        // Collect selected cleaning operations
        const cleaningOptions = {
          dataTypes: document.getElementById('check-data-types').checked,
          missingValues: document.getElementById('check-missing-values').checked && !document.getElementById('check-missing-values').disabled,
          duplicates: document.getElementById('check-duplicates').checked,
          outliers: document.getElementById('check-outliers').checked,
          columnNames: document.getElementById('check-column-names').checked,
          other: document.getElementById('check-other').checked
        };
        
        // Collect selected variables
        const selectedVariables = getSelectedVariables();
        
        // Collect method options for each operation
        const methodOptions = {
          dataTypes: document.getElementById('data-type-method-select')?.value || 'automatic',
          missingValues: document.getElementById('na-handling-select')?.value || 'dont',
          outliers: document.getElementById('outlier-method-select')?.value || 'iqr',
          columnNames: document.getElementById('column-naming-select')?.value || 'snake_case'
        };
        
        // Get custom text inputs for "Other" methods
        const customInputs = {
          dataTypes: document.getElementById('data-type-custom-input')?.value.trim() || '',
          missingValues: document.getElementById('missing-values-custom-input')?.value.trim() || '',
          outliers: document.getElementById('outlier-custom-input')?.value.trim() || '',
          columnNames: document.getElementById('column-naming-custom-input')?.value.trim() || ''
        };
        
        // Get other operations text if selected
        const otherOperations = cleaningOptions.other ? 
          document.getElementById('other-operations-input').value.trim() : '';
        
        const naHandling = cleaningOptions.missingValues ? 
          document.getElementById('na-handling-select').value : 'dont';
        
        // Validate that all checked "Other" options have content
        if (!validateOtherInputs()) {
          const invalidOptions = getInvalidOtherOptions();
          alert(`Please fill in the following "Other" options before starting:\n\n${invalidOptions.join('\n')}`);
          return;
        }
        
        console.log('Starting agent with:', { 
          dataframe, 
          naHandling, 
          cleaningOptions,
          selectedVariables
        });
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // Send agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_cleaning_agent',
            dataframe: dataframe,
            na_handling: naHandling,
            cleaning_options: cleaningOptions,
            method_options: methodOptions,
            custom_inputs: customInputs,
            other_operations: otherOperations,
            selected_variables: selectedVariables
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
        }
      }
      
      // Display DataFrame information
      function displayDataFrameInfo(dfInfo) {
        const infoDiv = document.getElementById('dataframe-info-main');
        const cleaningChecklist = document.getElementById('cleaning-checklist');
        const missingValuesGroup = document.getElementById('missing-values-group');
        const missingValuesCheckbox = document.getElementById('check-missing-values');
        const missingHandlingOptions = document.getElementById('missing-handling-options');
        
        if (dfInfo.exists) {
          const missingCounts = Object.entries(dfInfo.column_info)
            .filter(([col, info]) => info.missing > 0)
            .map(([col, info]) => `${col}: ${info.missing}`)
            .join(', ');
          
          const hasMissingValues = missingCounts.length > 0;
          
          infoDiv.innerHTML = `
            <strong>${dfInfo.name}</strong><br>
             ${dfInfo.nrow} rows  ${dfInfo.ncol} columns<br>
             Size: ${dfInfo.size_mb} MB<br>
            ${hasMissingValues ? ` Missing values: ${missingCounts}` : ' No missing values'}
          `;
          infoDiv.style.display = 'block';
          
          // Show cleaning checklist
          cleaningChecklist.style.display = 'block';
          
          // Always enable missing values option - let user decide
            missingValuesGroup.classList.remove('disabled');
            missingValuesCheckbox.disabled = false;
          console.log('Missing values option always enabled - user can check/uncheck as needed');
          
          // Set up checkbox interactions
          setupCheckboxInteractions();
          
          // Add event listeners to enable/disable start button based on selections
          addCleaningOptionListeners();
          

          
        } else {
          infoDiv.innerHTML = ` ${dfInfo.error}`;
          infoDiv.style.display = 'block';
          cleaningChecklist.style.display = 'none';
        }
      }
      
      // Toggle mode (Auto Execute or Ask) - simple click toggle
      function toggleMode() {
        const toggle = document.getElementById('auto-execute-toggle');
        const button = document.getElementById('mode-selector-button');
        
        if (toggle && button) {
          // Toggle the checkbox state
          toggle.checked = !toggle.checked;
          
          // Update button text based on current state
          if (toggle.checked) {
            button.textContent = 'Auto Execute';
          } else {
            button.textContent = 'Ask';
          }
          
          // Update mode status indicator
          updateModeStatus();
          
          console.log(' Mode changed to:', toggle.checked ? 'Auto Execute' : 'Ask');
        }
      }
      
      // Track last mode to avoid duplicate messages
      let lastModeStatus = null;
      
      // Update mode status indicator in chat
      function updateModeStatus() {
        const toggle = document.getElementById('auto-execute-toggle');
        
        if (toggle) {
          const currentMode = toggle.checked ? 'auto' : 'ask';
          
          // Only add message if mode changed
          if (lastModeStatus !== null && lastModeStatus !== currentMode) {
            const modeText = toggle.checked ? 'Auto Execute On' : 'Ask Mode On';
            addMessage(`**Mode Changed:** ${modeText}`, 'ai');
          }
          
          lastModeStatus = currentMode;
        }
      }
      
      // Set mode (for initialization and programmatic changes)
      function setMode(mode) {
        const toggle = document.getElementById('auto-execute-toggle');
        const button = document.getElementById('mode-selector-button');
        
        if (toggle && button) {
          if (mode === 'auto') {
            toggle.checked = true;
            button.textContent = 'Auto Execute';
          } else {
            toggle.checked = false;
            button.textContent = 'Ask';
          }
          
          // Update mode status indicator
          updateModeStatus();
          
          console.log(' Mode set to:', mode);
        }
      }
      
      // Get current auto-execute toggle state
      function isAutoExecuteEnabled() {
        const toggle = document.getElementById('auto-execute-toggle');
        return toggle ? toggle.checked : true; // Default to true if toggle not found
      }
      
      // Uncheck all cleaning options when new dataframe is selected
      function uncheckAllCleaningOptions() {
        // Uncheck all checkboxes
        document.getElementById('check-data-types').checked = false;
        document.getElementById('check-missing-values').checked = false;
        document.getElementById('check-duplicates').checked = false;
        document.getElementById('check-outliers').checked = false;
        document.getElementById('check-column-names').checked = false;
        document.getElementById('check-other').checked = false;
        
        // Hide all sub-options
        document.getElementById('missing-handling-options').style.display = 'none';
        document.getElementById('other-options').style.display = 'none';
        document.getElementById('data-type-options').style.display = 'none';
        document.getElementById('outlier-method-options').style.display = 'none';
        document.getElementById('column-naming-options').style.display = 'none';
        
        // Clear all custom input fields
        document.getElementById('other-operations-input').value = '';
        document.getElementById('data-type-custom-input').value = '';
        document.getElementById('missing-values-custom-input').value = '';
        document.getElementById('outlier-custom-input').value = '';
        document.getElementById('column-naming-custom-input').value = '';
        
        // Hide all "Other" input fields
        document.getElementById('data-type-other-input').style.display = 'none';
        document.getElementById('missing-values-other-input').style.display = 'none';
        document.getElementById('outlier-other-input').style.display = 'none';
        document.getElementById('column-naming-other-input').style.display = 'none';
        
        // Disable start button until user selects at least one option
        const startBtn = document.getElementById('start-agent-btn');
        if (startBtn) {
          startBtn.disabled = true;
        }
        
        // Re-validate the start button state
        updateStartButton();
      }
      
      // Function to check if all selected "Other" options have content
      function validateOtherInputs() {
        const otherInputs = [
          { 
            checkbox: 'check-data-types', 
            input: 'data-type-custom-input',
            methodSelect: 'data-type-method-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-missing-values', 
            input: 'missing-values-custom-input',
            methodSelect: 'na-handling-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-outliers', 
            input: 'outlier-custom-input',
            methodSelect: 'outlier-method-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-column-names', 
            input: 'column-naming-custom-input',
            methodSelect: 'column-naming-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-other', 
            input: 'other-operations-input',
            methodSelect: null,
            methodValue: null
          }
        ];
        
        // Check if any "Other" checkbox is checked but has no content
        const hasInvalidOther = otherInputs.some(({ checkbox, input, methodSelect, methodValue }) => {
          const checkboxEl = document.getElementById(checkbox);
          const inputEl = document.getElementById(input);
          
          if (!checkboxEl.checked) return false; // Skip if checkbox not checked
          
          // For the general "other" checkbox, always validate
          if (methodSelect === null) {
            return inputEl && inputEl.value.trim() === '';
          }
          
          // For method-specific "other" options, only validate if method is set to "other"
          const methodSelectEl = document.getElementById(methodSelect);
          if (methodSelectEl && methodSelectEl.value === methodValue) {
            return inputEl && inputEl.value.trim() === '';
          }
          
          return false; // Method is not "other", so no validation needed
        });
        
        return !hasInvalidOther;
      }
      
      // Function to check overall validation and update start button
      function updateStartButton() {
        const checkboxes = [
          'check-data-types',
          'check-missing-values', 
          'check-duplicates',
          'check-outliers',
          'check-column-names',
          'check-other'
        ];
        
        const startBtn = document.getElementById('start-agent-btn');
        
        // Check if at least one option is selected
        const hasSelection = checkboxes.some(cbId => 
          document.getElementById(cbId).checked
        );
        
        // Check if all "Other" inputs have content
        const otherInputsValid = validateOtherInputs();
        
        if (startBtn) {
          // Always enable the button, but show helpful message if validation fails
          startBtn.disabled = false;
          
          if (!hasSelection) {
            // No options selected
            startBtn.textContent = ' Start Cleaning Agent';
            startBtn.title = 'Please select at least one cleaning option';
          } else if (!otherInputsValid) {
            // Some "Other" options are checked but empty
            const invalidOptions = getInvalidOtherOptions();
            startBtn.textContent = ' Fill in "Other" options';
            startBtn.title = `Please fill in: ${invalidOptions.join(', ')}`;
          } else {
            // All validation passed
            startBtn.textContent = ' Start Cleaning Agent';
            startBtn.title = 'Ready to start cleaning agent';
          }
        }
      }
      
      // Helper function to get which "Other" options need content
      function getInvalidOtherOptions() {
        const otherInputs = [
          { 
            checkbox: 'check-data-types', 
            input: 'data-type-custom-input', 
            label: 'Data Types',
            methodSelect: 'data-type-method-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-missing-values', 
            input: 'missing-values-custom-input', 
            label: 'Missing Values',
            methodSelect: 'na-handling-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-outliers', 
            input: 'outlier-custom-input', 
            label: 'Outliers',
            methodSelect: 'outlier-method-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-column-names', 
            input: 'column-naming-custom-input', 
            label: 'Column Names',
            methodSelect: 'column-naming-select',
            methodValue: 'other'
          },
          { 
            checkbox: 'check-other', 
            input: 'other-operations-input', 
            label: 'Other Operations',
            methodSelect: null,
            methodValue: null
          }
        ];
        
        const invalidOptions = [];
        otherInputs.forEach(({ checkbox, input, label, methodSelect, methodValue }) => {
          const checkboxEl = document.getElementById(checkbox);
          const inputEl = document.getElementById(input);
          
          if (!checkboxEl.checked) return; // Skip if checkbox not checked
          
          // For the general "other" checkbox, always validate
          if (methodSelect === null) {
            if (inputEl && inputEl.value.trim() === '') {
              invalidOptions.push(label);
            }
            return;
          }
          
          // For method-specific "other" options, only validate if method is set to "other"
          const methodSelectEl = document.getElementById(methodSelect);
          if (methodSelectEl && methodSelectEl.value === methodValue) {
            if (inputEl && inputEl.value.trim() === '') {
              invalidOptions.push(label);
            }
          }
        });
        
        return invalidOptions;
      }
      
      // Add event listeners to enable/disable start button based on checkbox selections
      function addCleaningOptionListeners() {
        const checkboxes = [
          'check-data-types',
          'check-missing-values', 
          'check-duplicates',
          'check-outliers',
          'check-column-names',
          'check-other'
        ];
        
        checkboxes.forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', updateStartButton);
          }
        });
        
        // Add listeners to all "Other" text inputs to validate in real-time
        const otherInputs = [
          'data-type-custom-input',
          'missing-values-custom-input', 
          'outlier-custom-input',
          'column-naming-custom-input',
          'other-operations-input'
        ];
        
        otherInputs.forEach(inputId => {
          const input = document.getElementById(inputId);
          if (input) {
            input.addEventListener('input', updateStartButton);
            input.addEventListener('blur', updateStartButton);
          }
        });
        
        // Add listeners to method select dropdowns to validate when method changes
        const methodSelects = [
          'data-type-method-select',
          'na-handling-select',
          'outlier-method-select',
          'column-naming-select'
        ];
        
        methodSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateStartButton);
          }
        });
      }
      
      // Add event listeners for transformation agent checkboxes and options
      function addTransformationOptionListeners() {
        const checkboxes = [
          'check-distribution-analysis',
          'check-mathematical-transformations',
          'check-new-variables',
          'check-categorical-transformations',
          'check-datetime-transformations',
          'check-merging-combining',
          'check-aggregation-grouping',
          'check-statistical-transformations',
          'check-text-transformations',
          'check-spatial-transformations',
          'check-custom-transformations'
        ];
        
        checkboxes.forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', updateTransformationStartButton);
          }
        });
        
        // Add listeners to all "Other" text inputs to validate in real-time
        const otherInputs = [
          'math-transformations-custom-input',
          'new-variables-custom-input',
          'categorical-transformations-custom-input',
          'datetime-transformations-custom-input',
          'merging-combining-custom-input',
          'aggregation-grouping-custom-input',
          'statistical-transformations-custom-input',
          'text-transformations-custom-input',
          'spatial-transformations-custom-input',
          'custom-transformations-custom-input'
        ];
        
        otherInputs.forEach(inputId => {
          const input = document.getElementById(inputId);
          if (input) {
            input.addEventListener('input', updateTransformationStartButton);
            input.addEventListener('blur', updateTransformationStartButton);
          }
        });
        
        // Add listeners to method select dropdowns to validate when method changes
        const methodSelects = [
          'math-transformations-select',
          'new-variables-select',
          'categorical-transformations-select',
          'datetime-transformations-select',
          'merging-combining-select',
          'aggregation-grouping-select',
          'statistical-transformations-select',
          'text-transformations-select',
          'spatial-transformations-select'
        ];
        
        methodSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateTransformationStartButton);
          }
        });
      }
      
      // Update transformation start button based on selections
      function updateTransformationStartButton() {
        const startBtn = document.getElementById('start-transformation-btn');
        if (!startBtn) return;
        
        // Check if at least one transformation option is selected
        const hasSelection = [
          'check-distribution-analysis',
          'check-mathematical-transformations',
          'check-new-variables',
          'check-categorical-transformations',
          'check-datetime-transformations',
          'check-merging-combining',
          'check-aggregation-grouping',
          'check-statistical-transformations',
          'check-text-transformations',
          'check-spatial-transformations',
          'check-custom-transformations'
        ].some(id => document.getElementById(id)?.checked);
        
        if (!hasSelection) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select at least one transformation';
          startBtn.title = 'Please select at least one transformation operation';
          return;
        }
        
        // Check if all selected "Other" options have content
        const hasInvalidOther = [
          { checkbox: 'check-mathematical-transformations', input: 'math-transformations-custom-input', select: 'math-transformations-select' },
          { checkbox: 'check-new-variables', input: 'new-variables-custom-input', select: 'new-variables-select' },
          { checkbox: 'check-categorical-transformations', input: 'categorical-transformations-custom-input', select: 'categorical-transformations-select' },
          { checkbox: 'check-datetime-transformations', input: 'datetime-transformations-custom-input', select: 'datetime-transformations-select' },
          { checkbox: 'check-merging-combining', input: 'merging-combining-custom-input', select: 'merging-combining-select' },
          { checkbox: 'check-aggregation-grouping', input: 'aggregation-grouping-custom-input', select: 'aggregation-grouping-select' },
          { checkbox: 'check-statistical-transformations', input: 'statistical-transformations-custom-input', select: 'statistical-transformations-select' },
          { checkbox: 'check-text-transformations', input: 'text-transformations-custom-input', select: 'text-transformations-select' },
          { checkbox: 'check-spatial-transformations', input: 'spatial-transformations-custom-input', select: 'spatial-transformations-select' },
          { checkbox: 'check-custom-transformations', input: 'custom-transformations-custom-input', select: null }
        ].some(({ checkbox, input, select }) => {
          const checkboxEl = document.getElementById(checkbox);
          if (!checkboxEl?.checked) return false;
          
          // For custom transformations, always validate
          if (select === null) {
            const inputEl = document.getElementById(input);
            return inputEl && inputEl.value.trim() === '';
          }
          
          // For method-specific "other" options, only validate if method is set to "other"
          const selectEl = document.getElementById(select);
          if (selectEl && selectEl.value === 'other') {
            const inputEl = document.getElementById(input);
            return inputEl && inputEl.value.trim() === '';
          }
          
          return false;
        });
        
        if (hasInvalidOther) {
          startBtn.disabled = true;
          startBtn.textContent = 'Fill in "Other" options';
          startBtn.title = 'Please fill in all selected "Other" options';
          return;
        }
        
        // All validations passed
        startBtn.disabled = false;
        startBtn.textContent = ' Start Transformation Agent';
        startBtn.title = 'Start the transformation agent with selected options';
      }
      
      // Helper function to add execute button to a code block
      function addExecuteButtonToCodeBlock(codeBlock, code) {
        console.log(' Adding execute button to code block');
        console.log(' Code block element:', codeBlock);
        console.log(' Code block classes:', codeBlock.className);
        console.log(' Code block children count:', codeBlock.children.length);
        
        // Add manual mode indicator and execute button
        const manualModeDiv = document.createElement('div');
        manualModeDiv.style.marginTop = '15px';
        manualModeDiv.style.padding = '10px';
        manualModeDiv.style.backgroundColor = 'var(--bg-secondary)';
        manualModeDiv.style.borderRadius = '6px';
        manualModeDiv.style.border = '1px solid var(--border-color)';
        
        const manualModeText = document.createElement('div');
        manualModeText.innerHTML = '<strong>Auto Execute Off</strong>';
        manualModeText.style.marginBottom = '10px';
        manualModeText.style.color = 'var(--text-primary)';
        
        const executeButton = document.createElement('button');
        executeButton.textContent = 'Execute Code';
        executeButton.className = 'execute-cleaning-button';
        executeButton.onclick = () => {
          executeCleaningCodeWithErrorHandling(code);
          // Remove the manual mode section after clicking
          manualModeDiv.remove();
        };
        
        manualModeDiv.appendChild(manualModeText);
        manualModeDiv.appendChild(executeButton);
        codeBlock.appendChild(manualModeDiv);
        
        console.log(' Execute button added to code block');
        console.log(' Manual mode div added:', manualModeDiv);
        console.log(' Execute button added:', executeButton);
        console.log(' Code block children count after:', codeBlock.children.length);
        
        // Force a visual update
        manualModeDiv.style.display = 'block';
        executeButton.style.display = 'inline-block';
      }
      
      // Setup checkbox interactions
      function setupCheckboxInteractions() {
        const missingValuesCheckbox = document.getElementById('check-missing-values');
        const missingHandlingOptions = document.getElementById('missing-handling-options');
        
        // Show/hide missing values handling options
        missingValuesCheckbox.addEventListener('change', function() {
          if (this.checked && !this.disabled) {
            missingHandlingOptions.style.display = 'block';
          } else {
            missingHandlingOptions.style.display = 'none';
          }
        });
        
        // Trigger initial state
        if (missingValuesCheckbox.checked && !missingValuesCheckbox.disabled) {
          missingHandlingOptions.style.display = 'block';
        }
        
        // Setup other operations checkbox
        const otherCheckbox = document.getElementById('check-other');
        const otherOptions = document.getElementById('other-options');
        
        if (otherCheckbox && otherOptions) {
          // Show/hide other operations input
          otherCheckbox.addEventListener('change', function() {
            if (this.checked) {
              otherOptions.style.display = 'block';
            } else {
              otherOptions.style.display = 'none';
            }
          });
        }
        
        // Setup data type options
        const dataTypeCheckbox = document.getElementById('check-data-types');
        const dataTypeOptions = document.getElementById('data-type-options');
        const dataTypeMethodSelect = document.getElementById('data-type-method-select');
        const dataTypeOtherInput = document.getElementById('data-type-other-input');
        
        if (dataTypeCheckbox && dataTypeOptions) {
          dataTypeCheckbox.addEventListener('change', function() {
            if (this.checked) {
              dataTypeOptions.style.display = 'block';
            } else {
              dataTypeOptions.style.display = 'none';
            }
          });
          
          // Trigger initial state
          if (dataTypeCheckbox.checked) {
            dataTypeOptions.style.display = 'block';
          }
          
          // Show/hide custom input when "Other" is selected
          if (dataTypeMethodSelect) {
            dataTypeMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                dataTypeOtherInput.style.display = 'block';
              } else {
                dataTypeOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Setup missing values options
        const missingValuesMethodSelect = document.getElementById('na-handling-select');
        const missingValuesOtherInput = document.getElementById('missing-values-other-input');
        
        if (missingValuesMethodSelect) {
          missingValuesMethodSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              missingValuesOtherInput.style.display = 'block';
            } else {
              missingValuesOtherInput.style.display = 'none';
            }
          });
        }
        
        // Setup duplicates options
        const duplicatesCheckbox = document.getElementById('check-duplicates');
        const duplicatesOptions = document.getElementById('duplicates-options');
        
        if (duplicatesCheckbox && duplicatesOptions) {
          duplicatesCheckbox.addEventListener('change', function() {
            if (this.checked) {
              duplicatesOptions.style.display = 'block';
            } else {
              duplicatesOptions.style.display = 'none';
            }
          });
          
          // Trigger initial state
          if (duplicatesCheckbox.checked) {
            duplicatesOptions.style.display = 'block';
          }
        }
        
        // Setup outlier options
        const outlierCheckbox = document.getElementById('check-outliers');
        const outlierOptions = document.getElementById('outlier-method-options');
        const outlierMethodSelect = document.getElementById('outlier-method-select');
        const outlierOtherInput = document.getElementById('outlier-other-input');
        
        if (outlierCheckbox && outlierOptions) {
          outlierCheckbox.addEventListener('change', function() {
            if (this.checked) {
              outlierOptions.style.display = 'block';
            } else {
              outlierOptions.style.display = 'none';
            }
          });
          
          // Trigger initial state
          if (outlierCheckbox.checked) {
            outlierOptions.style.display = 'block';
          }
          
          // Show/hide custom input when "Other" is selected
          if (outlierMethodSelect) {
            outlierMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                outlierOtherInput.style.display = 'block';
              } else {
                outlierOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Setup column names options
        const columnNamesCheckbox = document.getElementById('check-column-names');
        const columnNamesOptions = document.getElementById('column-naming-options');
        const columnNamesMethodSelect = document.getElementById('column-naming-select');
        const columnNamesOtherInput = document.getElementById('column-naming-other-input');
        
        if (columnNamesCheckbox && columnNamesOptions) {
          columnNamesCheckbox.addEventListener('change', function() {
            if (this.checked) {
              columnNamesOptions.style.display = 'block';
            } else {
              columnNamesOptions.style.display = 'none';
            }
          });
          
          // Trigger initial state
          if (columnNamesCheckbox.checked) {
            columnNamesOptions.style.display = 'block';
          }
          
          // Show/hide custom input when "Other" is selected
          if (columnNamesMethodSelect) {
            columnNamesMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                columnNamesOtherInput.style.display = 'block';
              } else {
                columnNamesOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Setup mode selector (Auto Execute / Ask)
        const autoExecuteToggle = document.getElementById('auto-execute-toggle');
        if (autoExecuteToggle) {
          // Initialize mode based on checkbox state
          if (autoExecuteToggle.checked) {
            setMode('auto');
          } else {
            setMode('ask');
          }
          
          // Keep checkbox in sync if it's changed programmatically
          autoExecuteToggle.addEventListener('change', function() {
            const isEnabled = this.checked;
            setMode(isEnabled ? 'auto' : 'ask');
          });
        }
        
      }
      
      // Setup transformation agent checkbox interactions
      function setupTransformationCheckboxInteractions() {
        console.log(' Setting up transformation agent checkbox interactions...');
        
        // FIXED: Initialize start button state
        const startBtn = document.getElementById('start-transformation-btn');
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select a DataFrame first';
          startBtn.title = 'Please select a DataFrame to continue';
        }
        // Mathematical transformations
        const mathTransformCheckbox = document.getElementById('check-mathematical-transformations');
        const mathTransformOptions = document.getElementById('math-transformations-options');
        const mathTransformMethodSelect = document.getElementById('math-transformations-select');
        const mathTransformOtherInput = document.getElementById('math-transformations-other-input');
        
        if (mathTransformCheckbox && mathTransformOptions) {
          mathTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              mathTransformOptions.style.display = 'block';
            } else {
              mathTransformOptions.style.display = 'none';
            }
          });
          
          if (mathTransformMethodSelect) {
            mathTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                mathTransformOtherInput.style.display = 'block';
              } else {
                mathTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // New variables
        const newVarCheckbox = document.getElementById('check-new-variables');
        const newVarOptions = document.getElementById('new-variables-options');
        const newVarMethodSelect = document.getElementById('new-variables-select');
        const newVarOtherInput = document.getElementById('new-variables-custom-input');
        
        if (newVarCheckbox && newVarOptions) {
          newVarCheckbox.addEventListener('change', function() {
            if (this.checked) {
              newVarOptions.style.display = 'block';
            } else {
              newVarOptions.style.display = 'none';
            }
          });
          
          if (newVarMethodSelect) {
            newVarMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                newVarOtherInput.style.display = 'block';
              } else {
                newVarOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Categorical transformations
        const catTransformCheckbox = document.getElementById('check-categorical-transformations');
        const catTransformOptions = document.getElementById('categorical-transformations-options');
        const catTransformMethodSelect = document.getElementById('categorical-transformations-select');
        const catTransformOtherInput = document.getElementById('categorical-transformations-custom-input');
        
        if (catTransformCheckbox && catTransformOptions) {
          catTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              catTransformOptions.style.display = 'block';
            } else {
              catTransformOptions.style.display = 'none';
            }
          });
          
          if (catTransformMethodSelect) {
            catTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                catTransformOtherInput.style.display = 'block';
              } else {
                catTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Date/time transformations
        const dateTransformCheckbox = document.getElementById('check-datetime-transformations');
        const dateTransformOptions = document.getElementById('datetime-transformations-options');
        const dateTransformMethodSelect = document.getElementById('datetime-transformations-select');
        const dateTransformOtherInput = document.getElementById('datetime-transformations-custom-input');
        
        if (dateTransformCheckbox && dateTransformOptions) {
          dateTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              dateTransformOptions.style.display = 'block';
            } else {
              dateTransformOptions.style.display = 'none';
            }
          });
          
          if (dateTransformMethodSelect) {
            dateTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                dateTransformOtherInput.style.display = 'block';
              } else {
                dateTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Merging & combining
        const mergeCheckbox = document.getElementById('check-merging-combining');
        const mergeOptions = document.getElementById('merging-combining-options');
        const mergeMethodSelect = document.getElementById('merging-combining-select');
        const mergeOtherInput = document.getElementById('merging-combining-custom-input');
        
        if (mergeCheckbox && mergeOptions) {
          mergeCheckbox.addEventListener('change', function() {
            if (this.checked) {
              mergeOptions.style.display = 'block';
            } else {
              mergeOptions.style.display = 'none';
            }
          });
          
          if (mergeMethodSelect) {
            mergeMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                mergeOtherInput.style.display = 'block';
              } else {
                mergeOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Aggregation & grouping
        const aggCheckbox = document.getElementById('check-aggregation-grouping');
        const aggOptions = document.getElementById('aggregation-grouping-options');
        const aggMethodSelect = document.getElementById('aggregation-grouping-select');
        const aggOtherInput = document.getElementById('aggregation-grouping-custom-input');
        
        if (aggCheckbox && aggOptions) {
          aggCheckbox.addEventListener('change', function() {
            if (this.checked) {
              aggOptions.style.display = 'block';
            } else {
              aggOptions.style.display = 'none';
            }
          });
          
          if (aggMethodSelect) {
            aggMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                aggOtherInput.style.display = 'block';
            } else {
                aggOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Statistical transformations
        const statTransformCheckbox = document.getElementById('check-statistical-transformations');
        const statTransformOptions = document.getElementById('statistical-transformations-options');
        const statTransformMethodSelect = document.getElementById('statistical-transformations-select');
        const statTransformOtherInput = document.getElementById('statistical-transformations-custom-input');
        
        if (statTransformCheckbox && statTransformOptions) {
          statTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              statTransformOptions.style.display = 'block';
            } else {
              statTransformOptions.style.display = 'none';
            }
          });
          
          if (statTransformMethodSelect) {
            statTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                statTransformOtherInput.style.display = 'block';
              } else {
                statTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Text transformations
        const textTransformCheckbox = document.getElementById('check-text-transformations');
        const textTransformOptions = document.getElementById('text-transformations-options');
        const textTransformMethodSelect = document.getElementById('text-transformations-select');
        const textTransformOtherInput = document.getElementById('text-transformations-custom-input');
        
        if (textTransformCheckbox && textTransformOptions) {
          textTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              textTransformOptions.style.display = 'block';
            } else {
              textTransformOptions.style.display = 'none';
            }
          });
          
          if (textTransformMethodSelect) {
            textTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                textTransformOtherInput.style.display = 'block';
              } else {
                textTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Spatial transformations
        const spatialTransformCheckbox = document.getElementById('check-spatial-transformations');
        const spatialTransformOptions = document.getElementById('spatial-transformations-options');
        const spatialTransformMethodSelect = document.getElementById('spatial-transformations-select');
        const spatialTransformOtherInput = document.getElementById('spatial-transformations-custom-input');
        
        if (spatialTransformCheckbox && spatialTransformOptions) {
          spatialTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              spatialTransformOptions.style.display = 'block';
            } else {
              spatialTransformOptions.style.display = 'none';
            }
          });
          
          if (spatialTransformMethodSelect) {
            spatialTransformMethodSelect.addEventListener('change', function() {
              if (this.value === 'other') {
                spatialTransformOtherInput.style.display = 'block';
              } else {
                spatialTransformOtherInput.style.display = 'none';
              }
            });
          }
        }
        
        // Custom transformations
        const customTransformCheckbox = document.getElementById('check-custom-transformations');
        const customTransformOptions = document.getElementById('custom-transformations-options');
        
        if (customTransformCheckbox && customTransformOptions) {
          customTransformCheckbox.addEventListener('change', function() {
            if (this.checked) {
              customTransformOptions.style.display = 'block';
            } else {
              customTransformOptions.style.display = 'none';
            }
          });
        }
      }
      
      // Setup statistical agent checkbox interactions
      function setupStatisticalCheckboxInteractions() {
        console.log(' Setting up statistical agent checkbox interactions...');
        
        // FIXED: Initialize start button state
        const startBtn = document.getElementById('start-statistical-btn');
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select a DataFrame first';
          startBtn.title = 'Please select a DataFrame to continue';
        }
        
        // Group comparisons
        const groupCompCheckbox = document.getElementById('check-group-comparisons');
        const groupCompOptions = document.getElementById('group-comparisons-options');
        
        if (groupCompCheckbox && groupCompOptions) {
          groupCompCheckbox.addEventListener('change', function() {
            if (this.checked) {
              groupCompOptions.style.display = 'block';
            } else {
              groupCompOptions.style.display = 'none';
            }
          });
        }
        
        // Before/after analysis
        const beforeAfterCheckbox = document.getElementById('check-before-after-analysis');
        const beforeAfterOptions = document.getElementById('before-after-options');
        
        if (beforeAfterCheckbox && beforeAfterOptions) {
          beforeAfterCheckbox.addEventListener('change', function() {
            if (this.checked) {
              beforeAfterOptions.style.display = 'block';
            } else {
              beforeAfterOptions.style.display = 'none';
            }
          });
        }
        
        // Power analysis
        const powerCheckbox = document.getElementById('check-power-analysis');
        const powerOptions = document.getElementById('power-analysis-options');
        
        if (powerCheckbox && powerOptions) {
          powerCheckbox.addEventListener('change', function() {
            if (this.checked) {
              powerOptions.style.display = 'block';
            } else {
              powerOptions.style.display = 'none';
            }
          });
        }
        
        // Multiple testing correction
        const multipleTestingCheckbox = document.getElementById('check-multiple-testing-correction');
        const multipleTestingOptions = document.getElementById('multiple-testing-options');
        
        if (multipleTestingCheckbox && multipleTestingOptions) {
          multipleTestingCheckbox.addEventListener('change', function() {
            if (this.checked) {
              multipleTestingOptions.style.display = 'block';
            } else {
              multipleTestingOptions.style.display = 'none';
            }
          });
        }
        
        // Effect size analysis
        const effectSizeCheckbox = document.getElementById('check-effect-size-analysis');
        const effectSizeOptions = document.getElementById('effect-size-options');
        
        if (effectSizeCheckbox && effectSizeOptions) {
          effectSizeCheckbox.addEventListener('change', function() {
            if (this.checked) {
              effectSizeOptions.style.display = 'block';
            } else {
              effectSizeOptions.style.display = 'none';
            }
          });
        }
        
        // Custom statistical analysis
        const customStatCheckbox = document.getElementById('check-custom-statistical-analysis');
        const customStatOptions = document.getElementById('custom-statistical-analysis-options');
        
        if (customStatCheckbox && customStatOptions) {
          customStatCheckbox.addEventListener('change', function() {
            if (this.checked) {
              customStatOptions.style.display = 'block';
            } else {
              customStatOptions.style.display = 'none';
            }
          });
        }
        
        // Nonparametric tests
        const nonparametricCheckbox = document.getElementById('check-nonparametric-tests');
        const nonparametricOptions = document.getElementById('nonparametric-tests-options');
        
        if (nonparametricCheckbox && nonparametricOptions) {
          nonparametricCheckbox.addEventListener('change', function() {
            if (this.checked) {
              nonparametricOptions.style.display = 'block';
            } else {
              nonparametricOptions.style.display = 'none';
            }
          });
        }
        
        // Categorical tests
        const categoricalCheckbox = document.getElementById('check-categorical-tests');
        const categoricalOptions = document.getElementById('categorical-tests-options');
        
        if (categoricalCheckbox && categoricalOptions) {
          categoricalCheckbox.addEventListener('change', function() {
            if (this.checked) {
              categoricalOptions.style.display = 'block';
            } else {
              categoricalOptions.style.display = 'none';
            }
          });
        }
      }
      
      // Setup modeling agent checkbox interactions
      function setupModelingCheckboxInteractions() {
        console.log(' Setting up modeling agent checkbox interactions...');
        
        // Initialize start button state
        const startBtn = document.getElementById('start-modeling-btn');
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select a DataFrame first';
          startBtn.title = 'Please select a DataFrame to continue';
        }
        
        // Dimensionality reduction
        const drCheckbox = document.getElementById('check-dimensionality-reduction');
        const drOptions = document.getElementById('dimensionality-reduction-options');
        
        if (drCheckbox && drOptions) {
          drCheckbox.addEventListener('change', function() {
            if (this.checked) {
              drOptions.style.display = 'block';
            } else {
              drOptions.style.display = 'none';
            }
          });
        }
        
        // Custom modeling
        const customModelingCheckbox = document.getElementById('check-custom-modeling');
        const customModelingOptions = document.getElementById('custom-modeling-options');
        
        if (customModelingCheckbox && customModelingOptions) {
          customModelingCheckbox.addEventListener('change', function() {
            if (this.checked) {
              customModelingOptions.style.display = 'block';
            } else {
              customModelingOptions.style.display = 'none';
            }
          });
        }
        
        // Problem type change handler
        const problemTypeSelect = document.getElementById('modeling-problem-type');
        if (problemTypeSelect) {
          problemTypeSelect.addEventListener('change', function() {
            updateModelingStartButton();
          });
        }
        
        // Target variable change handler
        const targetVariableSelect = document.getElementById('modeling-target-variable');
        if (targetVariableSelect) {
          targetVariableSelect.addEventListener('change', function() {
            updateModelingStartButton();
          });
        }
      }
      
      // Show/hide variable selection for modeling algorithms
      function showHideModelingVariableSelection(checkboxId) {
        const checkbox = document.getElementById(checkboxId);
        if (!checkbox) return;
        
        // Map checkbox IDs to their corresponding options container IDs
        const optionMappings = {
          'check-dimensionality-reduction': 'dimensionality-reduction-options',
          'check-linear-regression': 'linear-regression-options',
          'check-logistic-regression': 'logistic-regression-options',
          'check-multinomial-regression': 'multinomial-regression-options',
          'check-random-forest': 'random-forest-options',
          'check-xgboost': 'xgboost-options',
          'check-feature-engineering': 'feature-engineering-options',
          'check-custom-modeling': 'custom-modeling-options'
        };
        
        const optionsId = optionMappings[checkboxId];
        if (optionsId) {
          const optionsContainer = document.getElementById(optionsId);
          if (optionsContainer) {
            if (checkbox.checked) {
              optionsContainer.style.display = 'block';
            } else {
              optionsContainer.style.display = 'none';
            }
          }
        }
      }
      
      // Add event listeners for modeling agent checkboxes and options
      function addModelingOptionListeners() {
        const checkboxes = [
          'check-dimensionality-reduction',
          'check-linear-regression',
          'check-logistic-regression',
          'check-multinomial-regression',
          'check-random-forest',
          'check-xgboost',
          'check-feature-engineering',
          'check-model-interpretability',
          'check-claude-plots',
          'check-custom-modeling'
        ];
        
        checkboxes.forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', function() {
              updateModelingStartButton();
              // Show/hide variable selection for modeling algorithms
              showHideModelingVariableSelection(id);
            });
          }
        });
        
        // Add listeners to method select dropdowns
        const methodSelects = [
          'dimensionality-reduction-select'
        ];
        
        methodSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateModelingStartButton);
          }
        });
      }
      
      // Add event listeners for statistical agent checkboxes and options
      function addStatisticalOptionListeners() {
        const checkboxes = [
          'check-basic-statistics',
          'check-group-comparisons',
          'check-categorical-tests',
          'check-before-after-analysis',
          'check-effect-size-analysis',
          'check-power-analysis',
          'check-multiple-testing-correction',
          'check-custom-statistical-analysis'
        ];
        
        checkboxes.forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', updateStatisticalStartButton);
          }
        });
        
        // Add listeners to method select dropdowns
        const methodSelects = [
          'group-comparisons-select',
          'nonparametric-tests-select',
          'categorical-tests-select',
          'before-after-select',
          'effect-size-select',
          'power-analysis-select',
          'multiple-testing-select'
        ];
        
        methodSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateStatisticalStartButton);
          }
        });
        
        // Add listener for effect size "Other" option
        const effectSizeSelect = document.getElementById('effect-size-select');
        const effectSizeCustomInput = document.getElementById('effect-size-custom-input');
        if (effectSizeSelect && effectSizeCustomInput) {
          effectSizeSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              effectSizeCustomInput.style.display = 'block';
            } else {
              effectSizeCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for power analysis "Other" option
        const powerAnalysisSelect = document.getElementById('power-analysis-select');
        const powerAnalysisCustomInput = document.getElementById('power-analysis-custom-input');
        if (powerAnalysisSelect && powerAnalysisCustomInput) {
          powerAnalysisSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              powerAnalysisCustomInput.style.display = 'block';
            } else {
              powerAnalysisCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for multiple testing "Other" option
        const multipleTestingSelect = document.getElementById('multiple-testing-select');
        const multipleTestingCustomInput = document.getElementById('multiple-testing-custom-input');
        if (multipleTestingSelect && multipleTestingCustomInput) {
          multipleTestingSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              multipleTestingCustomInput.style.display = 'block';
            } else {
              multipleTestingCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for group comparisons "Other" option
        const groupComparisonsSelect = document.getElementById('group-comparisons-select');
        const groupComparisonsCustomInput = document.getElementById('group-comparisons-custom-input');
        if (groupComparisonsSelect && groupComparisonsCustomInput) {
          groupComparisonsSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              groupComparisonsCustomInput.style.display = 'block';
            } else {
              groupComparisonsCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for nonparametric tests "Other" option
        const nonparametricTestsSelect = document.getElementById('nonparametric-tests-select');
        const nonparametricTestsCustomInput = document.getElementById('nonparametric-tests-custom-input');
        if (nonparametricTestsSelect && nonparametricTestsCustomInput) {
          nonparametricTestsSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              nonparametricTestsCustomInput.style.display = 'block';
            } else {
              nonparametricTestsCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for categorical tests "Other" option
        const categoricalTestsSelect = document.getElementById('categorical-tests-select');
        const categoricalTestsCustomInput = document.getElementById('categorical-tests-custom-input');
        if (categoricalTestsSelect && categoricalTestsCustomInput) {
          categoricalTestsSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              categoricalTestsCustomInput.style.display = 'block';
            } else {
              categoricalTestsCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listener for before/after analysis "Other" option
        const beforeAfterSelect = document.getElementById('before-after-select');
        const beforeAfterCustomInput = document.getElementById('before-after-custom-input');
        if (beforeAfterSelect && beforeAfterCustomInput) {
          beforeAfterSelect.addEventListener('change', function() {
            if (this.value === 'other') {
              beforeAfterCustomInput.style.display = 'block';
            } else {
              beforeAfterCustomInput.style.display = 'none';
            }
          });
        }
        
        // Add listeners to variable selection dropdowns
        const variableSelects = [
          'statistical-continuous-var',
          'statistical-grouping-var',
          'statistical-before-var',
          'statistical-after-var',
          'categorical-var1',
          'categorical-var2'
        ];
        
        variableSelects.forEach(selectId => {
          const select = document.getElementById(selectId);
          if (select) {
            select.addEventListener('change', updateStatisticalStartButton);
          }
        });
      }
      
      // Update statistical start button based on selections
      function updateStatisticalStartButton() {
        const startBtn = document.getElementById('start-statistical-btn');
        if (!startBtn) return;
        
        // Check if at least one analysis option is selected
        const hasSelection = [
          'check-basic-statistics',
          'check-group-comparisons',
          'check-categorical-tests',
          'check-before-after-analysis',
          'check-effect-size-analysis',
          'check-power-analysis',
          'check-multiple-testing-correction',
          'check-custom-statistical-analysis'
        ].some(id => document.getElementById(id)?.checked);
        
        if (!hasSelection) {
          startBtn.disabled = true;
          startBtn.textContent = 'Select at least one analysis type';
          startBtn.title = 'Please select at least one statistical analysis';
          return;
        }
        
        // Check if required variables are selected for group comparisons
        if (document.getElementById('check-group-comparisons')?.checked) {
          const continuousVar = document.getElementById('statistical-continuous-var')?.value;
          const groupingVar = document.getElementById('statistical-grouping-var')?.value;
          
          if (!continuousVar || !groupingVar) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select variables for group comparisons';
            startBtn.title = 'Please select both continuous and grouping variables';
            return;
          }
        }
        
        // Check if required variables are selected for before/after analysis
        if (document.getElementById('check-before-after-analysis')?.checked) {
          const beforeVar = document.getElementById('statistical-before-var')?.value;
          const afterVar = document.getElementById('statistical-after-var')?.value;
          
          if (!beforeVar || !afterVar) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select variables for before/after analysis';
            startBtn.title = 'Please select both before and after variables';
            return;
          }
        }
        
        // Check if required variables are selected for categorical tests
        if (document.getElementById('check-categorical-tests')?.checked) {
          const catVar1 = document.getElementById('categorical-var1')?.value;
          const catVar2 = document.getElementById('categorical-var2')?.value;
          
          if (!catVar1 || !catVar2) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select variables for categorical tests';
            startBtn.title = 'Please select both categorical variables';
            return;
          }
        }
        
        // All validations passed
        startBtn.disabled = false;
        startBtn.textContent = ' Start Statistical Analysis Agent';
        startBtn.title = 'Start the statistical analysis agent with selected options';
      }
      
      // Handle agent started response
      function handleAgentStarted(result) {
        // Track current agent type for success messages
        window.currentActiveAgentType = 'Cleaning';
        
        if (result.success) {
          const totalSteps = result.total_steps || result.workflow_steps?.length || 'Unknown';
          const stepNum = result.current_step?.step || 1;
          const stepDesc = result.current_step?.description || 'Starting...';
          
          // Show selected cleaning operations
          const selectedOps = [];
          if (result.cleaning_options) {
            if (result.cleaning_options.dataTypes) selectedOps.push(' Data Types');
            if (result.cleaning_options.missingValues) selectedOps.push(' Missing Values');
            if (result.cleaning_options.duplicates) selectedOps.push(' Duplicates');
            if (result.cleaning_options.outliers) selectedOps.push(' Outliers');
            if (result.cleaning_options.other) selectedOps.push(' Custom Operations');
            if (result.cleaning_options.columnNames) selectedOps.push(' Column Names');
          }
          
          // Add custom operations text if available
          if (result.other_operations && result.other_operations.trim()) {
            selectedOps.push(` Custom: ${result.other_operations}`);
          }
          
          const opsText = selectedOps.length > 0 ? `\n **Operations:**\n   ${selectedOps.join('\n   ')}` : '';
          
          addMessage(`**Cleaning Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** ${stepDesc}`, 'ai');
          
          console.log('Agent started with workflow:', result);
          
          // Initialize the workflow tracking
          currentAgentWorkflow = {
            dataframe: result.dataframe,
            naHandling: result.na_handling,
            cleaningOptions: result.cleaning_options,
            methodOptions: result.method_options,
            customInputs: result.custom_inputs,
            workflowSteps: result.workflow_steps,
            currentStep: 1,
            totalSteps: result.total_steps
          };
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          // Execute the first step
          if (result.current_step && result.current_step.code) {
            console.log('Executing first step code:', result.current_step.code);
            
            // Store the code for later display
            currentStepCode = result.current_step.code;
            
            // Agent workflow steps are ALWAYS auto-executed (predefined code)
            // The auto-execute toggle only applies to final Claude-generated code
            if (ws && ws.readyState === WebSocket.OPEN) {
              console.log(' Executing first agent workflow step');
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: result.current_step.code
              }));
            }
          } else {
            console.log('No code to execute for first step');
          }
        } else {
          addMessage(`**Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Handle transformation agent started response
      function handleTransformationAgentStarted(result) {
        console.log(' handleTransformationAgentStarted called with:', result);
        
        // Track current agent type for success messages
        window.currentActiveAgentType = 'Transformation';
        
        if (result.success) {
          const totalSteps = result.total_steps || result.workflow_steps?.length || 'Unknown';
          const stepNum = result.current_step?.step || 1;
          const stepDesc = result.current_step?.description || 'Starting...';
          
          // Show selected transformation operations
          const selectedOps = [];
          if (result.transformation_options) {
            if (result.transformation_options.distributionAnalysis) selectedOps.push('Distribution Analysis');
            if (result.transformation_options.mathematicalTransformations) selectedOps.push('Mathematical Transformations');
            if (result.transformation_options.newVariables) selectedOps.push('New Variables');
            if (result.transformation_options.categoricalTransformations) selectedOps.push('Categorical Transformations');
            if (result.transformation_options.dateTimeTransformations) selectedOps.push('Date/Time Transformations');
            if (result.transformation_options.mergingCombining) selectedOps.push('Merging & Combining');
            if (result.transformation_options.aggregationGrouping) selectedOps.push('Aggregation & Grouping');
            if (result.transformation_options.statisticalTransformations) selectedOps.push('Statistical Transformations');
            if (result.transformation_options.textTransformations) selectedOps.push('Text Transformations');
            if (result.transformation_options.spatialTransformations) selectedOps.push('Spatial Transformations');
            if (result.transformation_options.customTransformations) selectedOps.push('Custom Transformations');
          }
          
          const opsText = selectedOps.length > 0 ? `\n**Operations:**\n   ${selectedOps.join('\n   ')}` : '';
          
          addMessage(`**Transformation Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** ${stepDesc}${opsText}`, 'ai');
          
          console.log('Transformation agent started with workflow:', result);
          
          // Initialize the workflow tracking
          currentAgentWorkflow = {
            dataframe: result.dataframe,
            transformationOptions: result.transformation_options,
            methodOptions: result.method_options,
            customInputs: result.custom_inputs,
            workflowSteps: result.workflow_steps,
            currentStep: 1,
            totalSteps: result.total_steps
          };
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Transform send button to stop button when agent starts (consistent with other agents)
          transformToAgentStopButton();
          
          // Execute the first step
          if (result.current_step && result.current_step.code) {
            console.log('Executing first transformation step code:', result.current_step.code);
            
            // Store the code for later display
            currentStepCode = result.current_step.code;
            
            // Agent workflow steps are ALWAYS auto-executed (predefined code)
            // The auto-execute toggle only applies to final Claude-generated code
            if (ws && ws.readyState === WebSocket.OPEN) {
              console.log(' Executing first transformation workflow step');
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: result.current_step.code
              }));
            }
          } else {
            console.log('No code to execute for first transformation step');
          }
        } else {
          addMessage(`**Transformation Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Handle statistical agent started response
      function handleStatisticalAgentStarted(result) {
        console.log(' handleStatisticalAgentStarted called with:', result);
        
        // Track current agent type for success messages
        window.currentActiveAgentType = 'Statistical';
        
        if (result.success) {
          const totalSteps = result.total_steps || result.workflow_steps?.length || 'Unknown';
          const stepNum = result.current_step?.step || 1;
          const stepDesc = result.current_step?.description || 'Starting...';
          
          // Show selected statistical analysis operations
          const selectedOps = [];
          if (result.analysis_options) {
            if (result.analysis_options.basicStatistics) selectedOps.push(' Basic Statistics & Distributions');
            if (result.analysis_options.groupComparisons) selectedOps.push(' Group Comparisons');
            if (result.analysis_options.beforeAfterAnalysis) selectedOps.push(' Before/After Analysis');
            if (result.analysis_options.effectSizeAnalysis) selectedOps.push(' Effect Size Analysis');
            if (result.analysis_options.powerAnalysis) selectedOps.push(' Power Analysis');
            if (result.analysis_options.multipleTestingCorrection) selectedOps.push(' Multiple Testing Correction');
          }
          
          const opsText = selectedOps.length > 0 ? `\n **Operations:**\n   ${selectedOps.join('\n   ')}` : '';
          
          addMessage(`**Statistical Analysis Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** ${stepDesc}${opsText}`, 'ai');
          
          console.log('Statistical analysis agent started with workflow:', result);
          
          // Initialize the workflow tracking
          currentAgentWorkflow = {
            dataframe: result.dataframe,
            analysisOptions: result.analysis_options,
            methodOptions: result.method_options,
            variables: result.variables,
            customInputs: result.custom_inputs,
            workflowSteps: result.workflow_steps,
            currentStep: 1,
            totalSteps: result.total_steps
          };
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Execute the first step
          if (result.current_step && result.current_step.code) {
            console.log('Executing first statistical analysis step code:', result.current_step.code);
            
            // Store the code for later display
            currentStepCode = result.current_step.code;
            
            // Agent workflow steps are ALWAYS auto-executed (predefined code)
            // The auto-execute toggle only applies to final Claude-generated code
            if (ws && ws.readyState === WebSocket.OPEN) {
              console.log(' Executing first statistical workflow step');
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: result.current_step.code
              }));
            }
          } else {
            console.log('No code to execute for first statistical analysis step');
            // For statistical analysis steps without code, process the results and move to next step
            if (result.current_step && result.current_step.results) {
              console.log('Processing statistical step results:', result.current_step.results);
              
              // Display the results
              displayStatisticalStepResults(result.current_step);
              
              // Move to next step
              requestNextStatisticalStep();
            }
          }
        } else {
          addMessage(`**Statistical Analysis Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Display statistical step results
      function displayStatisticalStepResults(stepResult) {
        console.log('Displaying statistical step results:', stepResult);
        
        if (stepResult.operation === 'data_overview') {
          let message = `** Data Overview Results**\n\n`;
          
          if (stepResult.results && stepResult.results.structure) {
            const structure = stepResult.results.structure;
            message += `** Data Structure:**\n`;
            message += `- Observations: ${structure.observation_count}\n`;
            message += `- Variables: ${structure.variable_count}\n`;
            message += `- Size: ${(structure.memory_usage / 1024).toFixed(1)} KB\n\n`;
          }
          
          if (stepResult.results && stepResult.results.data_types) {
            message += `** Variable Types:**\n`;
            Object.entries(stepResult.results.data_types).forEach(([variable, type]) => {
              message += `- ${variable}: ${type}\n`;
            });
            message += `\n`;
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'distribution_analysis') {
          let message = `** Distribution Analysis Results**\n\n`;
          
          if (stepResult.results) {
            Object.entries(stepResult.results).forEach(([variable, analysis]) => {
              if (variable !== 'success' && variable !== 'step' && variable !== 'operation' && variable !== 'message') {
                message += `**${variable}:**\n`;
                
                if (analysis.normality_test) {
                  const test = analysis.normality_test;
                  message += `- Normality: ${test.method} (p=${test.p_value.toFixed(4)}) - ${test.is_normal ? 'Normal' : 'Non-normal'}\n`;
                }
                
                if (analysis.distribution_characteristics) {
                  const dist = analysis.distribution_characteristics;
                  message += `- Mean: ${dist.mean.toFixed(2)}, Median: ${dist.median.toFixed(2)}\n`;
                  message += `- Std Dev: ${dist.sd.toFixed(2)}, Skewness: ${dist.skewness.toFixed(2)}\n`;
                }
                
                if (analysis.outlier_analysis) {
                  const outliers = analysis.outlier_analysis;
                  message += `- Outliers: ${outliers.outlier_count} (${outliers.outlier_percentage}%)\n`;
                }
                
                message += `\n`;
              }
            });
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'group_comparisons') {
          let message = `** Group Comparisons Results**\n\n`;
          
          if (stepResult.results) {
            if (stepResult.results.test_type) {
              message += `**Test:** ${stepResult.results.test_type}\n`;
            }
            if (stepResult.results.test_result) {
              const result = stepResult.results.test_result;
              if (result.f_statistic) {
                message += `**F-statistic:** ${result.f_statistic.toFixed(3)}\n`;
                message += `**p-value:** ${result.p_value.toFixed(4)}\n`;
                message += `**Significance:** ${result.significance ? 'Significant' : 'Not significant'}\n`;
              }
              if (result.t_statistic) {
                message += `**t-statistic:** ${result.t_statistic.toFixed(3)}\n`;
                message += `**p-value:** ${result.p_value.toFixed(4)}\n`;
                message += `**Significance:** ${result.p_value < 0.05 ? 'Significant' : 'Not significant'}\n`;
              }
            }
            if (stepResult.results.effect_size) {
              const effect = stepResult.results.effect_size;
              if (effect.eta_squared) {
                message += `**Effect Size ():** ${effect.eta_squared.toFixed(3)} (${effect.interpretation})\n`;
              }
              if (effect.cohens_d) {
                message += `**Effect Size (Cohen's d):** ${effect.cohens_d.toFixed(3)} (${effect.interpretation})\n`;
              }
            }
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'before_after_analysis') {
          let message = `** Before/After Analysis Results**\n\n`;
          
          if (stepResult.results?.descriptive) {
            const desc = stepResult.results.descriptive;
            message += `**Descriptive Statistics:**\n`;
            message += `- Paired observations: ${desc.n_pairs}\n`;
            message += `- Before mean: ${desc.before_mean.toFixed(3)}\n`;
            message += `- After mean: ${desc.after_mean.toFixed(3)}\n`;
            message += `- Mean difference: ${desc.mean_difference.toFixed(3)}\n\n`;
          }
          
          if (stepResult.results?.paired_test) {
            const test = stepResult.results.paired_test;
            message += `**Paired t-test:**\n`;
            message += `- t-statistic: ${test.t_statistic.toFixed(3)}\n`;
            message += `- p-value: ${test.p_value.toFixed(4)}\n`;
            message += `- Result: ${test.significance ? 'Significant difference' : 'No significant difference'}\n\n`;
          }
          
          if (stepResult.results?.effect_size) {
            const effect = stepResult.results.effect_size;
            message += `**Effect Size:**\n`;
            message += `- Cohen's d: ${effect.cohens_d.toFixed(3)} (${effect.interpretation})\n`;
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'power_analysis') {
          let message = `** Power Analysis Results**\n\n`;
          
          if (stepResult.results?.current_sample_size) {
            message += `**Current Sample Size:** ${stepResult.results.current_sample_size}\n\n`;
          }
          
          if (stepResult.results?.basic_guidelines) {
            const guidelines = stepResult.results.basic_guidelines;
            message += `**Sample Size Guidelines (80% power, =0.05):**\n`;
            message += `**Two-group t-test:**\n`;
            message += `- Small effect: ${guidelines.two_group_ttest.small_effect}\n`;
            message += `- Medium effect: ${guidelines.two_group_ttest.medium_effect}\n`;
            message += `- Large effect: ${guidelines.two_group_ttest.large_effect}\n\n`;
            if (stepResult.results.note) {
              message += `*${stepResult.results.note}*\n`;
            }
          }
          
          if (stepResult.results?.two_sample_ttest) {
            message += `**T-test Power Analysis:**\n`;
            Object.entries(stepResult.results.two_sample_ttest).forEach(([size, analysis]) => {
              message += `- ${size.replace('_', ' ')}: Power = ${analysis.power.toFixed(3)}, Required n = ${analysis.required_n}\n`;
            });
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'multiple_testing_correction') {
          let message = `** Multiple Testing Correction Results**\n\n`;
          
          if (stepResult.results?.number_of_tests) {
            message += `**Number of tests:** ${stepResult.results.number_of_tests}\n\n`;
          }
          
          if (stepResult.results?.comparison) {
            const comp = stepResult.results.comparison;
            message += `**Significant Tests:**\n`;
            message += `- Uncorrected: ${comp.uncorrected_significant}\n`;
            message += `- Bonferroni: ${comp.bonferroni_significant}\n`;
            message += `- Benjamini-Hochberg (FDR): ${comp.fdr_significant}\n`;
            message += `- Holm: ${comp.holm_significant}\n\n`;
          }
          
          if (stepResult.results?.interpretation) {
            const interp = stepResult.results.interpretation;
            message += `**Recommendations:**\n`;
            message += `- Most conservative: ${interp.most_conservative}\n`;
            message += `- Balanced approach: ${interp.balanced_approach}\n`;
            message += `- ${interp.recommendation}\n`;
          }
          
          addMessage(message, 'ai');
        } else if (stepResult.operation === 'custom_statistical_analysis') {
          let message = `** Custom Statistical Analysis**\n\n`;
          
          if (stepResult.results?.description) {
            message += `**Custom Request:** ${stepResult.results.description}\n\n`;
          }
          
          if (stepResult.results?.data_context) {
            const ctx = stepResult.results.data_context;
            message += `**Dataset:** ${ctx.dataframe_name} (${ctx.n_rows} rows  ${ctx.n_cols} columns)\n`;
            message += `**Variables:** ${ctx.column_names.join(', ')}\n\n`;
          }
          
          message += `**Status:** ${stepResult.results?.status || 'Preparing custom analysis'}\n\n`;
          message += ` **Sending custom analysis request to Claude for interpretation and code generation...**\n\n`;
          
          addMessage(message, 'ai');
          
          // Send custom analysis request to Claude
          if (stepResult.claude_prompt && ws && ws.readyState === WebSocket.OPEN) {
            console.log(' Sending custom statistical analysis to Claude');
            
            // Set flag to prevent duplicate requests
            window.customStatisticalAnalysisInProgress = true;
            
            ws.send(JSON.stringify({
              action: 'chat_with_ai',
              message: stepResult.claude_prompt,
              conversation_context: 'custom_statistical_analysis',
              agentType: 'statistical'
            }));
          }
        } else {
          // Generic display for other operations
          let operationName = stepResult.operation || stepResult.test || 'Statistical Analysis';
          let message = `** ${operationName.replace('_', ' ').toUpperCase()} Results**\n\n`;
          message += `Analysis completed successfully.\n`;
          addMessage(message, 'ai');
        }
      }
      
      // Handle statistical step result
      function handleStatisticalStepResult(stepResult) {
        console.log('Processing statistical step result:', stepResult);
        
        if (stepResult.success) {
          // Store result for final summary
          agentResults.push({
            description: (stepResult.operation || stepResult.test || 'Statistical Analysis').replace('_', ' ').toUpperCase(),
            output: formatStatisticalResultForSummary(stepResult),
            step: stepResult.step
          });
          
          // Display the results
          displayStatisticalStepResults(stepResult);
          
          // Move to next step
          requestNextStatisticalStep();
        } else {
          addMessage(` **Statistical Analysis Error:** ${stepResult.error}`, 'ai');
          finishAgentWorkflow();
        }
      }
      
      // Format statistical result for Claude summary
      function formatStatisticalResultForSummary(stepResult) {
        if (stepResult.operation === 'data_overview') {
          let summary = `Dataset: ${stepResult.results?.structure?.observation_count} observations, ${stepResult.results?.structure?.variable_count} variables\n`;
          if (stepResult.results?.data_types) {
            const types = Object.entries(stepResult.results.data_types);
            summary += `Variable types: ${types.map(([name, type]) => `${name}(${type})`).join(', ')}\n`;
          }
          return summary;
        } else if (stepResult.operation === 'distribution_analysis') {
          let summary = 'Distribution Analysis:\n';
          if (stepResult.results) {
            Object.entries(stepResult.results).forEach(([variable, analysis]) => {
              if (variable !== 'success' && variable !== 'step' && variable !== 'operation' && variable !== 'message') {
                summary += `${variable}: `;
                if (analysis.normality_test) {
                  summary += `${analysis.normality_test.is_normal ? 'Normal' : 'Non-normal'} distribution, `;
                }
                if (analysis.outlier_analysis) {
                  summary += `${analysis.outlier_analysis.outlier_count} outliers (${analysis.outlier_analysis.outlier_percentage}%)`;
                }
                summary += '\n';
              }
            });
          }
          return summary;
        } else if (stepResult.operation === 'group_comparisons') {
          let summary = 'Group Comparisons:\n';
          if (stepResult.results?.test_type) {
            summary += `Test: ${stepResult.results.test_type}\n`;
          }
          if (stepResult.results?.test_result) {
            const result = stepResult.results.test_result;
            if (result.p_value !== undefined) {
              summary += `p-value: ${result.p_value.toFixed(4)}, ${result.p_value < 0.05 ? 'Significant' : 'Not significant'}\n`;
            }
          }
          if (stepResult.results?.effect_size) {
            const effect = stepResult.results.effect_size;
            if (effect.eta_squared) {
              summary += `Effect size (): ${effect.eta_squared.toFixed(3)}\n`;
            }
            if (effect.cohens_d) {
              summary += `Effect size (Cohen's d): ${effect.cohens_d.toFixed(3)}\n`;
            }
          }
          return summary;
        } else if (stepResult.operation === 'before_after_analysis') {
          let summary = 'Before/After Analysis:\n';
          if (stepResult.results?.paired_test) {
            const test = stepResult.results.paired_test;
            summary += `Test: ${test.test_type}, p-value: ${test.p_value.toFixed(4)}, ${test.significance ? 'Significant' : 'Not significant'}\n`;
          }
          if (stepResult.results?.effect_size) {
            summary += `Effect size (Cohen's d): ${stepResult.results.effect_size.cohens_d.toFixed(3)}\n`;
          }
          return summary;
        } else if (stepResult.operation === 'power_analysis') {
          let summary = 'Power Analysis:\n';
          if (stepResult.results?.current_sample_size) {
            summary += `Current sample size: ${stepResult.results.current_sample_size}\n`;
          }
          if (stepResult.results?.basic_guidelines) {
            summary += 'Sample size guidelines for 80% power provided\n';
          }
          return summary;
        } else if (stepResult.operation === 'multiple_testing_correction') {
          let summary = 'Multiple Testing Correction:\n';
          if (stepResult.results?.comparison) {
            const comp = stepResult.results.comparison;
            summary += `Uncorrected: ${comp.uncorrected_significant} significant tests\n`;
            summary += `Bonferroni: ${comp.bonferroni_significant} significant tests\n`;
            summary += `FDR: ${comp.fdr_significant} significant tests\n`;
          }
          return summary;
        } else if (stepResult.operation === 'custom_statistical_analysis') {
          let summary = 'Custom Statistical Analysis:\n';
          if (stepResult.results?.description) {
            summary += `Request: ${stepResult.results.description.substring(0, 100)}${stepResult.results.description.length > 100 ? '...' : ''}\n`;
          }
          summary += 'Sent to Claude for interpretation and code generation\n';
          return summary;
        } else if (stepResult.test) {
          // Handle categorical tests and other tests with 'test' property
          let summary = `${stepResult.test}:\n`;
          if (stepResult.result) {
            const result = stepResult.result;
            if (result.statistic !== undefined) {
              summary += `Test statistic: ${result.statistic.toFixed(4)}\n`;
            }
            if (result.p_value !== undefined) {
              summary += `p-value: ${result.p_value.toFixed(4)}, ${result.p_value < 0.05 ? 'Significant' : 'Not significant'}\n`;
            }
            if (result.parameter !== undefined) {
              summary += `Degrees of freedom: ${result.parameter}\n`;
            }
            if (result.method) {
              summary += `Method: ${result.method}\n`;
            }
          }
          if (stepResult.contingency_table) {
            summary += `Contingency table available\n`;
          }
          if (stepResult.interpretation) {
            summary += `Interpretation: ${stepResult.interpretation}\n`;
          }
          return summary;
        }
        return 'Analysis completed successfully';
      }
      
      // Request next statistical step
      function requestNextStatisticalStep() {
        if (!currentAgentWorkflow) return;
        
        currentAgentWorkflow.currentStep++;
        console.log(`Requesting next statistical step: ${currentAgentWorkflow.currentStep}/${currentAgentWorkflow.totalSteps}`);
        
        if (currentAgentWorkflow.currentStep <= currentAgentWorkflow.workflowSteps.length) {
          const nextStep = currentAgentWorkflow.workflowSteps[currentAgentWorkflow.currentStep - 1];
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              action: 'get_next_statistical_step_code',
              dataframe: currentAgentWorkflow.dataframe,
              step_info: nextStep,
              variables: currentAgentWorkflow.variables,
              method_options: currentAgentWorkflow.methodOptions,
              custom_inputs: currentAgentWorkflow.customInputs
            }));
          }
        } else {
          console.log('Statistical analysis workflow completed');
          finishAgentWorkflow();
        }
      }
      
      // Finish agent workflow  
      function finishAgentWorkflow() {
        console.log('Finishing agent workflow');
        
        // Check if custom analysis is in progress - if so, skip normal summary
        if (window.customStatisticalAnalysisInProgress || window.customTransformationInProgress) {
          console.log('Custom analysis in progress, skipping normal workflow completion');
          // Clear workflow state without sending summary
          currentAgentWorkflow = null;
          agentResults = [];
          agentCodes = [];
          // Reset button will be handled by finishStreaming() when Claude response completes
          return;
        }
        
        // Determine agent type and send appropriate summary
        const agentType = window.currentActiveAgentType || 'Unknown';
        
        if (agentType === 'Statistical') {
          sendStatisticalSummaryToClaude();
        } else if (agentType === 'Transformation') {
          sendTransformationSummaryToClaude();
        } else if (agentType === 'Cleaning') {
          sendCleaningSummaryToClaude();
        } else if (agentType === 'Modeling') {
          sendModelingSummaryToClaude();
        } else {
          // Unknown agent type - log error
          console.error('Unknown agent type:', agentType);
          addMessage(` **Agent Error:** Unknown agent type "${agentType}"`, 'ai');
        }
        
        // Clear workflow state
        currentAgentWorkflow = null;
        agentResults = [];
        agentCodes = [];
        
        // Reset button will be handled by finishStreaming() when Claude response completes
      }
      
      // Send statistical analysis summary to Claude
      function sendStatisticalSummaryToClaude() {
        if (!currentAgentWorkflow) return;
        
        createAnimatedPlaceholder("ai-analyzing-statistical", " **Analyzing Results** Sending statistical findings to Claude for comprehensive summary");
        
        // Format results for Claude
        const summaryText = `Analyze these statistical analysis results for the "${currentAgentWorkflow.dataframe}" dataset and provide a BRIEF summary:

${agentResults.map(result => `
**${result.description}:**
${result.output}
`).join('\n')}

Provide a CONCISE summary (max 3-4 sentences) covering:
- Key statistical findings
- Data quality insights  
- Main patterns or issues discovered

Keep it brief and focused. Dataset: ${currentAgentWorkflow.dataframe}`;

        // Send to Claude for analysis
        if (ws && ws.readyState === WebSocket.OPEN) {
          window.lastMessageContext = "agent_summary";
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: summaryText,
            conversation_context: 'data_statistical_agent_summary'
          }));
        }
        
        // Store the agent type and results for the follow-up code request
        // We'll send this after the first response completes
        window.pendingAgentCodeRequest = {
          agentType: 'statistical',
          operationType: 'statistical analysis',
          agentResults,
          currentAgentWorkflow: currentAgentWorkflow
        };
      }
      
      // Send transformation analysis summary to Claude
      function sendTransformationSummaryToClaude() {
        if (!currentAgentWorkflow) return;
        
        createAnimatedPlaceholder("ai-analyzing-transformation", " **Analyzing Results** Sending transformation findings to Claude for comprehensive summary");
        
        // Format results for Claude
        const summaryText = `Analyze these data transformation results for the "${currentAgentWorkflow.dataframe}" dataset and provide a BRIEF summary:

${agentResults.map(result => `
**${result.description}:**
${result.output}
`).join('\n')}

Provide a CONCISE summary (max 3-4 sentences) covering:
- Key transformation changes made
- Data quality improvements
- New variables or structures created

Keep it brief and focused. Dataset: ${currentAgentWorkflow.dataframe}`;

        // Send to Claude for analysis
        if (ws && ws.readyState === WebSocket.OPEN) {
          window.lastMessageContext = "agent_summary";
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: summaryText,
            conversation_context: 'data_transformation_agent_summary'
          }));
        }
        
        // Store the agent type and results for the follow-up code request
        // We'll send this after the first response completes
        window.pendingAgentCodeRequest = {
          agentType: 'transformation',
          operationType: 'data transformation',
          agentResults,
          currentAgentWorkflow: currentAgentWorkflow
        };
      }
      
      // Send data cleaning analysis summary to Claude
      function sendCleaningSummaryToClaude() {
        if (!currentAgentWorkflow) return;
        
        createAnimatedPlaceholder("ai-analyzing-cleaning", " **Analyzing Results** Sending data cleaning findings to Claude for comprehensive summary");
        
        // Format results for Claude
        const summaryText = `Analyze these data cleaning results for the "${currentAgentWorkflow.dataframe}" dataset and provide a BRIEF summary:

${agentResults.map(result => `
**${result.description}:**
${result.output}
`).join('\n')}

Provide a CONCISE summary (max 3-4 sentences) covering:
- Data quality issues found
- Missing values and outliers detected
- Key cleaning steps needed

Keep it brief and focused. Dataset: ${currentAgentWorkflow.dataframe}`;

        // Send to Claude for analysis
        if (ws && ws.readyState === WebSocket.OPEN) {
          window.lastMessageContext = "agent_summary";
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: summaryText,
            conversation_context: 'data_cleaning_agent_summary'
          }));
        }
        
        // Store the agent type and results for the follow-up code request
        // We'll send this after the first response completes
        window.pendingAgentCodeRequest = {
          agentType: 'cleaning',
          operationType: 'data cleaning',
          agentResults,
          currentAgentWorkflow: currentAgentWorkflow
        };
      }
      
      // Send modeling analysis summary to Claude
      function sendModelingSummaryToClaude() {
        if (!currentAgentWorkflow) return;
        
        createAnimatedPlaceholder("ai-analyzing-modeling", " **Analyzing Results** Sending modeling findings to Claude for comprehensive summary");
        
        // Format results for Claude
        const summaryText = `Analyze these modeling results for the "${currentAgentWorkflow.dataframe}" dataset and provide a BRIEF summary:

${agentResults.map(result => `
**${result.description}:**
${result.output}
`).join('\n')}

Provide a CONCISE summary (max 3-4 sentences) covering:
- Key model characteristics and suitability
- Data preparation completed
- Modeling approach recommendations

Keep it brief and focused. Dataset: ${currentAgentWorkflow.dataframe}`;

        // Send to Claude for analysis
        if (ws && ws.readyState === WebSocket.OPEN) {
          window.lastMessageContext = "agent_summary";
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: summaryText,
            conversation_context: 'data_modeling_agent_summary'
          }));
        }
        
        // Store the agent type and results for the follow-up code request
        // We'll send this after the first response completes
        window.pendingAgentCodeRequest = {
          agentType: 'modeling',
          operationType: 'predictive modeling',
          agentResults,
          currentAgentWorkflow: currentAgentWorkflow
        };
      }
      
      // Handle modeling agent started response
      function handleModelingAgentStarted(result) {
        console.log(' handleModelingAgentStarted called with:', result);
        
        // Track current agent type for success messages
        window.currentActiveAgentType = 'Modeling';
        
        if (result.success) {
          const totalSteps = result.total_steps || result.workflow_steps?.length || 'Unknown';
          const stepNum = result.current_step?.step || 1;
          const stepDesc = result.current_step?.description || 'Starting...';
          
          // Show selected modeling algorithms
          const selectedAlgorithms = [];
          if (result.algorithms) {
            if (result.algorithms.dimensionalityReduction) selectedAlgorithms.push('Dimensionality Reduction');
            if (result.algorithms.linearRegression) selectedAlgorithms.push('Linear Regression');
            if (result.algorithms.logisticRegression) selectedAlgorithms.push('Logistic Regression');
            if (result.algorithms.multinomialRegression) selectedAlgorithms.push('Multinomial Regression');
            if (result.algorithms.randomForest) selectedAlgorithms.push('Random Forest');
            if (result.algorithms.xgboost) selectedAlgorithms.push('XGBoost');
          }
          
          const algorithmsText = selectedAlgorithms.length > 0 ? `\n**Algorithms:**\n   ${selectedAlgorithms.join('\n   ')}` : '';
          
          addMessage(`**Modeling Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** ${stepDesc}${algorithmsText}`, 'ai');
          
          console.log('Modeling agent started with workflow:', result);
          
          // Initialize the workflow tracking
          currentAgentWorkflow = {
            dataframe: result.dataframe,
            targetVariable: result.target_variable,
            algorithms: result.algorithms,
            options: result.options,
            workflowSteps: result.workflow_steps,
            selected_variables: result.selected_variables,
            currentStep: 1,
            totalSteps: result.total_steps
          };
          
          console.log(' Modeling agent workflow initialized:', {
            dataframe: currentAgentWorkflow.dataframe,
            targetVariable: currentAgentWorkflow.targetVariable,
            algorithms: currentAgentWorkflow.algorithms,
            selected_variables: currentAgentWorkflow.selected_variables,
            totalSteps: currentAgentWorkflow.totalSteps,
            workflowStepsLength: currentAgentWorkflow.workflowSteps?.length
          });
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Execute the first step
          if (result.current_step && result.current_step.code) {
            console.log('Executing first modeling step code:', result.current_step.code);
            
            // Store the code for later display
            currentStepCode = result.current_step.code;
            
            // Agent workflow steps are ALWAYS auto-executed (predefined code)
            // The auto-execute toggle only applies to final Claude-generated code
            if (ws && ws.readyState === WebSocket.OPEN) {
              console.log(' Executing first modeling workflow step');
              ws.send(JSON.stringify({
                action: 'execute_code',
                code: result.current_step.code
              }));
            }
          } else {
            console.log('No code to execute for first modeling step');
          }
        } else {
          addMessage(` **Modeling Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Execute next step in agent workflow
      function executeNextAgentStep() {
        console.log(' executeNextAgentStep called');
        
        if (!currentAgentWorkflow) {
          console.log(' No active agent workflow');
          return;
        }
        
        console.log(' Workflow state before increment:', {
          currentStep: currentAgentWorkflow.currentStep,
          totalSteps: currentAgentWorkflow.totalSteps,
          workflowSteps: currentAgentWorkflow.workflowSteps?.length,
          agentType: currentAgentWorkflow.algorithms ? 'Modeling' : 
                    currentAgentWorkflow.transformationOptions ? 'Transformation' : 'Cleaning'
        });
        
        currentAgentWorkflow.currentStep++;
        console.log(' After increment - Current step:', currentAgentWorkflow.currentStep);
        
        if (currentAgentWorkflow.currentStep > currentAgentWorkflow.totalSteps) {
          console.log(' Workflow complete - exceeded total steps');
          console.log(' Final workflow state:', {
            currentStep: currentAgentWorkflow.currentStep,
            totalSteps: currentAgentWorkflow.totalSteps,
            agentType: currentAgentWorkflow.algorithms ? 'Modeling' : 
                      currentAgentWorkflow.transformationOptions ? 'Transformation' : 'Cleaning'
          });
          
          // Check if agent was stopped before proceeding
          if (currentAgentWorkflow.stopped) {
            console.log(' Agent was stopped, not proceeding with Claude analysis');
            return;
          }
          
          // Workflow complete - detect agent type
          let agentType = 'Cleaning';
          if (currentAgentWorkflow?.transformationOptions) {
            agentType = 'Transformation';
          } else if (currentAgentWorkflow?.algorithms) {
            agentType = 'Modeling';
          }
          addMessage(` **${agentType} Agent Complete!** All ${currentAgentWorkflow.totalSteps} operations finished.`, "ai");
          
          // Store workflow data before clearing
          const workflowData = {
            dataframe: currentAgentWorkflow.dataframe,
            methodOptions: currentAgentWorkflow.methodOptions,
            customInputs: currentAgentWorkflow.customInputs
          };
          
          // Clear workflow state
          currentAgentWorkflow = null;
          
          // Only proceed with Claude analysis if agent wasn't stopped
          if (workflowData) {
            finishAgentWorkflow();
          }
          return;
        }
        
        // Get the next step from the workflow
        const nextStepIndex = currentAgentWorkflow.currentStep - 1;
        console.log(' Next step index:', nextStepIndex);
        console.log(' Available workflow steps:', currentAgentWorkflow.workflowSteps);
        
        const nextStep = currentAgentWorkflow.workflowSteps[nextStepIndex];
        console.log(' Next step:', nextStep);
        
        if (nextStep) {
          // Check if agent was stopped before proceeding with next step
          if (currentAgentWorkflow.stopped) {
            console.log(' Agent was stopped, not proceeding with next step');
            return;
          }
          
          addMessage(` **Step ${currentAgentWorkflow.currentStep}/${currentAgentWorkflow.totalSteps}:**\n   ${nextStep.description}`, 'ai');
          
          console.log(' Requesting code for next step via WebSocket');
          
          // Handle different agent types
          if (currentAgentWorkflow.algorithms) {
            // Modeling agent
            const requestData = {
              action: 'get_next_modeling_step_code',
              dataframe: currentAgentWorkflow.dataframe,
              step_info: nextStep,
              target_variable: currentAgentWorkflow.targetVariable,
              algorithms: currentAgentWorkflow.algorithms,
              selected_variables: currentAgentWorkflow.selected_variables
            };
            console.log(' Sending modeling step request with selected_variables:', currentAgentWorkflow.selected_variables);
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify(requestData));
            } else {
              console.log(' WebSocket not available');
            }
          } else {
            // Cleaning or transformation agent
            const requestData = {
              action: 'get_next_step_code',
              dataframe: currentAgentWorkflow.dataframe,
              step_info: nextStep,
              method_options: currentAgentWorkflow.methodOptions,
              custom_inputs: currentAgentWorkflow.customInputs
            };
            
            // Add transformation-specific parameters for transformation agent
            if (currentAgentWorkflow.transformationOptions) {
              requestData.transformation_options = currentAgentWorkflow.transformationOptions;
            } else {
              requestData.na_handling = currentAgentWorkflow.naHandling;
            }
            
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify(requestData));
            } else {
              console.log(' WebSocket not available');
            }
          }
        } else {
          console.log(' No next step found');
        }
      }
      
      // Send agent results to Claude for summary
      function sendAgentSummaryToClaude() {
        // Detect agent type for appropriate messaging
        let agentType = 'cleaning';
        let operationType = 'cleaning';
        
        if (currentAgentWorkflow?.transformationOptions) {
          agentType = 'transformation';
          operationType = 'transformation';
        } else if (currentAgentWorkflow?.algorithms) {
          agentType = 'modeling';
          operationType = 'modeling';
        }
        
        createAnimatedPlaceholder("ai-analyzing-results", " **Analyzing Results** Sending findings to Claude for comprehensive summary");
        
        // Format results for Claude - Summary first
        const summaryText = `Analyze these ${operationType} results for the "${currentAgentWorkflow?.dataframe}" dataset and provide a BRIEF summary:

${agentResults.map(result => `
**${result.description}:**
${result.output}
`).join('\n')}

Provide a CONCISE summary (max 3-4 sentences) covering:
- Key issues found
- Overall data quality
- Main recommendations

Keep it brief and focused. Dataset: ${currentAgentWorkflow?.dataframe}`;

        // Send to AI chat
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: summaryText,
            conversation_context: `data_${agentType}_agent_summary`
          }));
        }
        
        // Store the agent type and results for the follow-up code request
        // We'll send this after the first response completes
        window.pendingAgentCodeRequest = {
          agentType,
          operationType,
          agentResults,
          currentAgentWorkflow: currentAgentWorkflow
        };
      }
      
      // Generate final modeling code directly (like other agents do)
      function generateFinalModelingCode() {
        const targetVar = currentAgentWorkflow?.targetVariable || 'target_variable';
        const dataframe = currentAgentWorkflow?.dataframe || 'df';
        const algorithms = currentAgentWorkflow?.algorithms || {};
        
        // Get the selected algorithms
        const selectedAlgorithms = Object.entries(algorithms)
          .filter(([key, value]) => value)
          .map(([key, value]) => key);
        
        let code = `# Final Modeling Code for ${dataframe} dataset
# Target Variable: ${targetVar}
# Selected Algorithms: ${selectedAlgorithms.join(', ')}

# Set seed for reproducibility
set.seed(123)

# Split data into train/test sets
train_idx <- sample(1:nrow(${dataframe}), 0.7 * nrow(${dataframe}))
train_data <- ${dataframe}[train_idx, ]
test_data <- ${dataframe}[-train_idx, ]

# Ensure categorical variables are factors
categorical_cols <- sapply(train_data, is.character)
train_data[categorical_cols] <- lapply(train_data[categorical_cols], as.factor)
test_data[categorical_cols] <- lapply(test_data[categorical_cols], as.factor)

# Train models based on selected algorithms
`;

        // Add code for each selected algorithm
        if (algorithms.linearRegression) {
          code += `
# Linear Regression
features <- names(${dataframe})[names(${dataframe}) != "${targetVar}"]
formula <- as.formula(paste("${targetVar} ~", paste(features, collapse = " + ")))
lm_model <- lm(formula, data = train_data)

# Evaluate linear regression
lm_predictions <- predict(lm_model, test_data)
lm_rmse <- sqrt(mean((test_data$${targetVar} - lm_predictions)^2))
lm_r2 <- 1 - sum((test_data$${targetVar} - lm_predictions)^2) / 
         sum((test_data$${targetVar} - mean(test_data$${targetVar}))^2)

cat("Linear Regression Results:\\n")
cat("RMSE:", round(lm_rmse, 4), "\\n")
cat("R:", round(lm_r2, 4), "\\n\\n")
`;
        }

        if (algorithms.randomForest) {
          code += `
# Random Forest
if (require(randomForest)) {
  rf_model <- randomForest(${targetVar} ~ ., data = train_data, ntree = 100)
  rf_predictions <- predict(rf_model, test_data)
  rf_rmse <- sqrt(mean((test_data$${targetVar} - rf_predictions)^2))
  
  cat("Random Forest Results:\\n")
  cat("RMSE:", round(rf_rmse, 4), "\\n\\n")
} else {
  cat("randomForest package not available\\n\\n")
}
`;
        }

        if (algorithms.xgboost) {
          code += `
# XGBoost
if (require(xgboost)) {
  # Prepare data for XGBoost
  train_matrix <- model.matrix(${targetVar} ~ . - 1, data = train_data)
  test_matrix <- model.matrix(${targetVar} ~ . - 1, data = test_data)
  
  xgb_model <- xgboost(data = train_matrix, 
                       label = train_data$${targetVar},
                       nrounds = 100, 
                       objective = "reg:squarederror",
                       verbose = 0)
  
  xgb_predictions <- predict(xgb_model, test_matrix)
  xgb_rmse <- sqrt(mean((test_data$${targetVar} - xgb_predictions)^2))
  
  cat("XGBoost Results:\\n")
  cat("RMSE:", round(xgb_rmse, 4), "\\n\\n")
} else {
  cat("xgboost package not available\\n\\n")
}
`;
        }

        // Add visualization code
        code += `
# Visualization
if (require(ggplot2)) {
  # Create a simple summary plot of the target variable
  p <- ggplot(${dataframe}, aes(x = ${targetVar})) +
    geom_histogram(bins = 20, fill = "steelblue", alpha = 0.7) +
    labs(title = "Distribution of ${targetVar}",
         x = "${targetVar}",
         y = "Count") +
    theme_minimal()
  
  print(p)
  
  # If we have predictions, create comparison plot
  if (exists("lm_predictions") && length(lm_predictions) > 0) {
    results_df <- data.frame(
      Actual = test_data$${targetVar},
      Predicted = lm_predictions
    )
    
    p2 <- ggplot(results_df, aes(x = Actual, y = Predicted)) +
      geom_point(alpha = 0.6) +
      geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
      labs(title = "Actual vs Predicted Values",
           subtitle = "Linear Regression Model",
           x = "Actual ${targetVar}",
           y = "Predicted ${targetVar}") +
      theme_minimal()
    
    print(p2)
  }
} else {
  cat("ggplot2 package not available for visualization\\n")
}

cat("\\nModeling workflow completed successfully!\\n")
`;

        return code;
      }
      
      // Show the executed code for each step with copy/insert functionality
      function showAgentCodeSections() {
        // Detect agent type for appropriate messaging
        let agentType = 'cleaning';
        let operationType = 'cleaning';
        
        if (currentAgentWorkflow?.transformationOptions) {
          agentType = 'transformation';
          operationType = 'transformation';
        } else if (currentAgentWorkflow?.algorithms) {
          agentType = 'modeling';
          operationType = 'modeling';
        }
        
        // Show insert all button first
        addMessage(` **${agentType.charAt(0).toUpperCase() + agentType.slice(1)} Agent Complete!** Generated R code for ${agentCodes.length} ${operationType} steps.`, 'ai');
        
        // Add insert all button
        setTimeout(() => {
          addInsertAllButton();
        }, 100);
        
        // Then show manual options
        setTimeout(() => {
          showManualCodeSections();
        }, 500);
      }
      
      // Add insert all button
      function addInsertAllButton() {
        const container = document.getElementById("chat-container");
        const buttonDiv = document.createElement("div");
        buttonDiv.className = "insert-all-container";
        buttonDiv.style.cssText = "margin: 15px 0; text-align: center;";
        
        const insertAllBtn = document.createElement("button");
        insertAllBtn.textContent = " Insert All Code Chunks to Editor";
        insertAllBtn.className = "insert-all-btn";
        insertAllBtn.style.cssText = "padding: 12px 24px; background: var(--text-primary); color: var(--bg-primary); border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600; box-shadow: 0 2px 4px rgba(0,0,0,0.1);";
        insertAllBtn.onclick = () => {
          console.log(' Insert All button clicked');
          insertAllBtn.disabled = true;
          insertAllBtn.textContent = " Inserting...";
          insertAllAgentCode();
        };
        
        buttonDiv.appendChild(insertAllBtn);
        container.appendChild(buttonDiv);
        container.scrollTop = container.scrollHeight;
      }
      
      // Insert all agent code as separate R chunks
      function insertAllAgentCode() {
        console.log(' Starting insertAllAgentCode');
        console.log(' Agent codes to insert:', agentCodes);
        console.log(' WebSocket state:', ws ? ws.readyState : 'no ws');
        
        if (!agentCodes || agentCodes.length === 0) {
          console.log(' No agent codes to insert');
          addMessage(` **Error:** No code to insert. Please try running the agent again.`, 'ai');
          return;
        }
        
        agentCodes.forEach((codeStep, index) => {
          setTimeout(() => {
            const codeChunk = `\`\`\`{r}\n# ${codeStep.description}\n${codeStep.code}\n\`\`\``;
            
            console.log(` Inserting step ${index + 1}/${agentCodes.length}:`, codeChunk.substring(0, 100) + '...');
            
            if (ws && ws.readyState === WebSocket.OPEN) {
              const message = {
                action: 'insert_code',
                code: codeChunk
              };
              console.log(' Sending WebSocket message:', message);
              ws.send(JSON.stringify(message));
            } else {
              console.log(' WebSocket not available for insertion');
              addMessage(` **Connection Error:** Unable to insert code. WebSocket not connected.`, 'ai');
            }
            
            // Show progress
            if (index === agentCodes.length - 1) {
              setTimeout(() => {
                console.log(' All insertions completed');
                addMessage(` **All Code Inserted!** ${agentCodes.length} R code chunks have been added to your editor.`, 'ai');
                
                // Re-enable button
                const insertBtn = document.querySelector('.insert-all-btn');
                if (insertBtn) {
                  insertBtn.disabled = false;
                  insertBtn.textContent = " Insert All Code Chunks to Editor";
                }
              }, 200);
            }
          }, 300 * index); // Stagger insertions
        });
      }
      
      // Show manual code sections with copy/insert buttons
      function showManualCodeSections() {
        addPlotAnalysisMessage(` **Generated R Code by Step:**\n\nBelow is the R code that was executed for each cleaning operation. You can copy or insert any section into your editor:`);
        
        agentCodes.forEach((codeStep, index) => {
          const codeContent = `\`\`\`r\n# ${codeStep.description}\n${codeStep.code}\n\`\`\``;
          
          // Use addPlotAnalysisMessage which shows only Copy/Insert buttons (no Execute & Fix)
          setTimeout(() => {
            addPlotAnalysisMessage(`**Step ${codeStep.step}: ${codeStep.description}**\n\n${codeContent}`);
          }, 200 * (index + 1));
        });
      }
      

      
      // Handle agent step response
      function handleAgentStep(result) {
        // Clear the step timeout since we received a response
        if (currentAgentStepTimeout) {
          clearTimeout(currentAgentStepTimeout);
          currentAgentStepTimeout = null;
        }
        
        if (result.success) {
          if (result.completed) {
            // Detect agent type for completion message
            let agentType = 'Cleaning';
            if (currentAgentWorkflow?.transformationOptions) {
              agentType = 'Transformation';
            } else if (currentAgentWorkflow?.problemType) {
              agentType = 'Modeling';
            }
            addMessage(` **${agentType} Agent Completed!**\n\nAll ${result.total_steps} steps have been executed successfully.`, 'ai');
          } else {
            addMessage(` **Step ${result.step}/${result.total_steps}:** ${result.description}`, 'ai');
            if (result.code) {
              executeAgentCode(result.code, getCurrentDataFrame(), getCurrentNAHandling(), result.step);
            }
          }
        } else {
          addMessage(` **Step ${result.step} Error:** ${result.error}`, 'ai');
        }
      }
      
      // Execute agent code and continue to next step
      function executeAgentCode(code, dataframe, naHandling, currentStep) {
        if (ws && isConnected) {
          // Add code message to chat
          addMessage(code, 'user');
          
          // Agent workflow steps are ALWAYS auto-executed (predefined code)
          // The auto-execute toggle only applies to final Claude-generated code
          console.log(' Executing agent workflow step code');
          
          // Set a timeout to detect if we never receive a response (90 seconds)
          currentAgentStepTimeout = setTimeout(() => {
            if (currentAgentWorkflow) {
              console.error(' Agent step timed out after 90 seconds');
              addMessage(` **Timeout Warning:** Agent step took longer than expected. The workflow may have stalled.\n\nYou can:\n- Wait for the step to complete\n- Stop the agent workflow and try again\n- Check the R console for errors`, 'ai');
              currentAgentStepTimeout = null;
            }
          }, 90000); // 90 second timeout
          
          pendingTimeouts.push(currentAgentStepTimeout);
          
          ws.send(JSON.stringify({
            action: 'execute_code',
            code: code
          }));
          
          // After a brief delay, request next step based on agent type
          const nextStepTimeout = setTimeout(() => {
            if (currentAgentWorkflow?.problemType) {
              // Modeling agent - use the step-by-step execution flow
              executeNextAgentStep();
            } else {
              // Cleaning or transformation agent - use the legacy flow
              ws.send(JSON.stringify({
                action: 'next_agent_step',
                dataframe: dataframe,
                na_handling: naHandling,
                step: currentStep + 1
              }));
            }
          }, 1000);
          
          pendingTimeouts.push(nextStepTimeout);
        }
      }
      
      // Helper functions for agent state
      let currentAgentDataFrame = null;
      let currentAgentNAHandling = null;
      let currentAgentStepTimeout = null; // Track the current step timeout
      
      function getCurrentDataFrame() { return currentAgentDataFrame; }
      function getCurrentNAHandling() { return currentAgentNAHandling; }
      function setCurrentAgent(dataframe, naHandling) {
        currentAgentDataFrame = dataframe;
        currentAgentNAHandling = naHandling;
      }
      
      // Global iteration counter for error handling
      let cleaningCodeIterationCount = 0;
      const MAX_CLEANING_ITERATIONS = 3;
      let cleaningCodeExecuting = false; // Flag to prevent duplicate handling
      

      
      // Handle Claude's cleaning code response with automatic execution and error handling
      function handleCleaningCodeResponse(message, conversationContext) {
        // Check if operation was stopped
        if (operationStopped) {
          console.log(' Operation was stopped, ignoring code response');
          return;
        }
        
        console.log(' Handling Claude cleaning code response');
        console.log(' Message received:', message);
        console.log(' Conversation context:', conversationContext);
        
        // Check if this is modeling agent code - respect auto-execute toggle
        if (conversationContext === 'data_modeling_agent_code' || currentAgentWorkflow?.algorithms) {
          const autoExecute = isAutoExecuteEnabled();
          
          if (autoExecute) {
            console.log(' This is modeling agent code with auto-execute enabled - will execute code');
            // Continue to normal execution flow below
          } else {
            console.log(' This is modeling agent code with auto-execute disabled - showing success message without execution');
          addMessage(`**Modeling Code Generated Successfully!**\n\nThe modeling workflow has completed and Claude has provided the final R code for your selected algorithms.`, 'ai');
          addMessage(`**Next Steps:**\n- Copy the code above to your R script\n- Execute it in your R environment\n- The modeling agent workflow is now complete!`, 'ai');
          
          // Reset workflow state
          currentAgentWorkflow = null;
          
          // Don't reset button yet - wait for AI response streaming to complete
          // The button will be reset in finishStreaming() when streaming is done
          return;
          }
        }
        
        // Extract R code from the message
        const codeBlocks = extractRCodeBlocks(message);
        console.log(' Extracted code blocks:', codeBlocks);
        
        if (codeBlocks.length === 0) {
          addMessage(' **No R code found** in Claude\'s response. Please ask for executable R code.', 'ai');
          cleaningCodeExecuting = false;
          cleaningCodeIterationCount = 0;
          return;
        }
        
        // Get the ORIGINAL formatted code from the message (not extracted)
        const originalCode = getOriginalFormattedCode(message);
        console.log(' Original formatted code:', originalCode.substring(0, 200) + '...');
        
        // Validate that we got actual code
        if (!originalCode || originalCode.trim().length === 0) {
          console.error(' Code extraction failed: originalCode is empty');
          addMessage(' **Code Extraction Error:** Unable to extract code from the response. The code block may be malformed.', 'ai');
          cleaningCodeExecuting = false;
          cleaningCodeIterationCount = 0;
          return;
        }
        
        // Combine extracted code blocks for display
        const combinedCode = codeBlocks.join('\n\n');
        console.log(' Combined code to execute:', combinedCode);
        
        // Double-check combined code is not empty
        if (!combinedCode || combinedCode.trim().length === 0) {
          console.error(' Code extraction failed: combinedCode is empty');
          addMessage(' **Code Extraction Error:** Extracted code is empty. Please try asking Claude to provide the code again.', 'ai');
          cleaningCodeExecuting = false;
          cleaningCodeIterationCount = 0;
          return;
        }
        
        // Check if auto-execute is enabled
        const autoExecute = isAutoExecuteEnabled();
        
        // Clear agent final code flag after handling
        window.isAgentFinalCode = false;
        
        if (autoExecute) {
          // Store the code for error handling
          currentStepCode = originalCode;
          
          // Execute the code automatically
          executeCleaningCodeWithErrorHandling(originalCode);
        } else {
          // Manual mode: Don't add a new message, just add the execute button to the existing code block
          // The code block is already displayed by the normal message processing
          
          // Manual mode: Simple approach - add execute button directly to the last AI message
          setTimeout(() => {
            console.log(' Manual mode: Adding execute button to last AI message...');
            
            // Find the last AI message (which should contain the code block)
            const lastAIMessage = document.querySelector('.ai-message:last-child');
            
            if (lastAIMessage) {
              console.log(' Last AI message found, adding execute button...');
              
              // Create a simple execute button container
              const buttonContainer = document.createElement('div');
              buttonContainer.style.marginTop = '15px';
              buttonContainer.style.padding = '10px';
              buttonContainer.style.backgroundColor = '#f8f9fa';
              buttonContainer.style.borderRadius = '6px';
              buttonContainer.style.border = '1px solid #e9ecef';
              buttonContainer.style.textAlign = 'center';
              
              const executeButton = document.createElement('button');
              executeButton.textContent = 'Execute Code';
              executeButton.className = 'execute-cleaning-button';
              executeButton.onclick = () => {
                executeCleaningCodeWithErrorHandling(originalCode);
                // Remove the button after clicking
                buttonContainer.remove();
              };
              
              buttonContainer.appendChild(executeButton);
              lastAIMessage.appendChild(buttonContainer);
              
              console.log(' Execute button added to last AI message');
            } else {
              console.log(' No AI message found');
            }
          }, 300); // Simple 300ms delay
        }
        
        // Use the existing copyToClipboard function to preserve formatting
        // Create a temporary button for the copy function
        const tempButton = document.createElement('button');
        tempButton.textContent = 'Copy';
        copyToClipboard(originalCode, tempButton);
      }
      
      // Extract R code blocks from Claude's message (ONLY R blocks, not output/other languages)
      function extractRCodeBlocks(message) {
        
        // Decode HTML entities first - messages from streaming may be HTML-encoded
        // Create a temporary div to decode HTML entities
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = message;
        let decodedMessage = tempDiv.textContent || tempDiv.innerText || message;
        
        // If decoding didn't work or message wasn't HTML, use original
        if (!decodedMessage || decodedMessage === message) {
          // Try manual decoding of common entities
          decodedMessage = message
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/&nbsp;/g, ' ');
        }
        
        console.log(' Decoded message preview:', decodedMessage.substring(0, 200) + '...');
        
        // ONLY match R code blocks - NOT plain ``` or other languages
        // Matches: ```r, ```R, ```{r}, ```{R} followed by newline/whitespace then content then closing ```
        const codeBlockRegex = /```(?:\{[rR]\}|[rR])(?:\n|\s+)([\s\S]*?)```/g;
        const codeBlocks = [];
        let match;
        
        while ((match = codeBlockRegex.exec(decodedMessage)) !== null) {
          const codeContent = match[1];
          console.log(' Found code block:', codeContent.substring(0, 100) + '...');
          
          // Remove any language identifier that might be at the start (like {r}, r, etc.)
          let cleanedCode = codeContent
            .replace(/^\{[rR]\}\s*\n?/, '') // Remove {r} or {R} at start
            .replace(/^\s*\{[rR]\}\s*\n?/, '') // Remove {r} or {R} with whitespace
            .replace(/^[rR]\s+/, '') // Remove r or R followed by whitespace (not part of function name)
            .replace(/^\s*[rR]\s+/, ''); // Remove r or R with surrounding whitespace
          
          // Decode any remaining HTML entities in the code content
          cleanedCode = cleanedCode
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
          
          // AGGRESSIVELY preserve line breaks - this is critical for R syntax
          // Only remove leading/trailing spaces/tabs from each line, NOT newlines
          cleanedCode = cleanedCode
            .replace(/^[ \t]+|[ \t]+$/gm, '') // Remove leading/trailing spaces/tabs only (preserve \n)
            .replace(/\n{6,}/g, '\n\n\n\n\n'); // Only replace 6+ consecutive newlines
          
          // Only add if there's actual code content (not just whitespace)
          if (cleanedCode.trim().length > 0) {
          codeBlocks.push(cleanedCode);
          }
        }
        
        console.log(' Extracted code blocks count:', codeBlocks.length);
        return codeBlocks;
      }
      
      // Get the original formatted code from the message
      function getOriginalFormattedCode(message) {
        
        // Decode HTML entities first - messages from streaming may be HTML-encoded
        // Create a temporary div to decode HTML entities
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = message;
        let decodedMessage = tempDiv.textContent || tempDiv.innerText || message;
        
        // If decoding didn't work or message wasn't HTML, use original
        if (!decodedMessage || decodedMessage === message) {
          // Try manual decoding of common entities
          decodedMessage = message
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/&nbsp;/g, ' ');
        }
        
        // Find ONLY R code blocks and extract them with original formatting
        // Matches: ```r, ```R, ```{r}, ```{R} - NOT plain ``` or other languages
        // ONLY matches COMPLETE blocks with both opening and closing ```
        const codeBlockRegex = /```(?:\{[rR]\}|[rR])(?:\n|\s+)([\s\S]*?)```/g;
        const allMatches = [...decodedMessage.matchAll(codeBlockRegex)];
        
        if (allMatches.length > 0) {
          console.log(` Found ${allMatches.length} code block(s)`);
          
          const allCodeBlocks = allMatches.map((codeBlockMatch, index) => {
          let originalCode = codeBlockMatch[1];
            console.log(` Processing code block ${index + 1}, length:`, originalCode.length);
            
            // Remove any language identifier that might be at the start (like {r}, r, etc.)
            originalCode = originalCode
              .replace(/^\{[rR]\}\s*\n?/, '') // Remove {r} or {R} at start
              .replace(/^\s*\{[rR]\}\s*\n?/, '') // Remove {r} or {R} with whitespace
              .replace(/^[rR]\s+/, '') // Remove r or R followed by whitespace (not part of function name)
              .replace(/^\s*[rR]\s+/, ''); // Remove r or R with surrounding whitespace
          
          // Decode HTML entities back to actual characters
          originalCode = originalCode
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
          
          // Ensure proper line breaks are preserved
          // Replace any HTML line break entities with actual newlines
          originalCode = originalCode
            .replace(/<br\s*\/?>/gi, '\n')
            .replace(/<\/p>/gi, '\n')
            .replace(/<p[^>]*>/gi, '');
          
          // AGGRESSIVELY preserve line breaks - this is critical for R syntax
            // Only remove leading/trailing spaces/tabs from each line, NOT newlines
          originalCode = originalCode
              .replace(/^[ \t]+|[ \t]+$/gm, '') // Remove leading/trailing spaces/tabs only (preserve \n)
            .replace(/\n{6,}/g, '\n\n\n\n\n'); // Only replace 6+ consecutive newlines
          
          // FINAL CHECK: Ensure we have proper line breaks between statements
          // Look for patterns like "}variable" or ")variable" and add line breaks
          originalCode = originalCode
            .replace(/([})\]])([a-zA-Z_])/g, '$1\n$2') // Add line break after } ) ] before variable
            .replace(/([a-zA-Z_])#/g, '$1\n#') // Add line break before comments
            .replace(/([a-zA-Z_])library/g, '$1\nlibrary'); // Add line break before library calls
          
            console.log(` Code block ${index + 1} processed, length:`, originalCode.length);
          return originalCode;
          });
          
          // Combine all code blocks with proper separation
          const combinedCode = allCodeBlocks.join('\n\n');
          console.log(' Combined all code blocks, total length:', combinedCode.length);
          console.log(' Sample of combined code:', combinedCode.substring(0, 300));
          
          return combinedCode;
        } else {
          console.log(' No code block found, returning empty string');
          return '';
        }
      }
      

      
      // Execute cleaning code with automatic error handling and iteration
      function executeCleaningCodeWithErrorHandling(code, originalMessage) {
        console.log(' Executing code with error handling');
        
        // Store the code that's being executed for error handling
        currentStepCode = code;
        
        // Set flag to prevent duplicate handling
        cleaningCodeExecuting = true;
        
        // Reset stop flag for new operation
        operationStopped = false;
        
        // Set AI responding flag
        isAIResponding = true;
        
        // Transform send button to stop button
        transformToStopButton();
        
        // Check if this is normal chat auto-execute (not an agent workflow)
        // If no active agent workflow, clear the agent type flags for normal chat
        if (!currentAgentWorkflow) {
          window.currentActiveAgentType = null;
          window.completedAgentType = null;
        }
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          // Send the code for execution
          ws.send(JSON.stringify({
            action: 'execute_code',
            code: code
          }));
          
          // Don't set timeout - wait for actual WebSocket response
          console.log(' Code sent for execution, waiting for response...');
        }
      }
      

      
      // Handle cleaning code errors and ask Claude to fix them
      function handleCleaningCodeError(error, code) {
        console.log(' Handling cleaning code error:', error);
        
        // Increment iteration counter
        cleaningCodeIterationCount++;
        console.log(` Cleaning code iteration: ${cleaningCodeIterationCount}/${MAX_CLEANING_ITERATIONS}`);
        
        // Check if we've exceeded the maximum iterations
        if (cleaningCodeIterationCount >= MAX_CLEANING_ITERATIONS) {
          addMessage(` **Maximum Iterations Reached**\n\nThe code has failed ${MAX_CLEANING_ITERATIONS} times. Stopping automatic iteration to prevent infinite loops.\n\n**Last Error:**\n\`${error}\`\n\n**Recommendation:**\nPlease manually review and fix the code, or try a different approach.`, 'ai');
          
          // Reset counter for future attempts
          cleaningCodeIterationCount = 0;
          
          // Don't reset button yet - wait for AI response streaming to complete
          // The button will be reset in finishStreaming() when streaming is done
          return;
        }
        
        addMessage(` **Code Execution Failed (Attempt ${cleaningCodeIterationCount}/${MAX_CLEANING_ITERATIONS})**\n\nThe code encountered an error:\n\n\`${error}\`\n\nAsking Claude to fix this...`, 'ai');
        
        // Ask Claude to fix the code
        const fixRequest = `The R code I provided earlier failed to execute with this error:

\`${error}\`

**Original Code That Failed:**
\`\`\`r
${code || "Code not available"}
\`\`\`

Please fix the code and provide a corrected version that will work. The code should:

1. Handle the specific error that occurred: \`${error}\`
2. Be more robust and defensive
3. Still accomplish the original cleaning goals
4. Be production-ready and executable

**Important:** Please analyze the original code and the specific error to provide a targeted fix, not a generic solution.`;
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'chat_with_ai',
            message: fixRequest,
            conversation_context: 'data_cleaning_agent_code_fix'
          }));
        }
      }
      
      // FIXED: Removed unused originalOnMessage and originalOnOpen functions
      // The main WebSocket handlers above handle all functionality
      
      // ========== VISUALIZATION AGENT FUNCTIONS ==========
      
      
      // Show agent selection view
      function showAgentSelection() {
        document.getElementById('agent-selection').style.display = 'block';
        document.getElementById('back-to-agents-btn').style.display = 'none';
        document.getElementById('agents-main-header').textContent = ' AI Agents';
        document.getElementById('agent-selection-prompt').textContent = 'Select an agent to get started';
        
        // Hide all agent configs
        const configs = ['cleaning-config', 'transformation-config', 'statistical-config', 'modeling-config', 'visualization-config'];
        configs.forEach(id => {
          const config = document.getElementById(id);
          if (config) config.style.display = 'none';
        });
      }
      
      // Load available DataFrames for visualization config
      function loadVisualizationDataFrames() {
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'get_dataframes'
          }));
        }
      }
      
      // Populate DataFrame dropdown for visualization config
      function populateVizDataFrameSelect(dataframes) {
        console.log(' populateVizDataFrameSelect called with:', dataframes);
        const select = document.getElementById('viz-dataframe-select');
        const startBtn = document.getElementById('start-viz-btn');
        
        if (!select) {
          console.error('viz-dataframe-select element not found!');
          return;
        }
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">-- Choose a DataFrame --</option>';
        
        if (Array.isArray(dataframes)) {
          dataframes.forEach(df => {
            console.log(' Adding viz dataframe option:', df);
            const option = document.createElement('option');
            option.value = df;
            option.textContent = df;
            select.appendChild(option);
          });
        }
        
        // Enable start button when DataFrame is selected
        select.onchange = function() {
          if (this.value) {
            updateVizDataFrameInfo();
            setTimeout(() => updateVizStartButton(), 100);
          } else {
            const checklist = document.getElementById('viz-checklist');
            if (checklist) {
              checklist.style.display = 'none';
            }
            if (startBtn) {
              startBtn.disabled = true;
              startBtn.textContent = 'Select a DataFrame first';
              startBtn.title = 'Please select a DataFrame to continue';
            }
          }
        };
      }
      
      // Update DataFrame info when selection changes for visualization
      function updateVizDataFrameInfo() {
        const select = document.getElementById('viz-dataframe-select');
        const selectedDF = select.value;
        const infoDiv = document.getElementById('viz-dataframe-info');
        const checklist = document.getElementById('viz-checklist');
        const variablesSection = document.getElementById('viz-variables-section');
        const optionsSection = document.getElementById('viz-options-section');
        
        if (selectedDF) {
          // Set current visualization dataframe for context
          window.currentVisualizationDataframe = selectedDF;
          
          // Request DataFrame info from R
          if (ws && isConnected) {
            ws.send(JSON.stringify({
              action: 'get_dataframe_info',
              dataframe: selectedDF
            }));
          }
          
          // Show checklist and other sections
          if (checklist) checklist.style.display = 'block';
          if (variablesSection) variablesSection.style.display = 'block';
          if (optionsSection) optionsSection.style.display = 'block';
        } else {
          if (infoDiv) infoDiv.style.display = 'none';
          if (checklist) checklist.style.display = 'none';
          if (variablesSection) variablesSection.style.display = 'none';
          if (optionsSection) optionsSection.style.display = 'none';
        }
      }
      
      // Handle visualization DataFrame info response
      function handleVisualizationDataframeInfo(dataframeInfo) {
        try {
          if (!dataframeInfo || !window.currentVisualizationDataframe) return;
          
          console.log(' Processing dataframe info for visualization agent:', dataframeInfo);
          
          const infoDiv = document.getElementById('viz-dataframe-info');
          if (!infoDiv) return;
          
          // Check if we have proper column info to update the variables
          const hasColumns = dataframeInfo.columns || dataframeInfo.column_info;
          if (!hasColumns) {
            console.log(' No column info in dataframe response for visualization agent, keeping loading state');
            return; // Keep the loading state - real column info will come later
          }
          
          // Get columns from either structure
          const columns = dataframeInfo.columns || dataframeInfo.column_info || {};
          
          // Extract variable names and types
          const variables = Object.keys(columns);
          const variableTypes = {};
          
          // Process column information to get types
          variables.forEach(varName => {
            const colInfo = columns[varName];
            if (typeof colInfo === 'object' && colInfo !== null) {
              // If it's an object with type information
              variableTypes[varName] = colInfo.type || colInfo.class || 'unknown';
            } else {
              // If it's just a string or simple value
              variableTypes[varName] = typeof colInfo;
            }
          });
          
          // Store variable types globally for smart filtering
          window.currentVisualizationVariables = variables;
          window.currentVisualizationVariableTypes = variableTypes;
          
          infoDiv.style.display = 'none';
          
          // Store dataframe name for later use
          window.currentVisualizationDataframe = dataframeInfo.name;
          
          // Populate variable dropdowns
          populateVizVariableDropdowns(variables);
          
          // Update start button
          updateVizStartButton();
          
        } catch (error) {
          console.error(' Error handling visualization dataframe info:', error);
          const infoDiv = document.getElementById('viz-dataframe-info');
          if (infoDiv) {
            infoDiv.innerHTML = `<div class="error">Error loading DataFrame info: ${error.message}</div>`;
            infoDiv.style.display = 'block';
          }
        }
      }
      
      // Populate visualization variable dropdowns
      function populateVizVariableDropdowns(variables) {
        // Populate all existing plot variable dropdowns
        const categories = ['distributions', 'comparisons', 'relationships', 'categorical', 'time-series', 'statistical'];
        
        categories.forEach(category => {
          const configsDiv = document.getElementById(`viz-${category}-plot-configs`);
          if (configsDiv) {
            const selects = configsDiv.querySelectorAll('select');
            selects.forEach(select => {
              if (select.id.includes('-var')) {
                // Clear existing options except the first one
                select.innerHTML = select.querySelector('option').outerHTML;
                
                variables.forEach(varName => {
                  const option = document.createElement('option');
                  option.value = varName;
                  option.textContent = varName;
                  select.appendChild(option);
                });
              }
            });
          }
        });
      }
      
      // Update visualization start button state
      function updateVizStartButton() {
        const startBtn = document.getElementById('start-viz-btn');
        const select = document.getElementById('viz-dataframe-select');
        const selectedDF = select ? select.value : '';
        
        // Check if at least one plot is configured
        const configuredPlots = getConfiguredPlots();
        
        console.log(' updateVizStartButton - selectedDF:', selectedDF);
        console.log(' updateVizStartButton - configuredPlots:', configuredPlots);
        console.log(' updateVizStartButton - configuredPlots.length:', configuredPlots.length);
        
        if (startBtn) {
          if (!selectedDF) {
            startBtn.disabled = true;
            startBtn.textContent = 'Select a DataFrame first';
            startBtn.title = 'Please select a DataFrame to continue';
          } else if (configuredPlots.length === 0) {
            startBtn.disabled = true;
            startBtn.textContent = 'Configure at least one plot';
            startBtn.title = 'Please configure at least one plot';
          } else {
            startBtn.disabled = false;
            startBtn.textContent = ` Start Visualization Agent (${configuredPlots.length} plots)`;
            startBtn.title = `Ready to generate ${configuredPlots.length} plots`;
          }
        }
      }
      
      // Get all configured plots
      function getConfiguredPlots() {
        const configuredPlots = [];
        
        // Check each category
        const categories = ['distributions', 'comparisons', 'relationships', 'categorical', 'time-series', 'statistical'];
        
        console.log(' getConfiguredPlots - checking categories:', categories);
        
        categories.forEach(category => {
          const checkbox = document.getElementById(`viz-check-${category}`);
          console.log(` getConfiguredPlots - checking category ${category}:`, checkbox ? checkbox.checked : 'checkbox not found');
          if (checkbox && checkbox.checked) {
            // Map category names to HTML IDs
            const categoryMap = {
              'distributions': 'dist',
              'comparisons': 'comp',
              'relationships': 'rel',
              'categorical': 'cat',
              'time-series': 'ts',
              'statistical': 'stat',
              'automatic': 'auto'
            };
            
            const shortCategory = categoryMap[category] || category;
            
            // Get individual plot configurations directly
            const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
            if (configsDiv) {
              const plotConfigs = configsDiv.querySelectorAll('.plot-config-section');
              plotConfigs.forEach(plotConfig => {
                const plotId = plotConfig.id.replace('-config', '');
                const config = getIndividualPlotConfiguration(plotId);
                if (config && isPlotConfigurationComplete(config)) { // Only add if plot is complete
                  configuredPlots.push({
                    category: category,
                    plotId: plotId,
                    ...config
                  });
                }
              });
            }
          }
        });
        
        return configuredPlots;
      }
      
      // Get configuration for an individual plot
      function getIndividualPlotConfiguration(plotId) {
        const plotType = document.getElementById(`${plotId}-plot-type`)?.value || '';
        const xVar = document.getElementById(`${plotId}-x-var`)?.value || '';
        const yVar = document.getElementById(`${plotId}-y-var`)?.value || '';
        const colorVar = document.getElementById(`${plotId}-color-var`)?.value || '';
        const title = document.getElementById(`${plotId}-title`)?.value || '';
        const bins = document.getElementById(`${plotId}-bins`)?.value || '30';
        
        return {
          plotType: plotType,
          xVar: xVar,
          yVar: yVar,
          colorVar: colorVar,
          title: title,
          bins: parseInt(bins)
        };
      }
      
      // Check if a plot configuration is complete (has all mandatory variables)
      function isPlotConfigurationComplete(config) {
        if (!config.plotType) return false;
        
        // Define mandatory variables for each plot type
        const mandatoryVars = {
          'histogram': ['xVar'],
          'density': ['xVar'],
          'boxplot': ['xVar'],
          'violin': ['xVar'],
          'scatter': ['xVar', 'yVar'],
          'line': ['xVar', 'yVar'],
          'bar': ['xVar'],
          'pie': ['xVar'],
          'heatmap': ['xVar', 'yVar'],
          'correlation': ['xVar'],
          'timeseries': ['xVar', 'yVar'],
          'qqplot': ['xVar'],
          'residual': ['xVar', 'yVar']
        };
        
        const requiredVars = mandatoryVars[config.plotType] || ['xVar'];
        
        // Check if all required variables are filled
        return requiredVars.every(varName => config[varName] && config[varName].trim() !== '');
      }
      
      // Setup visualization agent checkbox interactions
      function setupVisualizationCheckboxInteractions() {
        console.log(' Setting up visualization agent checkbox interactions...');
        
        // Setup category toggles
        const categories = ['distributions', 'comparisons', 'relationships', 'categorical', 'time-series', 'statistical', 'automatic'];
        categories.forEach(category => {
          const checkbox = document.getElementById(`viz-check-${category}`);
          if (checkbox) {
            checkbox.addEventListener('change', () => updateVizStartButton());
          }
        });
      }
      
      // Toggle visualization category options
      function toggleVizCategory(category) {
        const checkbox = document.getElementById(`viz-check-${category}`);
        const optionsDiv = document.getElementById(`viz-${category}-options`);
        
        if (checkbox.checked) {
          optionsDiv.style.display = 'block';
          
          // Automatically create the first plot when category is checked
          // Map category names to HTML IDs (same as in createVizPlotConfig)
          const categoryMap = {
            'distributions': 'dist',
            'comparisons': 'comp',
            'relationships': 'rel',
            'categorical': 'cat',
            'time-series': 'ts',
            'statistical': 'stat',
            'automatic': 'auto'
          };
          const shortCategory = categoryMap[category] || category;
          const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
          console.log(' Auto-creating plot for category:', category);
          console.log(' Short category:', shortCategory);
          console.log(' Looking for ID:', `viz-${shortCategory}-plot-configs`);
          console.log(' ConfigsDiv found:', !!configsDiv);
          console.log(' ConfigsDiv children length:', configsDiv ? configsDiv.children.length : 'N/A');
          
          if (configsDiv && configsDiv.children.length === 0) {
            // Get the default plot type for this category
            const defaultPlotType = getDefaultPlotTypeForCategory(category);
            console.log(' Default plot type:', defaultPlotType);
            
            // Create the first plot configuration
            const plotConfig = createVizPlotConfig(category, defaultPlotType, 1);
            console.log(' Generated plot config HTML length:', plotConfig.length);
            
            configsDiv.insertAdjacentHTML('beforeend', plotConfig);
            console.log(' Plot config inserted, new children length:', configsDiv.children.length);
            
            // Populate variables if available
            if (window.currentVisualizationVariables) {
              populateVizPlotVariables(category);
            }
          } else {
            console.log(' Skipping auto-creation - configsDiv not found or already has children');
          }
        } else {
          optionsDiv.style.display = 'none';
          // Clear plot configs when category is unchecked
          const categoryMap = {
            'distributions': 'dist',
            'comparisons': 'comp',
            'relationships': 'rel',
            'categorical': 'cat',
            'time-series': 'ts',
            'statistical': 'stat',
            'automatic': 'auto'
          };
          const shortCategory = categoryMap[category] || category;
          const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
          if (configsDiv) {
            configsDiv.innerHTML = '';
            configsDiv.style.display = 'none';
          }
        }
        
        updateVizStartButton();
      }
      
      // Toggle plot type and show individual plot configurations
      function toggleVizPlotType(category) {
        console.log(' toggleVizPlotType called for category:', category);
        
        // Map category names to HTML IDs
        const categoryMap = {
          'distributions': 'dist',
          'comparisons': 'comp',
          'relationships': 'rel',
          'categorical': 'cat',
          'time-series': 'ts',
          'automatic': 'auto'
        };
        
        const shortCategory = categoryMap[category] || category;
        const plotTypeSelect = document.getElementById(`viz-${shortCategory}-plot-type`);
        const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
        
        console.log(' Looking for elements:');
        console.log(' plotTypeSelect ID:', `viz-${shortCategory}-plot-type`);
        console.log(' plotTypeSelect element:', plotTypeSelect);
        console.log(' configsDiv ID:', `viz-${shortCategory}-plot-configs`);
        console.log(' configsDiv element:', configsDiv);
        
        if (!plotTypeSelect || !configsDiv) {
          console.log(' Missing elements, returning');
          return;
        }
        
        const plotType = plotTypeSelect.value;
        
        if (plotType && plotType !== 'auto') {
          // Clear existing configs
          configsDiv.innerHTML = '';
          
          // Create a single plot with the selected type
          const plotTypes = [plotType];
          
          // Create individual plot configurations
          plotTypes.forEach((type, index) => {
            const plotNum = index + 1;
            const plotConfig = createVizPlotConfig(category, type, plotNum);
            configsDiv.insertAdjacentHTML('beforeend', plotConfig);
          });
          
          configsDiv.style.display = 'block';
          
          // Show the "Add Plot" button
          const addPlotSection = document.querySelector(`#viz-${shortCategory}-plot-configs`).nextElementSibling;
          if (addPlotSection && addPlotSection.classList.contains('add-plot-section')) {
            addPlotSection.style.display = 'block';
          }
          
          // Populate variables if available
          if (window.currentVisualizationVariables) {
            populateVizPlotVariables(category);
          }
        } else {
          configsDiv.innerHTML = '';
          configsDiv.style.display = 'none';
          
          // Hide the "Add Plot" button
          const addPlotSection = document.querySelector(`#viz-${shortCategory}-plot-configs`).nextElementSibling;
          if (addPlotSection && addPlotSection.classList.contains('add-plot-section')) {
            addPlotSection.style.display = 'none';
          }
        }
        
        updateVizStartButton();
      }
      
      // Add a new plot configuration to a category
      function addVizPlot(category) {
        // Map category names to HTML IDs
        const categoryMap = {
          'distributions': 'dist',
          'comparisons': 'comp',
          'relationships': 'rel',
          'categorical': 'cat',
          'time-series': 'ts',
          'statistical': 'stat',
          'automatic': 'auto'
        };
        
        const shortCategory = categoryMap[category] || category;
        const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
        
        if (!configsDiv) return;
        
        // Count existing plots to get the next number
        const existingPlots = configsDiv.querySelectorAll('.plot-config-section');
        const plotNum = existingPlots.length + 1;
        
        // Create the new plot configuration with default plot type
        const defaultPlotType = getDefaultPlotTypeForCategory(category);
        const plotConfig = createVizPlotConfig(category, defaultPlotType, plotNum);
        configsDiv.insertAdjacentHTML('beforeend', plotConfig);
        
        // Populate variables if available
        if (window.currentVisualizationVariables) {
          populateVizPlotVariables(category);
        }
        
        updateVizStartButton();
      }
      
      // Get default plot type for each category
      function getDefaultPlotTypeForCategory(category) {
        const defaults = {
          'distributions': 'histogram',
          'comparisons': 'boxplot',
          'relationships': 'scatter',
          'categorical': 'bar',
          'time-series': 'line',
          'statistical': 'qqplot'
        };
        return defaults[category] || 'histogram';
      }
      
      // Update individual plot type and refresh the plot configuration
      function updateIndividualPlotType(plotId, category) {
        const plotTypeSelect = document.getElementById(`${plotId}-plot-type`);
        if (!plotTypeSelect) return;
        
        const newPlotType = plotTypeSelect.value;
        if (!newPlotType) return;
        
        // Extract plot number from plotId (e.g., "dist-histogram-2" -> 2)
        const plotNum = plotId.split('-').pop();
        
        // Find the plot config container
        const plotConfigDiv = document.getElementById(`${plotId}-config`);
        if (!plotConfigDiv) return;
        
        // Create new plot configuration with the updated type
        const newPlotConfig = createVizPlotConfig(category, newPlotType, plotNum);
        
        // Replace the existing plot configuration
        plotConfigDiv.outerHTML = newPlotConfig;
        
        // Repopulate variables if available
        if (window.currentVisualizationVariables) {
          populateVizPlotVariables(category);
        }
        
        updateVizStartButton();
      }
      
      // Create individual plot configuration HTML
      function createVizPlotConfig(category, plotType, plotNum) {
        // Map category names to HTML IDs
        const categoryMap = {
          'distributions': 'dist',
          'comparisons': 'comp',
          'relationships': 'rel',
          'categorical': 'cat',
          'time-series': 'ts',
          'automatic': 'auto'
        };
        
        const shortCategory = categoryMap[category] || category;
        const plotId = `${shortCategory}-${plotType}-${plotNum}`;
        const plotName = getPlotDisplayName(plotType);
        
        let configHtml = `
          <div class="plot-config-section" id="${plotId}-config">
            <div class="plot-config-header">
              <h5> ${plotName} ${plotNum}</h5>
              <button type="button" class="remove-plot-btn" onclick="removeVizPlot('${plotId}')" title="Remove this plot"></button>
            </div>
            <div class="plot-config-details">
              <div class="form-group">
                <label for="${plotId}-plot-type">Plot Type</label>
                <select id="${plotId}-plot-type" onchange="updateIndividualPlotType('${plotId}', '${category}')">
                  <option value="">-- Select Plot Type --</option>
        `;
        
        // Add plot type options based on category
        if (category === 'distributions') {
          configHtml += `
                  <option value="histogram" ${plotType === 'histogram' ? 'selected' : ''}>Histogram</option>
                  <option value="density" ${plotType === 'density' ? 'selected' : ''}>Density Plot</option>
          `;
        } else if (category === 'comparisons') {
          configHtml += `
                  <option value="boxplot" ${plotType === 'boxplot' ? 'selected' : ''}>Box Plot</option>
                  <option value="violin" ${plotType === 'violin' ? 'selected' : ''}>Violin Plot</option>
          `;
        } else if (category === 'relationships') {
          configHtml += `
                  <option value="scatter" ${plotType === 'scatter' ? 'selected' : ''}>Scatter Plot</option>
                  <option value="line" ${plotType === 'line' ? 'selected' : ''}>Line Plot</option>
                  <option value="correlation" ${plotType === 'correlation' ? 'selected' : ''}>Correlation Plot</option>
          `;
        } else if (category === 'categorical') {
          configHtml += `
                  <option value="bar" ${plotType === 'bar' ? 'selected' : ''}>Bar Chart</option>
                  <option value="pie" ${plotType === 'pie' ? 'selected' : ''}>Pie Chart</option>
          `;
        } else if (category === 'time-series') {
          configHtml += `
                  <option value="line" ${plotType === 'line' ? 'selected' : ''}>Line Plot</option>
                  <option value="trend" ${plotType === 'trend' ? 'selected' : ''}>Trend Analysis</option>
          `;
        } else if (category === 'statistical') {
          configHtml += `
                  <option value="qqplot" ${plotType === 'qqplot' ? 'selected' : ''}>Q-Q Plot</option>
                  <option value="residual" ${plotType === 'residual' ? 'selected' : ''}>Residual Plot</option>
          `;
        } else {
          // For any other category, show all options
          configHtml += `
                  <option value="histogram" ${plotType === 'histogram' ? 'selected' : ''}>Histogram</option>
                  <option value="density" ${plotType === 'density' ? 'selected' : ''}>Density Plot</option>
                  <option value="boxplot" ${plotType === 'boxplot' ? 'selected' : ''}>Box Plot</option>
                  <option value="violin" ${plotType === 'violin' ? 'selected' : ''}>Violin Plot</option>
                  <option value="scatter" ${plotType === 'scatter' ? 'selected' : ''}>Scatter Plot</option>
                  <option value="line" ${plotType === 'line' ? 'selected' : ''}>Line Plot</option>
                  <option value="bar" ${plotType === 'bar' ? 'selected' : ''}>Bar Chart</option>
                  <option value="pie" ${plotType === 'pie' ? 'selected' : ''}>Pie Chart</option>
          `;
        }
        
        configHtml += `
                </select>
              </div>
        `;
        
        // Add variable selections based on plot type
        if (plotType === 'histogram' || plotType === 'density') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-bins">Bins (for histogram)</label>
                <input type="number" id="${plotId}-bins" value="30" min="5" max="100">
              </div>
            </div>
          `;
        } else if (plotType === 'boxplot' || plotType === 'violin') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Grouping Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Grouping Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Value Variable</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Value Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'scatter' || plotType === 'line') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">X Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select X Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Y Variable</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Y Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-color-var">Color Variable (Optional)</label>
                <select id="${plotId}-color-var">
                  <option value="">-- Select Color Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'bar' || plotType === 'pie') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Categorical Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Categorical Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Count Variable (Optional)</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Count Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'trend') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Time Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Time Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Value Variable</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Value Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'qqplot') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'residual') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">X Variable</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select X Variable --</option>
                </select>
              </div>
              <div class="form-group">
                <label for="${plotId}-y-var">Y Variable</label>
                <select id="${plotId}-y-var">
                  <option value="">-- Select Y Variable --</option>
                </select>
              </div>
            </div>
          `;
        } else if (plotType === 'correlation') {
          configHtml += `
            <div class="form-row">
              <div class="form-group">
                <label for="${plotId}-x-var">Variable (for correlation matrix)</label>
                <select id="${plotId}-x-var">
                  <option value="">-- Select Variable --</option>
                </select>
              </div>
            </div>
          `;
        }
        
        // Add title field for all plots
        configHtml += `
            <div class="form-group">
              <label for="${plotId}-title">Plot Title (Optional)</label>
              <input type="text" id="${plotId}-title" placeholder="Enter custom title">
            </div>
          </div>
        </div>
        `;
        
        return configHtml;
      }
      
      // Get display name for plot type
      function getPlotDisplayName(plotType) {
        const names = {
          'histogram': 'Histogram',
          'density': 'Density Plot',
          'boxplot': 'Box Plot',
          'violin': 'Violin Plot',
          'scatter': 'Scatter Plot',
          'line': 'Line Plot',
          'bar': 'Bar Chart',
          'pie': 'Pie Chart',
          'trend': 'Trend Analysis',
          'correlation': 'Correlation Plot',
          'qqplot': 'Q-Q Plot',
          'residual': 'Residual Plot'
        };
        return names[plotType] || plotType;
      }
      
      // Remove a specific plot configuration
      function removeVizPlot(plotId) {
        const plotElement = document.getElementById(`${plotId}-config`);
        if (plotElement) {
          plotElement.remove();
        }
        updateVizStartButton();
      }
      
      // Populate variables for all plots in a category with smart filtering
      function populateVizPlotVariables(category) {
        if (!window.currentVisualizationVariables || !window.currentVisualizationVariableTypes) return;
        
        // Map category names to HTML IDs
        const categoryMap = {
          'distributions': 'dist',
          'comparisons': 'comp',
          'relationships': 'rel',
          'categorical': 'cat',
          'time-series': 'ts',
          'statistical': 'stat',
          'automatic': 'auto'
        };
        
        const shortCategory = categoryMap[category] || category;
        const configsDiv = document.getElementById(`viz-${shortCategory}-plot-configs`);
        if (!configsDiv) return;
        
        const selects = configsDiv.querySelectorAll('select');
        selects.forEach(select => {
          if (select.id.includes('-var')) {
            // Preserve current selection
            const currentValue = select.value;
            
            // Determine what type of variable this select expects
            const expectedType = getExpectedVariableType(select.id);
            
            // Clear existing options except the first one
            select.innerHTML = select.querySelector('option').outerHTML;
            
            // Filter variables based on expected type and add them with data types
            window.currentVisualizationVariables.forEach(varName => {
              const varType = window.currentVisualizationVariableTypes[varName];
              const isCompatible = isVariableCompatible(varType, expectedType);
              
              if (isCompatible) {
                const option = document.createElement('option');
                option.value = varName;
                option.textContent = `${varName} (${varType})`;
                select.appendChild(option);
              }
            });
            
            // Restore selection if it still exists
            if (currentValue && Array.from(select.options).some(opt => opt.value === currentValue)) {
              select.value = currentValue;
            }
            
            // Add change event listener to update start button
            select.addEventListener('change', () => updateVizStartButton());
          }
        });
      }
      
      // Get expected variable type based on select ID and plot type
      function getExpectedVariableType(selectId) {
        // Extract plot type from select ID (e.g., "dist-histogram-1-x-var" -> "histogram")
        const plotTypeMatch = selectId.match(/(histogram|density|boxplot|violin|scatter|line|bar|pie|correlation|qqplot|residual|trend)/);
        const plotType = plotTypeMatch ? plotTypeMatch[1] : '';
        
        // X variable logic
        if (selectId.includes('-x-var') && !selectId.includes('-y-var')) {
          // For boxplots and violin plots, X should be categorical (grouping variable)
          if (plotType === 'boxplot' || plotType === 'violin') {
            return 'categorical';
          }
          // For histograms, density plots, bar charts, pie charts, X can be any type
          if (plotType === 'histogram' || plotType === 'density' || plotType === 'bar' || plotType === 'pie') {
            return 'any';
          }
          // For scatter plots, line plots, residual plots, X should be numeric
          if (plotType === 'scatter' || plotType === 'line' || plotType === 'residual') {
            return 'numeric';
          }
          // For correlation plots and Q-Q plots, X should be numeric
          if (plotType === 'correlation' || plotType === 'qqplot') {
            return 'numeric';
          }
        }
        
        // Y variable logic
        if (selectId.includes('-y-var')) {
          // Y variables should generally be numeric
          return 'numeric';
        }
        
        return 'any'; // Default to any type
      }
      
      // Check if variable type is compatible with expected type
      function isVariableCompatible(varType, expectedType) {
        if (expectedType === 'any') return true;
        
        // Normalize variable types
        const normalizedType = varType.toLowerCase();
        
        if (expectedType === 'numeric') {
          return normalizedType.includes('numeric') || 
                 normalizedType.includes('integer') || 
                 normalizedType.includes('double') ||
                 normalizedType.includes('number');
        }
        
        if (expectedType === 'categorical') {
          return normalizedType.includes('character') || 
                 normalizedType.includes('factor') || 
                 normalizedType.includes('string') ||
                 normalizedType.includes('categorical');
        }
        
        return true; // Default to compatible
      }
      
      
      // Start visualization agent
      function startVisualizationAgent() {
        console.log(' Starting visualization agent...');
        
        const dataframe = document.getElementById('viz-dataframe-select').value;
        if (!dataframe) {
          alert('Please select a DataFrame first');
          return;
        }
        
        // Get configured plots
        const configuredPlots = getConfiguredPlots();
        if (configuredPlots.length === 0) {
          alert('Please configure at least one plot');
          return;
        }
        
        // Collect global options
        const options = {
          auto_analyze: true, // Always analyze plots
          plots: configuredPlots
        };
        
        // Switch to chat tab to show agent progress
        switchTab('chat');
        
        // Hide visualization config
        const vizConfig = document.getElementById('visualization-config');
        if (vizConfig) {
          vizConfig.style.display = 'none';
        }
        
        // Send visualization agent start request
        if (ws && isConnected) {
          ws.send(JSON.stringify({
            action: 'start_visualization_agent',
            dataframe: dataframe,
            options: options
          }));
          
          // Transform send button to stop button when agent starts
          transformToAgentStopButton();
          
          console.log(' Visualization agent start request sent with', configuredPlots.length, 'plots');
        } else {
          alert('Not connected to R. Please check your connection.');
        }
      }
      
      // Handle visualization agent started
      function handleVisualizationAgentStarted(result) {
        console.log(' handleVisualizationAgentStarted called with:', result);
        
        if (result.success) {
          currentAgentWorkflow = {
            type: 'visualization',
            dataframe: result.dataframe,
            options: result.options,
            totalSteps: result.total_steps,
            workflowSteps: result.workflow_steps,
            currentStep: 1,
            stopped: false
          };
          
          const stepNum = currentAgentWorkflow.currentStep;
          const totalSteps = currentAgentWorkflow.totalSteps;
          const plotCount = result.options.plots ? result.options.plots.length : 0;
          
          addMessage(`** Visualization Agent Started**\n\n` +
            `**Step ${stepNum}/${totalSteps}:** Generating ${plotCount} configured plots\n` +
            `**Dataset:** ${result.dataframe}`, 'ai');
          
          console.log('Visualization agent started with workflow:', result);
          
          // Clear previous results
          agentResults = [];
          agentCodes = [];
          
          // Start the first visualization step
          requestNextVisualizationStep();
        } else {
          addMessage(` **Visualization Agent Error:** ${result.error || result.message}`, 'ai');
        }
      }
      
      // Handle visualization step result
      function handleVisualizationStepResult(stepResult) {
        console.log(' Processing visualization step result:', stepResult);
        
        if (stepResult.success) {
          // Store result for final summary
          agentResults.push({
            description: stepResult.plot_type,
            output: formatVisualizationResult(stepResult),
            step: stepResult.step
          });
          
          // Display the results
          displayVisualizationResults(stepResult);
          
          // Move to next step
          requestNextVisualizationStep();
        } else {
          addMessage(` **Visualization Error:** ${stepResult.error}`, 'ai');
          finishAgentWorkflow();
        }
      }
      
      // Display visualization results
      function displayVisualizationResults(stepResult) {
        console.log(' Displaying visualization results:', stepResult);
        
        let message = `** ${stepResult.plot_type.toUpperCase()} VISUALIZATION**\n\n`;
        
        if (stepResult.plot_data) {
          // Add plot description
          message += `Generated ${stepResult.plot_type} showing ${stepResult.description}\n\n`;
          
          // Add base64 image data
          message += `data:image/png;base64,${stepResult.plot_data}`;
          
          // Check if auto-analyze is enabled
          if (stepResult.auto_analyze) {
            message += `\n\n **Auto-analyzing plot...**`;
          }
        } else {
          message += `Plot generated successfully.\n`;
        }
        
        addVisualizationMessage(message, 'ai');
        
        // Auto-trigger plot analysis if enabled
        if (stepResult.auto_analyze && stepResult.plot_data) {
          setTimeout(() => {
            triggerPlotAnalysis();
          }, 1000);
        }
      }
      
      // Format visualization result for summary
      function formatVisualizationResult(stepResult) {
        if (stepResult.success) {
          return `Generated ${stepResult.plot_type} plot successfully.\nDescription: ${stepResult.description}`;
        } else {
          return `Error: ${stepResult.error}`;
        }
      }
      
      // Request next visualization step
      function requestNextVisualizationStep() {
        if (!currentAgentWorkflow || currentAgentWorkflow.type !== 'visualization') {
          console.log(' No active visualization workflow');
          return;
        }
        
        console.log(' Requesting next visualization step:', currentAgentWorkflow.currentStep);
        
        if (currentAgentWorkflow.currentStep > currentAgentWorkflow.totalSteps) {
          console.log(' Visualization workflow completed');
          finishVisualizationWorkflow();
          return;
        }
        
        // Execute current step, then increment for next time
        const stepToExecute = currentAgentWorkflow.currentStep;
        currentAgentWorkflow.currentStep++;
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'execute_visualization_step',
            step: stepToExecute,
            dataframe: currentAgentWorkflow.dataframe,
            variables: {}, // Legacy parameter
            options: currentAgentWorkflow.options
          }));
        }
      }
      
      // Finish visualization workflow
      function finishVisualizationWorkflow() {
        console.log(' Finishing visualization workflow');
        
        
        // Individual plot analyses already provided comprehensive insights
        // No need for additional comprehensive analysis
        
        // Reset workflow
        currentAgentWorkflow = null;
      }
      

      // Analyze current visualization plot specifically
      function analyzeCurrentVisualizationPlot() {
        console.log(' Analyzing current visualization plot...');
        
        if (!currentAgentWorkflow || currentAgentWorkflow.type !== 'visualization') {
          console.log(' No active visualization workflow for analysis');
          return;
        }
        
        // Get current step info
        const currentStep = currentAgentWorkflow.currentStep - 1; // Step that just completed (0-based)
        const arrayIndex = currentAgentWorkflow.currentStep - 2; // Convert 1-based step to 0-based array index
        
        
        const plotConfig = currentAgentWorkflow.workflowSteps[arrayIndex];
        
        if (!plotConfig) {
          addMessage(` **Debug Error:** No plot config found for current step ${currentStep}\n- Available workflow steps: ${JSON.stringify(currentAgentWorkflow.workflowSteps, null, 2)}`, 'ai');
          return;
        }
        
        
        // Extract plot information
        const plotType = plotConfig.plotType || plotConfig.plot_type || 'histogram';
        const actualConfig = plotConfig.plot_config || plotConfig;
        const xVar = plotConfig.xVar || actualConfig.xVar || '';
        const yVar = plotConfig.yVar || actualConfig.yVar || '';
        
        console.log(' Debug - plotConfig:', plotConfig);
        console.log(' Debug - actualConfig:', actualConfig);
        console.log(' Debug - extracted vars:', { plotType, xVar, yVar });
        
        
        // Create data variables object
        const dataVariables = {
          dataframe: currentAgentWorkflow.dataframe
        };
        if (xVar) dataVariables.x = xVar;
        if (yVar) dataVariables.y = yVar;
        
        // Create plot command (construct from plot configuration)
        let plotCommand = '';
        if (plotType === 'histogram') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar})) + geom_histogram(bins = 30)`;
        } else if (plotType === 'density') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar})) + geom_density()`;
        } else if (plotType === 'boxplot') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar}, y = ${yVar})) + geom_boxplot()`;
        } else if (plotType === 'scatter') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar}, y = ${yVar})) + geom_point()`;
        } else if (plotType === 'bar') {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar})) + geom_bar()`;
        } else {
          plotCommand = `ggplot(${currentAgentWorkflow.dataframe}, aes(x = ${xVar}${yVar ? `, y = ${yVar}` : ''})) + geom_${plotType}()`;
        }
        
        console.log(' Sending visualization plot analysis request:', {
          plotType,
          dataVariables,
          plotCommand
        });
        
        // Send analysis request
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'analyze_visualization_plot',
            plot_command: plotCommand,
            plot_type: plotType,
            data_variables: dataVariables
          }));
        }
      }
      
      // Trigger plot analysis (integrate with existing analyze last plot)
      function triggerPlotAnalysis() {
        console.log(' Triggering plot analysis...');
        
        addMessage(" **Analyzing Generated Plot...**", "ai");
        
        // Send plot analysis request
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'analyze_last_plot'
          }));
        }
      }
      
      
      // Add visualization agent to WebSocket message handler
      const originalOnMessage = ws?.onmessage;
      
      // Initialize visualization agent interactions
      document.addEventListener('DOMContentLoaded', function() {
        setupVisualizationCheckboxInteractions();
      });
      
      // ============================================
      // DATA EXPLORER FUNCTIONS
      // ============================================
      
      // Explorer state
      let explorerState = {
        currentDataframe: null,
        columnInfo: {},
        filters: [],
        sorts: [],
        pinnedCols: [],
        pinnedRows: [],
        page: 1,
        pageSize: 100,
        selectedCells: new Set(),
        columnWidths: {},
        summaryCollapsed: false,
        summaryLayout: 'left',
        filteredSummaryColumns: null,
        summarySortOrder: 'original'
      };
      
      // Load available dataframes for explorer
      function loadExplorerDataframes() {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: "get_objects"
          }));
        }
      }
      
      // Populate explorer object select with all objects (nested dropdown)
      function populateExplorerObjectSelect(objects, objectsInfo) {
        const dropdown = document.getElementById('explorer-dataframe-select-dropdown');
        const button = document.getElementById('explorer-dataframe-select-button');
        const buttonText = document.getElementById('explorer-dataframe-select-text');
        
        if (!dropdown || !button) return;
        
        // Detect theme and use solid background
        const isDark = document.body.classList.contains('dark-theme') || 
                       window.matchMedia('(prefers-color-scheme: dark)').matches;
        const dropdownBg = isDark ? '#2d2d2d' : '#ffffff';
        dropdown.style.backgroundColor = dropdownBg;
        dropdown.style.background = dropdownBg;
        
        dropdown.innerHTML = '';
        
        if (!objects || objects.length === 0) {
          buttonText.textContent = 'No objects available';
          return;
        }
        
        // Group objects by category
        const categories = {
          'dataframe': [],
          'list': [],
          'vector': [],
          'matrix': [],
          'function': [],
          'ts': [],
          'other': []
        };
        
        objects.forEach(objName => {
          const objInfo = objectsInfo && objectsInfo[objName] ? objectsInfo[objName] : null;
          const category = (objInfo && objInfo.category) ? objInfo.category : 'other';
          
          if (!categories[category]) {
            categories[category] = [];
          }
          
          categories[category].push({
            name: objName,
            info: objInfo
          });
        });
        
        // Create category groups
        const categoryLabels = {
          'dataframe': 'DataFrames',
          'list': 'Lists',
          'vector': 'Vectors',
          'matrix': 'Matrices',
          'function': 'Functions',
          'ts': 'Time Series',
          'other': 'Other Objects'
        };
        
        Object.keys(categories).forEach(category => {
          if (categories[category].length === 0) return;
          
          // Category header (clickable to expand/collapse)
          const categoryHeader = document.createElement('div');
          categoryHeader.className = 'dropdown-category-header';
          const headerBg = isDark ? '#3d3d3d' : '#f0f0f0';
          const headerText = isDark ? '#ffffff' : '#000000';
          categoryHeader.style.cssText = `padding: 8px 12px; font-weight: 600; cursor: pointer; background: ${headerBg} !important; background-color: ${headerBg} !important; color: ${headerText} !important; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; user-select: none; opacity: 1 !important; backdrop-filter: none !important; -webkit-backdrop-filter: none !important;`;
          categoryHeader.innerHTML = `
            <span>${categoryLabels[category] || category} (${categories[category].length})</span>
            <span class="category-arrow" style="transition: transform 0.2s; color: ${headerText};"></span>
          `;
          
          // Category items container (initially hidden)
          const categoryItems = document.createElement('div');
          categoryItems.className = 'dropdown-category-items';
          const itemBg = isDark ? '#2d2d2d' : '#ffffff';
          const hoverBg = isDark ? '#3d3d3d' : '#f0f0f0';
          const itemText = isDark ? '#ffffff' : '#000000';
          categoryItems.style.cssText = `display: none; background: ${itemBg} !important; background-color: ${itemBg} !important; opacity: 1 !important; backdrop-filter: none !important; -webkit-backdrop-filter: none !important;`;
          categoryItems.dataset.category = category;
          
          // Add items to category
          categories[category].forEach(obj => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            item.style.cssText = `padding: 8px 12px 8px 24px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background 0.2s; background: ${itemBg} !important; background-color: ${itemBg} !important; color: ${itemText} !important; opacity: 1 !important; backdrop-filter: none !important; -webkit-backdrop-filter: none !important;`;
            item.dataset.objName = obj.name;
            item.dataset.category = category;
            
            let displayText = obj.name;
            if (obj.info) {
              const type = obj.info.type || 'unknown';
            
            // Add category/type indicator
              if (category === 'dataframe' && obj.info.size_info) {
                displayText = `${obj.name} (${obj.info.size_info.nrow} x ${obj.info.size_info.ncol})`;
              } else if ((category === 'list' || category === 'vector') && obj.info.size_info) {
                const length = obj.info.size_info.length || '?';
                displayText = `${obj.name} [${length}]`;
              } else if (category === 'matrix' && obj.info.size_info) {
                displayText = `${obj.name} [${obj.info.size_info.nrow} x ${obj.info.size_info.ncol}]`;
            } else if (category === 'function') {
                displayText = `${obj.name} [function]`;
            } else if (category === 'ts' && obj.info.size_info) {
                const freq = obj.info.size_info.frequency || '?';
                displayText = `${obj.name} [ts, freq=${freq}]`;
            } else {
                displayText = `${obj.name} [${type}]`;
              }
            }
            
            item.textContent = displayText;
            
            // Click handler for item
            item.onclick = (e) => {
              e.stopPropagation();
              loadExplorerDataframeFromName(obj.name);
              dropdown.style.display = 'none';
              dropdown.style.visibility = 'hidden';
              dropdown.style.opacity = '0';
              dropdown.style.pointerEvents = 'none';
              buttonText.textContent = displayText;
            };
            
            item.onmouseenter = () => {
              item.style.background = hoverBg;
              item.style.backgroundColor = hoverBg;
            };
            item.onmouseleave = () => {
              item.style.background = itemBg;
              item.style.backgroundColor = itemBg;
            };
            
            categoryItems.appendChild(item);
          });
          
          // Click handler for category header (toggle expand/collapse)
          categoryHeader.onclick = (e) => {
            e.stopPropagation();
            const arrow = categoryHeader.querySelector('.category-arrow');
            const isExpanded = categoryItems.style.display !== 'none';
            
            if (isExpanded) {
              categoryItems.style.display = 'none';
              arrow.style.transform = 'rotate(0deg)';
            } else {
              categoryItems.style.display = 'block';
              arrow.style.transform = 'rotate(90deg)';
            }
          };
          
          dropdown.appendChild(categoryHeader);
          dropdown.appendChild(categoryItems);
        });
        
      };
      
      // Setup dropdown toggle (only once)
      if (!window.explorerDropdownInitialized) {
        window.explorerDropdownInitialized = true;
        
        // Toggle dropdown on button click
        document.addEventListener('click', function(e) {
          const button = document.getElementById('explorer-dataframe-select-button');
          const dropdown = document.getElementById('explorer-dataframe-select-dropdown');
          const explorerTab = document.getElementById('explorer-tab');
          const isExplorerActive = explorerTab && explorerTab.classList.contains('active') && explorerTab.style.display !== 'none';
          
          if (!button || !dropdown) {
            return;
          }
          
          // If explorer tab is not active, always hide the dropdown and do nothing
          if (!isExplorerActive) {
            console.log('  Explorer tab not active - hiding dropdown');
            dropdown.style.display = 'none';
            dropdown.style.visibility = 'hidden';
            dropdown.style.opacity = '0';
            dropdown.style.pointerEvents = 'none';
            return;
          }
          
          // Toggle if clicking the button
          if (button.contains(e.target)) {
            e.stopPropagation();
            const isVisible = dropdown.style.display === 'block' || dropdown.style.display === '';
            if (isVisible) {
              dropdown.style.display = 'none';
              dropdown.style.visibility = 'hidden';
              dropdown.style.opacity = '0';
              dropdown.style.pointerEvents = 'none';
            } else {
              dropdown.style.display = 'block';
              dropdown.style.visibility = 'visible';
              dropdown.style.opacity = '1';
              dropdown.style.pointerEvents = 'auto';
            }
          }
          // Close if clicking outside
          else if (!dropdown.contains(e.target) && !button.contains(e.target)) {
            dropdown.style.display = 'none';
            dropdown.style.visibility = 'hidden';
            dropdown.style.opacity = '0';
            dropdown.style.pointerEvents = 'none';
          }
        });
      }
      
      // Load dataframe by name (used by dropdown items)
      function loadExplorerDataframeFromName(objName) {
        if (!objName) return;
        
        // Find the category from the dropdown item
        const dropdown = document.getElementById('explorer-dataframe-select-dropdown');
        const item = dropdown ? dropdown.querySelector(`[data-obj-name="${objName}"]`) : null;
        const category = item ? item.dataset.category : null;
        
        console.log('Explorer: Loading object:', objName, 'category:', category);
        
        // Use the main loading function
        loadExplorerObjectMain(objName);
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: 'get_dataframe_explorer_data',
            dataframe: objName
          }));
        }
      };
      
      // Load a specific object in explorer (legacy function - now uses loadExplorerDataframeFromName)
      function loadExplorerDataframe() {
        // This function is kept for compatibility but the new dropdown uses loadExplorerDataframeFromName
        const buttonText = document.getElementById('explorer-dataframe-select-text');
        if (!buttonText || !buttonText.textContent || buttonText.textContent === 'Select an object...') {
          explorerState.currentDataframe = null;
          document.getElementById('explorer-df-dims').textContent = '';
          document.getElementById('explorer-status-text').textContent = '';
          document.getElementById('summary-columns-list').innerHTML = '';
          document.getElementById('grid-column-headers').innerHTML = '';
          document.getElementById('grid-row-headers').innerHTML = '';
          document.getElementById('grid-data-cells').innerHTML = '';
          return;
        }
        
        // Try to find the object name from the button text
        // This is a fallback - the new dropdown should use loadExplorerDataframeFromName directly
        return;
      }
      
      // Main function to load object (used by new dropdown)
      function loadExplorerObjectMain(objName) {
        if (!objName) {
          explorerState.currentDataframe = null;
          document.getElementById('explorer-df-dims').textContent = '';
          document.getElementById('explorer-status-text').textContent = '';
          document.getElementById('summary-columns-list').innerHTML = '';
          document.getElementById('grid-column-headers').innerHTML = '';
          document.getElementById('grid-row-headers').innerHTML = '';
          document.getElementById('grid-data-cells').innerHTML = '';
          
          // Hide all grid elements when no object is selected
          const summaryPanel = document.getElementById('explorer-summary-panel');
          const rowHeaderCorner = document.querySelector('.row-header-corner');
          const rowHeaders = document.getElementById('grid-row-headers');
          const columnHeaders = document.getElementById('grid-column-headers');
          const gridWrapper = document.querySelector('.explorer-grid-wrapper');
          const explorerActions = document.querySelector('.explorer-actions');
          const prevPageBtn = document.getElementById('prev-page-btn');
          const nextPageBtn = document.getElementById('next-page-btn');
          const summarySearch = document.getElementById('summary-search');
          
          if (summaryPanel) summaryPanel.style.display = 'none';
          if (rowHeaderCorner) rowHeaderCorner.style.display = 'none';
          if (rowHeaders) rowHeaders.style.display = 'none';
          if (columnHeaders) columnHeaders.style.display = 'none';
          if (gridWrapper) gridWrapper.style.display = 'none';
          if (explorerActions) explorerActions.style.display = 'none';
          if (prevPageBtn) prevPageBtn.style.display = 'none';
          if (nextPageBtn) nextPageBtn.style.display = 'none';
          if (summarySearch) summarySearch.style.display = 'none';
          
          return;
        }
        
        // Show grid elements when loading an object
        const gridWrapper = document.querySelector('.explorer-grid-wrapper');
        const explorerActions = document.querySelector('.explorer-actions');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const summarySearch = document.getElementById('summary-search');
        
        if (gridWrapper) gridWrapper.style.display = 'block';
        if (explorerActions) explorerActions.style.display = 'flex';
        if (prevPageBtn) prevPageBtn.style.display = 'flex';
        if (nextPageBtn) nextPageBtn.style.display = 'flex';
        if (summarySearch) summarySearch.style.display = 'block';
        
        explorerState.currentDataframe = objName;
        explorerState.page = 1;
        explorerState.filters = [];
        explorerState.sorts = [];
        explorerState.pinnedCols = [];
        explorerState.pinnedRows = [];
        explorerState.selectedCells.clear();
        
        // Enable pagination buttons
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        if (prevBtn) prevBtn.disabled = true; // Start at page 1, so previous is disabled
        if (nextBtn) nextBtn.disabled = false; // Will be updated after data loads
        
        // Clear previous content
        document.getElementById('explorer-df-dims').textContent = '';
        document.getElementById('explorer-status-text').textContent = '';
        document.getElementById('summary-columns-list').innerHTML = '';
        document.getElementById('grid-column-headers').innerHTML = '';
        document.getElementById('grid-row-headers').innerHTML = '';
        document.getElementById('grid-data-cells').innerHTML = '';
        
        // Get comprehensive explorer data
        if (ws && ws.readyState === WebSocket.OPEN) {
          console.log(' Explorer: Sending request for explorer data');
          ws.send(JSON.stringify({
            action: "get_dataframe_explorer_data",
            dataframe: objName
          }));
        } else {
          console.error(' Explorer: WebSocket not connected');
          document.getElementById('explorer-status-text').textContent = 'Error: Not connected';
        }
      }
      
      // Render object explorer for non-dataframe objects
      function renderObjectExplorer(objData) {
        // Helper function to escape HTML
        const escapeHTML = (str) => {
          if (!str) return '';
          const div = document.createElement('div');
          div.textContent = str;
          return div.innerHTML;
        };
        
        const summaryContainer = document.getElementById('summary-columns-list');
        const gridContainer = document.getElementById('grid-data-cells');
        const dimsText = document.getElementById('explorer-df-dims');
        const summaryPanel = document.getElementById('explorer-summary-panel');
        const rowHeaderCorner = document.querySelector('.row-header-corner');
        const rowHeaders = document.getElementById('grid-row-headers');
        const columnHeaders = document.getElementById('grid-column-headers');
        
        // Hide summary panel for non-dataframe/matrix objects
        if (summaryPanel) {
          summaryPanel.style.display = 'none';
        }
        
        // Hide row header corner and row headers for non-dataframe/matrix objects
        if (rowHeaderCorner) {
          rowHeaderCorner.style.display = 'none';
        }
        if (rowHeaders) {
          rowHeaders.innerHTML = '';
          rowHeaders.style.display = 'none';
        }
        if (columnHeaders) {
          columnHeaders.innerHTML = '';
          columnHeaders.style.display = 'none';
        }
        
        summaryContainer.innerHTML = '';
        gridContainer.innerHTML = '';
        
        // Hide pagination buttons for non-dataframes
        document.getElementById('prev-page-btn').style.display = 'none';
        document.getElementById('next-page-btn').style.display = 'none';
        
        // Determine object type - check for vectors (have values and length but no column_info)
        let objType = objData.type || 'unknown';
        if (objData.values && objData.length !== undefined && !objData.column_info && !objData.nrow) {
          objType = 'vector';
        } else if (objData.column_info && objData.nrow && objData.ncol) {
          // Could be dataframe or matrix - check type field
          if (objData.type === 'matrix') {
            objType = 'matrix';
          } else {
            objType = 'dataframe';
          }
        }
        
        let dimsTextContent = '';
        let summaryHtml = '';
        let gridHtml = '';
        
        if (objType === 'list') {
          dimsTextContent = 'List: ' + objData.length + ' elements';
          summaryHtml = '<div style="padding: 12px; font-size: 13px;">';
          summaryHtml += '<div style="font-weight: 600; margin-bottom: 8px;">List Structure</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Length:</strong> ' + objData.length + '</div>';
          if (objData.names) {
            summaryHtml += '<div style="margin-bottom: 4px;"><strong>Named:</strong> Yes (' + objData.names.length + ' names)</div>';
          } else {
            summaryHtml += '<div style="margin-bottom: 4px;"><strong>Named:</strong> No</div>';
          }
          summaryHtml += '</div>';
          
          // Show list elements
          if (objData.elements && objData.elements.length > 0) {
            gridHtml = '<div style="padding: 12px;">';
            gridHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Elements:</div>';
            objData.elements.forEach((elem, idx) => {
              const name = elem.name || '[' + elem.index + ']';
              gridHtml += '<div style="padding: 8px; border-bottom: 1px solid var(--border-color);">';
              gridHtml += '<div style="font-weight: 500;">' + name + '</div>';
              gridHtml += '<div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">';
              gridHtml += 'Type: ' + elem.type;
              if (elem.length) {
                gridHtml += ', Length: ' + elem.length;
              }
              gridHtml += '</div>';
              if (elem.preview) {
                gridHtml += '<div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px; font-family: monospace;">' + elem.preview + '</div>';
              }
              gridHtml += '</div>';
            });
            if (objData.length > objData.elements.length) {
              gridHtml += '<div style="padding: 8px; color: var(--text-secondary); font-size: 12px;">';
              gridHtml += '... and ' + (objData.length - objData.elements.length) + ' more elements';
              gridHtml += '</div>';
            }
            gridHtml += '</div>';
          }
        } else if (objType === 'vector') {
          const vecType = objData.type || 'unknown';
          dimsTextContent = 'Vector: ' + objData.length + ' elements (' + vecType + ')';
          
          // Summary panel
          if (objData.summary_stats) {
            // Helper function to safely format numbers
            const formatStat = (val) => {
              if (val === null || val === undefined || val === 'NA' || isNaN(val)) {
                return 'N/A';
              }
              return typeof val === 'number' ? val.toFixed(2) : String(val);
            };
            
            summaryHtml = '<div style="padding: 12px; font-size: 13px;">';
            summaryHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Summary Statistics</div>';
            summaryHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px;">';
            summaryHtml += '<div><strong>Min:</strong> ' + formatStat(objData.summary_stats.min) + '</div>';
            summaryHtml += '<div><strong>Max:</strong> ' + formatStat(objData.summary_stats.max) + '</div>';
            summaryHtml += '<div><strong>Mean:</strong> ' + formatStat(objData.summary_stats.mean) + '</div>';
            summaryHtml += '<div><strong>Median:</strong> ' + formatStat(objData.summary_stats.median) + '</div>';
            summaryHtml += '<div><strong>SD:</strong> ' + formatStat(objData.summary_stats.sd) + '</div>';
            summaryHtml += '<div><strong>SE:</strong> ' + formatStat(objData.summary_stats.se) + '</div>';
            summaryHtml += '</div></div>';
          } else if (objData.frequency) {
            summaryHtml = '<div style="padding: 12px; font-size: 13px;">';
            summaryHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Top Values</div>';
            summaryHtml += '<div style="display: flex; flex-direction: column; gap: 4px;">';
            
            // Handle both array and string cases (R may return string for single value)
            const freqValues = Array.isArray(objData.frequency.values) 
              ? objData.frequency.values 
              : [objData.frequency.values];
            const freqCounts = Array.isArray(objData.frequency.counts)
              ? objData.frequency.counts
              : [objData.frequency.counts];
            
            freqValues.forEach((val, idx) => {
              const count = freqCounts[idx] || 0;
              const total = objData.length || 1;
              const pct = total > 0 ? (100 * count / total).toFixed(1) : '0.0';
              const countStr = String(count);
              const pctStr = String(pct);
              summaryHtml += '<div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid var(--border-color);">';
              summaryHtml += '<span>' + escapeHTML(String(val)) + '</span>';
              summaryHtml += '<span style="color: var(--text-secondary); font-size: 12px;">' + countStr + ' (' + pctStr + '%)</span>';
              summaryHtml += '</div>';
            });
            summaryHtml += '</div></div>';
          }
          
          // Grid with values - always show if values exist, even for single element
          // Handle both array and single value cases (R may return list which becomes array or single value)
          let valuesArray = objData.values;
          if (!Array.isArray(valuesArray) && valuesArray !== null && valuesArray !== undefined) {
            // If it's not an array, wrap it in an array
            valuesArray = [valuesArray];
          }
          
          if (valuesArray && Array.isArray(valuesArray) && valuesArray.length > 0) {
            gridHtml = '<div style="padding: 12px; display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px;">';
            valuesArray.forEach((val, idx) => {
              gridHtml += '<div style="padding: 4px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 12px;">' + escapeHTML(String(val)) + '</div>';
            });
            if (objData.length > valuesArray.length) {
              gridHtml += '<div style="padding: 4px; color: var(--text-secondary); font-size: 12px;">... and ' + (objData.length - valuesArray.length) + ' more</div>';
            }
            gridHtml += '</div>';
          } else if (objData.length === 1) {
            // Special case: single element vector - show it even if values array is missing
            gridHtml = '<div style="padding: 12px;"><div style="padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 12px; display: inline-block;">[Single element vector - value not available]</div></div>';
          }
        } else if (objType === 'function') {
          dimsTextContent = 'Function: ' + objData.formals_count + ' parameters';
          summaryHtml = '<div style="padding: 12px; font-size: 13px;">';
          summaryHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Function Information</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Parameters:</strong> ' + objData.formals_count + '</div>';
          if (objData.formals && Array.isArray(objData.formals) && objData.formals.length > 0) {
            summaryHtml += '<div style="margin-bottom: 4px;"><strong>Formals:</strong> ' + objData.formals.join(', ') + '</div>';
          }
          if (objData.environment) {
            summaryHtml += '<div style="margin-bottom: 4px;"><strong>Environment:</strong> ' + objData.environment + '</div>';
          }
          summaryHtml += '</div>';
          
          if (objData.body_full && Array.isArray(objData.body_full) && objData.body_full.length > 0) {
            gridHtml = '<div style="padding: 12px; width: 100%; box-sizing: border-box;"><div style="font-weight: 600; margin-bottom: 8px;">Function Body:</div><pre style="background: var(--bg-secondary); padding: 12px; border-radius: 4px; overflow-x: auto; overflow-y: auto; max-height: 600px; font-size: 12px; font-family: monospace; white-space: pre-wrap; width: 100%; box-sizing: border-box;">';
            gridHtml += objData.body_full.join('\n');
            gridHtml += '</pre></div>';
          } else if (objData.body_preview && Array.isArray(objData.body_preview) && objData.body_preview.length > 0) {
            // Fallback for old format
            gridHtml = '<div style="padding: 12px; width: 100%; box-sizing: border-box;"><div style="font-weight: 600; margin-bottom: 8px;">Function Body:</div><pre style="background: var(--bg-secondary); padding: 12px; border-radius: 4px; overflow-x: auto; overflow-y: auto; max-height: 600px; font-size: 12px; font-family: monospace; white-space: pre-wrap; width: 100%; box-sizing: border-box;">';
            gridHtml += objData.body_preview.join('\n');
            gridHtml += '</pre></div>';
          }
        } else if (objType === 'array') {
          // Handle dim as either array or number (1D arrays might serialize as number)
          let dimArray = objData.dim;
          if (!Array.isArray(dimArray) && typeof dimArray === 'number') {
            dimArray = [dimArray];
          }
          const dimStr = Array.isArray(dimArray) ? dimArray.join(', ') : 'unknown';
          dimsTextContent = 'Array: [' + dimStr + ']';
          summaryHtml = '<div style="padding: 12px; font-size: 13px;">';
          summaryHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Array Information</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Dimensions:</strong> [' + dimStr + ']</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Mode:</strong> ' + (objData.mode || 'unknown') + '</div>';
          if (objData.preview_type === 'sample' && objData.total_dims) {
            const totalDimsStr = Array.isArray(objData.total_dims) ? objData.total_dims.join('  ') : 'unknown';
            summaryHtml += '<div style="margin-bottom: 4px; color: var(--text-secondary); font-size: 11px;"><strong>Total Size:</strong> ' + totalDimsStr + '</div>';
            const previewDimsStr = Array.isArray(objData.preview_dims) ? objData.preview_dims.join('  ') : 'unknown';
            summaryHtml += '<div style="margin-bottom: 4px; color: var(--text-secondary); font-size: 11px;"><strong>Showing:</strong> ' + previewDimsStr + ' (sample)</div>';
          } else if (objData.preview_type === 'flattened' && objData.preview_count) {
            summaryHtml += '<div style="margin-bottom: 4px; color: var(--text-secondary); font-size: 11px;"><strong>Showing:</strong> First ' + objData.preview_count + ' elements (flattened)</div>';
          }
          summaryHtml += '</div>';
          
          // Display array values
          if (objData.values && Array.isArray(objData.values) && objData.values.length > 0) {
            gridHtml = '<div style="padding: 12px;">';
            
            if (objData.preview_type === 'sample' && Array.isArray(objData.preview_dims) && objData.preview_dims.length >= 2) {
              // Display as 2D grid
              // Note: R arrays are stored in column-major order, so we need to transpose
              const rows = objData.preview_dims[0];
              const cols = objData.preview_dims[1];
              gridHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Array Preview:</div>';
              gridHtml += '<div style="display: grid; grid-template-columns: repeat(' + cols + ', minmax(80px, 1fr)); gap: 4px; font-size: 12px; font-family: monospace;">';
              
              // R stores arrays in column-major order: [row1,col1], [row2,col1], ..., [row1,col2], [row2,col2], ...
              // For display, we want row-major: [row1,col1], [row1,col2], ..., [row2,col1], [row2,col2], ...
              // So we need to map: display[row][col] = values[col * rows + row]
              for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                  // Convert from row-major display index to column-major R index
                  const idx = j * rows + i;
                  if (idx < objData.values.length) {
                    const val = objData.values[idx];
                    gridHtml += '<div style="padding: 4px; border: 1px solid var(--border-color); border-radius: 4px; text-align: center; background: var(--bg-secondary);">';
                    gridHtml += escapeHTML(String(val));
                    gridHtml += '</div>';
                  }
                }
              }
              gridHtml += '</div>';
              
              if (objData.total_dims && Array.isArray(objData.total_dims)) {
                const totalRows = objData.total_dims[0];
                const totalCols = objData.total_dims[1];
                if (rows < totalRows || cols < totalCols) {
                  gridHtml += '<div style="margin-top: 8px; padding: 4px; color: var(--text-secondary); font-size: 11px;">';
                  gridHtml += 'Showing ' + rows + '  ' + cols + ' of ' + totalRows + '  ' + totalCols + ' total';
                  gridHtml += '</div>';
                }
              }
            } else {
              // Display as flat list
              gridHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Array Values:</div>';
              gridHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 4px; font-size: 12px; font-family: monospace;">';
              objData.values.forEach((val, idx) => {
                gridHtml += '<div style="padding: 4px; border: 1px solid var(--border-color); border-radius: 4px; text-align: center; background: var(--bg-secondary);">';
                gridHtml += escapeHTML(String(val));
                gridHtml += '</div>';
              });
              gridHtml += '</div>';
              
              if (objData.preview_type === 'flattened' && objData.total_dims) {
                const totalElements = Array.isArray(objData.total_dims) 
                  ? objData.total_dims.reduce((a, b) => a * b, 1)
                  : objData.values.length;
                if (objData.values.length < totalElements) {
                  gridHtml += '<div style="margin-top: 8px; padding: 4px; color: var(--text-secondary); font-size: 11px;">';
                  gridHtml += 'Showing ' + objData.values.length + ' of ' + totalElements + ' total elements';
                  gridHtml += '</div>';
                }
              }
            }
            
            gridHtml += '</div>';
          } else {
            gridHtml = '<div style="padding: 12px; color: var(--text-secondary);">No array data available</div>';
          }
        } else if (objType === 'ts') {
          // Time series display
          const startStr = Array.isArray(objData.start) ? objData.start.join(', ') : String(objData.start || 'unknown');
          const endStr = Array.isArray(objData.end) ? objData.end.join(', ') : String(objData.end || 'unknown');
          dimsTextContent = 'Time Series: ' + objData.length + ' observations';
          
          summaryHtml = '<div style="padding: 12px; font-size: 13px;">';
          summaryHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Time Series Information</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Start:</strong> [' + startStr + ']</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>End:</strong> [' + endStr + ']</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Frequency:</strong> ' + (objData.frequency || 'unknown') + '</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Length:</strong> ' + (objData.length || 0) + '</div>';
          if (objData.deltat) {
            summaryHtml += '<div style="margin-bottom: 4px;"><strong>Delta t:</strong> ' + objData.deltat + '</div>';
          }
          summaryHtml += '</div>';
          
          // Summary stats
          if (objData.summary_stats) {
            const formatStat = (val) => {
              if (val === null || val === undefined || val === 'NA' || isNaN(val)) {
                return 'N/A';
              }
              return typeof val === 'number' ? val.toFixed(2) : String(val);
            };
            
            summaryHtml += '<div style="padding: 12px; font-size: 13px; margin-top: 8px;">';
            summaryHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Summary Statistics</div>';
            summaryHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px;">';
            summaryHtml += '<div><strong>Min:</strong> ' + formatStat(objData.summary_stats.min) + '</div>';
            summaryHtml += '<div><strong>Max:</strong> ' + formatStat(objData.summary_stats.max) + '</div>';
            summaryHtml += '<div><strong>Mean:</strong> ' + formatStat(objData.summary_stats.mean) + '</div>';
            summaryHtml += '<div><strong>Median:</strong> ' + formatStat(objData.summary_stats.median) + '</div>';
            summaryHtml += '<div><strong>SD:</strong> ' + formatStat(objData.summary_stats.sd) + '</div>';
            summaryHtml += '<div><strong>SE:</strong> ' + formatStat(objData.summary_stats.se) + '</div>';
            summaryHtml += '</div></div>';
          }
          
          // Display time series values
          if (objData.values && Array.isArray(objData.values) && objData.values.length > 0) {
            gridHtml = '<div style="padding: 12px;">';
            gridHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Time Series Values:</div>';
            gridHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 4px; font-size: 12px; font-family: monospace;">';
            objData.values.forEach((val, idx) => {
              gridHtml += '<div style="padding: 4px; border: 1px solid var(--border-color); border-radius: 4px; text-align: center; background: var(--bg-secondary);">';
              gridHtml += escapeHTML(String(val));
              gridHtml += '</div>';
            });
            gridHtml += '</div>';
            
            if (objData.preview_type === 'sample' && objData.preview_count && objData.length) {
              gridHtml += '<div style="margin-top: 8px; padding: 4px; color: var(--text-secondary); font-size: 11px;">';
              gridHtml += 'Showing ' + objData.values.length + ' of ' + objData.length + ' total observations';
              gridHtml += '</div>';
            }
            gridHtml += '</div>';
          } else {
            gridHtml = '<div style="padding: 12px; color: var(--text-secondary);">No time series data available</div>';
          }
        } else {
          // Other types
          dimsTextContent = objData.type || 'Object';
          summaryHtml = '<div style="padding: 12px; font-size: 13px;">';
          summaryHtml += '<div style="font-weight: 600; margin-bottom: 8px;">Object Information</div>';
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Type:</strong> ' + objData.type + '</div>';
          const classStr = Array.isArray(objData.class) ? objData.class.join(', ') : String(objData.class || 'unknown');
          summaryHtml += '<div style="margin-bottom: 4px;"><strong>Class:</strong> ' + classStr + '</div>';
          summaryHtml += '</div>';
          
          if (objData.str_preview && Array.isArray(objData.str_preview) && objData.str_preview.length > 0) {
            gridHtml = '<div style="padding: 12px;"><div style="font-weight: 600; margin-bottom: 8px;">Structure Preview:</div><pre style="background: var(--bg-secondary); padding: 12px; border-radius: 4px; overflow-x: auto; font-size: 12px; font-family: monospace;">';
            gridHtml += objData.str_preview.join('\n');
            gridHtml += '</pre></div>';
          }
        }
        
        dimsText.textContent = dimsTextContent;
        summaryContainer.innerHTML = summaryHtml;
        gridContainer.innerHTML = gridHtml;
        
        // For functions, make the grid container take full width
        if (objType === 'function') {
          const gridWrapper = document.querySelector('.explorer-grid-wrapper');
          if (gridWrapper) {
            gridWrapper.style.width = '100%';
            gridWrapper.style.flex = '1';
          }
          if (gridContainer) {
            gridContainer.style.width = '100%';
            gridContainer.style.display = 'block';
          }
        }
      }
      
      // Render summary panel with columns
      function renderExplorerSummary(columnInfo) {
        explorerState.columnInfo = columnInfo;
        const container = document.getElementById('summary-columns-list');
        container.innerHTML = '';
        
        let columns = Object.keys(columnInfo);
        
        // Apply search filter
        const searchText = document.getElementById('summary-search').value.toLowerCase();
        if (searchText) {
          columns = columns.filter(col => col.toLowerCase().includes(searchText));
        }
        
        // Apply sort
        if (explorerState.summarySortOrder !== 'original') {
          columns.sort((a, b) => {
            const infoA = columnInfo[a];
            const infoB = columnInfo[b];
            
            switch(explorerState.summarySortOrder) {
              case 'name-asc':
                return a.localeCompare(b);
              case 'name-desc':
                return b.localeCompare(a);
              case 'type-asc':
                return infoA.type.localeCompare(infoB.type);
              case 'type-desc':
                return infoB.type.localeCompare(infoA.type);
              default:
                return 0;
            }
          });
        }
        
        columns.forEach(colName => {
          const info = columnInfo[colName];
          const item = document.createElement('div');
          item.className = 'summary-column-item';
          item.dataset.columnName = colName;
          
          const header = document.createElement('div');
          header.className = 'summary-column-header';
          
          const nameSpan = document.createElement('span');
          nameSpan.style.fontWeight = '600';
          nameSpan.textContent = colName;
          nameSpan.style.cursor = 'pointer';
          nameSpan.title = 'Double-click to focus column in grid';
          nameSpan.ondblclick = (e) => {
            e.stopPropagation();
            e.preventDefault();
            try {
              focusColumnInGrid(colName);
            } catch (error) {
              console.error('Error focusing column:', error);
            }
          };
          header.appendChild(nameSpan);
          
          const typeSpan = document.createElement('span');
          typeSpan.style.fontSize = '11px';
          typeSpan.style.color = 'var(--text-secondary)';
          typeSpan.style.marginLeft = '8px';
          typeSpan.textContent = info.type;
          header.appendChild(typeSpan);
          
          // Add expand/collapse indicator
          const expandIcon = document.createElement('span');
          expandIcon.className = 'expand-icon';
          expandIcon.style.cssText = 'margin-left: auto; font-size: 12px; color: var(--text-secondary); transition: transform 0.2s; user-select: none;';
          expandIcon.textContent = '';
          expandIcon.title = 'Click to expand details';
          header.appendChild(expandIcon);
          
          item.appendChild(header);
          
          // Missing data indicator
          if (info.missing > 0) {
            const missingDiv = document.createElement('div');
            missingDiv.style.marginTop = '5px';
            missingDiv.style.fontSize = '11px';
            missingDiv.style.color = 'var(--text-secondary)';
            missingDiv.textContent = `${info.missing} missing (${info.missing_pct}%)`;
            
            const missingBar = document.createElement('div');
            missingBar.className = 'missing-data-bar';
            missingBar.style.width = `${info.missing_pct}%`;
            missingDiv.appendChild(missingBar);
            
            item.appendChild(missingDiv);
          }
          
          // Mini sparkline
          const sparklineDiv = document.createElement('div');
          sparklineDiv.className = 'mini-sparkline';
          
          if (info.histogram && info.histogram.counts) {
            sparklineDiv.innerHTML = renderMiniHistogram(info.histogram.counts);
          } else if (info.frequency && info.frequency.counts) {
            sparklineDiv.innerHTML = renderMiniBarChart(info.frequency.counts);
          }
          
          item.appendChild(sparklineDiv);
          
          // Expandable stats (initially hidden)
          const expandedDiv = document.createElement('div');
          expandedDiv.className = 'column-stats-expanded';
          expandedDiv.style.display = 'none';
          
          if (info.summary_stats) {
            // Check if it's numeric (has sd/se) or date (has range_days) or categorical (has most_common)
            if (info.summary_stats.sd !== undefined && info.summary_stats.se !== undefined) {
              // Numeric summary
              // Helper function to safely format numbers
              const formatStat = (val) => {
                if (val === null || val === undefined || val === 'NA' || isNaN(val)) {
                  return 'N/A';
                }
                return typeof val === 'number' ? val.toFixed(2) : String(val);
              };
              
              expandedDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px; margin-top: 8px; font-size: 13px;">
                  <div><strong>Min:</strong> ${formatStat(info.summary_stats.min)}</div>
                  <div><strong>Max:</strong> ${formatStat(info.summary_stats.max)}</div>
                  <div><strong>Mean:</strong> ${formatStat(info.summary_stats.mean)}</div>
                  <div><strong>Median:</strong> ${formatStat(info.summary_stats.median)}</div>
                  <div><strong>SD:</strong> ${formatStat(info.summary_stats.sd)}</div>
                  <div><strong>SE:</strong> ${formatStat(info.summary_stats.se)}</div>
                </div>
              `;
            } else if (info.summary_stats.range_days !== undefined) {
              // Date/POSIXct summary
              let dateHtml = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px; margin-top: 8px; font-size: 13px;">
                  <div><strong>Min:</strong> ${info.summary_stats.min}</div>
                  <div><strong>Max:</strong> ${info.summary_stats.max}</div>
                  <div><strong>Median:</strong> ${info.summary_stats.median}</div>
                  <div><strong>Range:</strong> ${info.summary_stats.range_days.toFixed(1)} days</div>
              `;
              if (info.summary_stats.range_hours !== undefined) {
                dateHtml += `<div><strong>Range:</strong> ${info.summary_stats.range_hours.toFixed(1)} hours</div>`;
              }
              dateHtml += `</div>`;
              expandedDiv.innerHTML = dateHtml;
            } else if (info.summary_stats.top_values !== undefined) {
              // Categorical summary (factor/character/logical) - show top values
              const isLogical = info.type === 'logical';
              const title = isLogical ? 'Values:' : 'Top Values:';
              
              let catHtml = `
                <div style="margin-top: 8px; font-size: 13px;">
                  <div style="margin-bottom: 8px; font-weight: 600; color: var(--text-primary);">${title}</div>
                  <div style="display: flex; flex-direction: column; gap: 4px;">
              `;
              
              const topValues = info.summary_stats.top_values;
              const topCounts = info.summary_stats.top_counts;
              const topPcts = info.summary_stats.top_percentages;
              
              // Helper function to escape HTML content
              const escapeHTML = (str) => {
                if (!str) return '';
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
              };
              
              for (let i = 0; i < topValues.length; i++) {
                catHtml += `
                  <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid var(--border-color);">
                    <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: ${isLogical ? '500' : '400'};">${escapeHTML(String(topValues[i]))}</span>
                    <span style="margin-left: 12px; color: var(--text-secondary); font-size: 12px;">${topCounts[i]} (${topPcts[i]}%)</span>
                  </div>
                `;
              }
              
              catHtml += `</div>`;
              
              // For logical columns, show NA info if present
              if (isLogical && info.summary_stats.na_count !== undefined && info.summary_stats.na_count > 0) {
                catHtml += `
                  <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--border-color);">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0;">
                      <span style="font-weight: 500;">NA</span>
                      <span style="margin-left: 12px; color: var(--text-secondary); font-size: 12px;">${info.summary_stats.na_count} (${info.summary_stats.na_percentage}%)</span>
                    </div>
                  </div>
                `;
              }
              
              // Add total categories info (for non-logical)
              if (!isLogical && info.summary_stats.total_categories !== undefined) {
                catHtml += `
                  <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--text-secondary);">
                    <strong>Total Categories:</strong> ${info.summary_stats.total_categories}
                  </div>
                `;
              }
              
              // For character columns, add string length stats
              if (info.summary_stats.avg_length !== undefined) {
                catHtml += `
                  <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--border-color);">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px; font-size: 13px;">
                      <div><strong>Avg Length:</strong> ${info.summary_stats.avg_length}</div>
                      <div><strong>Min Length:</strong> ${info.summary_stats.min_length}</div>
                      <div><strong>Max Length:</strong> ${info.summary_stats.max_length}</div>
                      <div><strong>Median Length:</strong> ${info.summary_stats.median_length}</div>
                    </div>
                  </div>
                `;
              }
              
              catHtml += `</div>`;
              expandedDiv.innerHTML = catHtml;
            }
          } else if (info.frequency) {
            expandedDiv.innerHTML = `
              <div><strong>Total Categories:</strong> ${info.frequency.total_categories}</div>
              <div><strong>Unique Values:</strong> ${info.unique_values}</div>
            `;
          }
          
          item.appendChild(expandedDiv);
          
          // Toggle expand on click (but not on column name double-click)
          item.onclick = (e) => {
            if (e.target !== nameSpan) {
              const isExpanded = expandedDiv.style.display !== 'none';
              expandedDiv.style.display = isExpanded ? 'none' : 'block';
              item.classList.toggle('expanded', !isExpanded);
              
              // Rotate expand icon
              if (expandIcon) {
                expandIcon.style.transform = isExpanded ? 'rotate(0deg)' : 'rotate(90deg)';
                expandIcon.textContent = isExpanded ? '' : '';
              }
            }
          };
          
          container.appendChild(item);
        });
      }
      
      // Render mini histogram
      function renderMiniHistogram(counts) {
        // Ensure counts is an array
        if (!counts || !Array.isArray(counts)) {
          if (typeof counts === 'object' && counts !== null) {
            // Convert object to array of values
            counts = Object.values(counts);
          } else {
            return '';
          }
        }
        
        if (counts.length === 0) return '';
        
        const maxCount = Math.max(...counts);
        if (maxCount === 0) return '';
        
        return counts.map(count => {
          const height = (count / maxCount) * 100;
          return `<div class="sparkline-bar" style="height: ${height}%"></div>`;
        }).join('');
      }
      
      // Render mini bar chart
      function renderMiniBarChart(counts) {
        // Ensure counts is an array
        if (!counts || !Array.isArray(counts)) {
          if (typeof counts === 'object' && counts !== null) {
            // Convert object to array of values
            counts = Object.values(counts);
          } else {
            return '';
          }
        }
        
        if (counts.length === 0) return '';
        
        const maxCount = Math.max(...counts);
        if (maxCount === 0) return '';
        
        return counts.map(count => {
          const height = (count / maxCount) * 100;
          return `<div class="sparkline-bar" style="height: ${height}%"></div>`;
        }).join('');
      }
      
      // Filter summary columns
      function filterSummaryColumns() {
        renderExplorerSummary(explorerState.columnInfo);
      }
      
      // Sort summary columns
      function sortSummaryColumns() {
        const select = document.getElementById('summary-sort');
        explorerState.summarySortOrder = select.value;
        renderExplorerSummary(explorerState.columnInfo);
      }
      
      // Toggle summary panel
      function toggleSummaryPanel() {
        const panel = document.getElementById('explorer-summary-panel');
        explorerState.summaryCollapsed = !explorerState.summaryCollapsed;
        panel.classList.toggle('collapsed', explorerState.summaryCollapsed);
        const btn = document.querySelector('.collapse-btn');
        btn.textContent = explorerState.summaryCollapsed ? '' : '';
      }
      
      // Focus column in grid
      function focusColumnInGrid(columnName) {
        const headers = document.querySelectorAll('.grid-column-header');
        for (let header of headers) {
          const headerText = header.textContent.trim().replace(/\s*.*|\s*.*|\s*\d+.*/g, '').trim();
          if (headerText === columnName || header.dataset.column === columnName) {
            header.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
            // Highlight briefly
            header.style.backgroundColor = 'var(--text-primary)';
            header.style.color = 'var(--bg-primary)';
            setTimeout(() => {
              header.style.backgroundColor = '';
              header.style.color = '';
            }, 1000);
            return;
          }
        }
      }
      
      // Render data grid
      function renderExplorerGrid(chunkData, columns, pageInfo) {
        const headersContainer = document.getElementById('grid-column-headers');
        const rowsContainer = document.getElementById('grid-row-headers');
        const cellsContainer = document.getElementById('grid-data-cells');
        
        headersContainer.innerHTML = '';
        rowsContainer.innerHTML = '';
        cellsContainer.innerHTML = '';
        
        // Set solid backgrounds for row header corner
        const isDark = document.body.classList.contains('dark-theme') || 
                       window.matchMedia('(prefers-color-scheme: dark)').matches;
        const cornerBg = isDark ? '#2d2d2d' : '#f0f0f0';
        const headerBg = isDark ? '#2d2d2d' : '#f0f0f0';
        const rowHeaderCorner = document.getElementById('row-header-corner');
        if (rowHeaderCorner) {
          rowHeaderCorner.style.backgroundColor = cornerBg;
        }
        
        // Set grid template columns
        const columnWidths = columns.map(col => explorerState.columnWidths[col] || 120);
        const gridTemplateColumns = columnWidths.map(w => `${w}px`).join(' ');
        cellsContainer.style.gridTemplateColumns = gridTemplateColumns;
        headersContainer.style.gridTemplateColumns = gridTemplateColumns;
        
        // Ensure both containers use the same grid setup
        headersContainer.style.display = 'grid';
        cellsContainer.style.display = 'grid';
        
          // Render column headers
          columns.forEach((col, colIndex) => {
          const header = document.createElement('div');
          header.className = 'grid-column-header';
          header.style.backgroundColor = headerBg;
          header.dataset.column = col;
          // Don't set width explicitly - let grid handle it
          
          // Create text node for column name
          const colNameSpan = document.createElement('span');
          colNameSpan.textContent = col;
          header.appendChild(colNameSpan);
          
          if (explorerState.pinnedCols.includes(col)) {
            header.classList.add('pinned');
          }
          
          // Add sort indicator
          const sort = explorerState.sorts.find(s => s.column === col);
          if (sort) {
            header.classList.add(sort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
            if (explorerState.sorts.length > 1) {
              const sortOrder = explorerState.sorts.findIndex(s => s.column === col) + 1;
              const orderSpan = document.createElement('span');
              orderSpan.textContent = ` ${sortOrder}`;
              orderSpan.style.marginLeft = '4px';
              header.appendChild(orderSpan);
            }
          }
          
          // Context menu (right-click)
          header.oncontextmenu = (e) => {
            e.preventDefault();
            e.stopPropagation();
            showColumnContextMenu(e, col);
            return false;
          };
          
          // Click to sort (left-click only)
          header.onclick = (e) => {
            // Only handle left-click (button 0 or undefined)
            if (e.button !== undefined && e.button !== 0) {
              return;
            }
            e.preventDefault();
            e.stopPropagation();
            console.log(' Column header clicked:', col, 'button:', e.button);
            toggleColumnSort(col);
            return false;
          };
          
          headersContainer.appendChild(header);
        });
        
        // Render rows
        const numRows = chunkData[columns[0]] ? chunkData[columns[0]].length : 0;
        for (let i = 0; i < numRows; i++) {
          const rowIndex = pageInfo.start_row + i - 1;
          
          // Row header
          const rowHeader = document.createElement('div');
          rowHeader.className = 'grid-row-header';
          rowHeader.style.backgroundColor = headerBg;
          rowHeader.textContent = rowIndex + 1; // 1-based indexing for R
          rowHeader.dataset.row = rowIndex;
          
          if (explorerState.pinnedRows.includes(rowIndex)) {
            rowHeader.classList.add('pinned');
          }
          
          rowHeader.oncontextmenu = (e) => {
            e.preventDefault();
            showRowContextMenu(e, rowIndex);
          };
          
          rowsContainer.appendChild(rowHeader);
          
          // Data cells
          columns.forEach((col, colIndex) => {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.dataset.row = rowIndex;
            cell.dataset.col = col;
            const value = chunkData[col] ? chunkData[col][i] : '';
            cell.textContent = value || '';
            cell.title = value; // Tooltip for full value
            
            cell.onclick = () => {
              selectCell(rowIndex, col);
            };
            
            cell.oncontextmenu = (e) => {
              e.preventDefault();
              showCellContextMenu(e, rowIndex, col);
            };
            
            cellsContainer.appendChild(cell);
          });
        }
        
        // Update status
        const statusText = `Showing rows ${pageInfo.start_row}-${pageInfo.end_row} of ${pageInfo.total_rows}${pageInfo.filtered_rows < pageInfo.total_rows ? ` (${pageInfo.filtered_rows} after filters)` : ''}`;
        document.getElementById('explorer-status-text').textContent = statusText;
        
        // Update pagination buttons
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        
        if (prevBtn) {
          prevBtn.disabled = (pageInfo.page <= 1);
        }
        if (nextBtn) {
          nextBtn.disabled = (pageInfo.page >= pageInfo.total_pages);
        }
      }
      
      // Load grid page
      function loadExplorerPage(page, pageSize = null) {
        if (!explorerState.currentDataframe) return;
        
        explorerState.page = page;
        const size = pageSize || explorerState.pageSize;
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: "get_dataframe_chunk_filtered",
            dataframe: explorerState.currentDataframe,
            page: page,
            page_size: size,
            filters: explorerState.filters,
            sorts: explorerState.sorts,
            pinned_cols: explorerState.pinnedCols
          }));
        }
      }
      
      // Navigate to next page
      function explorerNextPage() {
        if (!explorerState.currentDataframe) return;
        const currentPage = explorerState.page || 1;
        loadExplorerPage(currentPage + 1);
        // Remove focus from button after click to prevent color change
        const nextBtn = document.getElementById('next-page-btn');
        if (nextBtn) nextBtn.blur();
      }
      
      // Navigate to previous page
      function explorerPreviousPage() {
        if (!explorerState.currentDataframe) return;
        const currentPage = explorerState.page || 1;
        if (currentPage > 1) {
          loadExplorerPage(currentPage - 1);
        }
        // Remove focus from button after click to prevent color change
        const prevBtn = document.getElementById('prev-page-btn');
        if (prevBtn) prevBtn.blur();
      }
      
      // Cell selection
      function selectCell(row, col) {
        const cellId = `${row}_${col}`;
        explorerState.selectedCells.clear();
        explorerState.selectedCells.add(cellId);
        
        // Update UI
        document.querySelectorAll('.grid-cell').forEach(cell => {
          cell.classList.remove('selected', 'range-selected');
          if (cell.dataset.row == row && cell.dataset.col == col) {
            cell.classList.add('selected');
          }
        });
      }
      
      // Column sort toggle
      function toggleColumnSort(column) {
        console.log(' toggleColumnSort called for:', column);
        console.log(' Current sorts:', explorerState.sorts);
        
        const existingSort = explorerState.sorts.findIndex(s => s.column === column);
        
        if (existingSort >= 0) {
          const sort = explorerState.sorts[existingSort];
          console.log(' Found existing sort:', sort);
          if (sort.direction === 'asc') {
            sort.direction = 'desc';
            console.log(' Changed to desc');
          } else {
            explorerState.sorts.splice(existingSort, 1);
            console.log(' Removed sort');
          }
        } else {
          explorerState.sorts.push({
            column: column,
            direction: 'asc',
            order: explorerState.sorts.length + 1
          });
          console.log(' Added new sort (asc)');
        }
        
        console.log(' Updated sorts:', explorerState.sorts);
        loadExplorerPage(explorerState.page);
      }
      
      // Add filter - opens modal
      function explorerAddFilter(columnName = null) {
        if (!explorerState.currentDataframe) {
          alert('Please select a dataframe first');
          return;
        }
        
        // Wait for columnInfo if not loaded yet
        if (!explorerState.columnInfo) {
          alert('Column information is still loading. Please wait a moment and try again.');
          return;
        }
        
        // Populate column select
        const columnSelect = document.getElementById('filter-column-select');
        columnSelect.innerHTML = '<option value="">Select a column...</option>';
        const columns = Object.keys(explorerState.columnInfo);
        columns.forEach(col => {
          const option = document.createElement('option');
          option.value = col;
          option.textContent = col;
          if (columnName === col) {
            option.selected = true;
          }
          columnSelect.appendChild(option);
        });
        
        // Reset filter type and value
        document.getElementById('filter-type-select').innerHTML = '<option value="">Select filter type...</option>';
        document.getElementById('filter-type-select').value = '';
        document.getElementById('filter-value-input').value = '';
        document.getElementById('filter-value-input-2').value = '';
        document.getElementById('filter-value-container').style.display = 'none';
        document.getElementById('filter-between-container').style.display = 'none';
        
        // Show modal
        document.getElementById('filter-modal').style.display = 'flex';
        
        // Update filter types when column changes
        columnSelect.onchange = updateFilterTypes;
        if (columnName) {
          updateFilterTypes();
        }
      }
      
      // Update filter types based on selected column
      function updateFilterTypes() {
        const columnSelect = document.getElementById('filter-column-select');
        const typeSelect = document.getElementById('filter-type-select');
        const valueContainer = document.getElementById('filter-value-container');
        const betweenContainer = document.getElementById('filter-between-container');
        
        const column = columnSelect.value;
        if (!column || !explorerState.columnInfo) {
          typeSelect.innerHTML = '<option value="">Select filter type...</option>';
          valueContainer.style.display = 'none';
          return;
        }
        
        const colInfo = explorerState.columnInfo[column];
        const colType = colInfo.type;
        
        let filterTypeOptions = [];
        if (colType === 'numeric') {
          filterTypeOptions = [
            {value: 'equals', label: 'Equals'},
            {value: 'not_equals', label: 'Not Equals'},
            {value: 'greater_than', label: 'Greater Than'},
            {value: 'less_than', label: 'Less Than'},
            {value: 'between', label: 'Between'},
            {value: 'is_null', label: 'Is Null'},
            {value: 'is_not_null', label: 'Is Not Null'}
          ];
        } else if (colType === 'character' || colType === 'factor') {
          filterTypeOptions = [
            {value: 'equals', label: 'Equals'},
            {value: 'not_equals', label: 'Not Equals'},
            {value: 'contains', label: 'Contains'},
            {value: 'starts_with', label: 'Starts With'},
            {value: 'ends_with', label: 'Ends With'},
            {value: 'is_empty', label: 'Is Empty'},
            {value: 'is_not_empty', label: 'Is Not Empty'},
            {value: 'is_null', label: 'Is Null'},
            {value: 'is_not_null', label: 'Is Not Null'}
          ];
        } else {
          filterTypeOptions = [
            {value: 'equals', label: 'Equals'},
            {value: 'not_equals', label: 'Not Equals'},
            {value: 'is_null', label: 'Is Null'},
            {value: 'is_not_null', label: 'Is Not Null'}
          ];
        }
        
        typeSelect.innerHTML = '<option value="">Select filter type...</option>';
        filterTypeOptions.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt.value;
          option.textContent = opt.label;
          typeSelect.appendChild(option);
        });
        
        // Update value input visibility
        typeSelect.onchange = function() {
          const filterType = typeSelect.value;
          const needsValue = filterType && 
            filterType !== 'is_null' && 
            filterType !== 'is_not_null' && 
            filterType !== 'is_empty' && 
            filterType !== 'is_not_empty';
          
          if (filterType === 'between') {
            valueContainer.style.display = 'block';
            betweenContainer.style.display = 'block';
          } else if (needsValue) {
            valueContainer.style.display = 'block';
            betweenContainer.style.display = 'none';
          } else {
            valueContainer.style.display = 'none';
            betweenContainer.style.display = 'none';
          }
        };
      }
      
      // Apply filter from modal
      function applyFilter() {
        const column = document.getElementById('filter-column-select').value;
        const filterType = document.getElementById('filter-type-select').value;
        
        if (!column || !filterType) {
          alert('Please select both a column and filter type');
          return;
        }
        
        const colInfo = explorerState.columnInfo[column];
        const colType = colInfo.type;
        
        let filterValue = null;
        const needsValue = filterType !== 'is_null' && 
          filterType !== 'is_not_null' && 
          filterType !== 'is_empty' && 
          filterType !== 'is_not_empty';
        
        if (needsValue) {
          if (filterType === 'between') {
            const val1 = document.getElementById('filter-value-input').value;
            const val2 = document.getElementById('filter-value-input-2').value;
            if (!val1 || !val2) {
              alert('Please enter both minimum and maximum values');
              return;
            }
            filterValue = [parseFloat(val1) || val1, parseFloat(val2) || val2];
          } else {
            const val = document.getElementById('filter-value-input').value;
            if (!val) {
              alert('Please enter a filter value');
              return;
            }
            filterValue = val;
            // Try to parse as number for numeric columns
            if (colType === 'numeric') {
              const numValue = parseFloat(filterValue);
              if (!isNaN(numValue)) filterValue = numValue;
            }
          }
        }
        
        explorerState.filters.push({
          column: column,
          type: filterType,
          value: filterValue
        });
        
        // Show filter bar if hidden
        const filterBar = document.getElementById('explorer-filter-bar');
        if (filterBar.style.display === 'none') {
          filterBar.style.display = 'block';
          document.getElementById('toggle-filters-btn').textContent = ' Hide Filters';
        }
        
        closeFilterModal();
        renderFilters();
        loadExplorerPage(1);
      }
      
      // Close filter modal
      function closeFilterModal() {
        document.getElementById('filter-modal').style.display = 'none';
      }
      
      // Open guide modal
      function openGuideModal() {
        console.log(' Opening guide modal');
        const modal = document.getElementById('guide-modal');
        if (modal) {
          modal.style.display = 'flex';
          console.log(' Guide modal display set to flex');
        } else {
          console.error(' Guide modal not found!');
        }
      }
      
      // Close guide modal
      function closeGuideModal() {
        console.log(' Closing guide modal');
        const modal = document.getElementById('guide-modal');
        if (modal) {
          modal.style.display = 'none';
        }
      }
      
      // Close guide modal when clicking outside
      document.addEventListener('click', function(e) {
        const guideModal = document.getElementById('guide-modal');
        const modalContent = guideModal ? guideModal.querySelector('.modal-content') : null;
        // Don't close if clicking the button that opens the modal
        const openButton = e.target.closest('button[onclick*="openGuideModal"]');
        if (openButton) {
          return; // Let the button's onclick handle opening
        }
        // Close if clicking outside the modal content
        if (guideModal && guideModal.style.display === 'flex' && modalContent && !modalContent.contains(e.target) && !e.target.closest('.modal-content')) {
          closeGuideModal();
        }
      });
      
      // Render filters
      // Helper function to escape HTML content for filters
      const escapeHTMLForFilter = (str) => {
        if (!str) return '';
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      };
      
      function renderFilters() {
        const container = document.getElementById('explorer-filters-container');
        const filterBar = document.getElementById('explorer-filter-bar');
        container.innerHTML = '';
        
        if (explorerState.filters.length === 0) {
          filterBar.style.display = 'none';
          document.getElementById('toggle-filters-btn').textContent = ' Show Filters';
          return;
        }
        
        // Show filter bar if there are filters
        filterBar.style.display = 'block';
        document.getElementById('toggle-filters-btn').textContent = ' Hide Filters';
        
        explorerState.filters.forEach((filter, index) => {
          const filterDiv = document.createElement('div');
          filterDiv.className = 'filter-item';
          
          // Format filter value display
          let valueDisplay = '';
          if (filter.value !== null && filter.value !== undefined) {
            if (Array.isArray(filter.value)) {
              valueDisplay = `[${filter.value[0]}, ${filter.value[1]}]`;
            } else {
              valueDisplay = String(filter.value);
            }
          }
          
          filterDiv.innerHTML = `
            <span style="font-weight: 500;">${escapeHTMLForFilter(filter.column)}</span>
            <span style="color: var(--text-secondary); margin: 0 4px;">${escapeHTMLForFilter(filter.type)}</span>
            ${valueDisplay ? '<span style="color: var(--accent-color);">' + escapeHTMLForFilter(valueDisplay) + '</span>' : ''}
            <button onclick="removeFilter(${index})" style="background: none; border: none; cursor: pointer; color: var(--text-secondary); font-size: 18px; padding: 0 8px; margin-left: auto;"></button>
          `;
          container.appendChild(filterDiv);
        });
      }
      
      // Remove filter
      function removeFilter(index) {
        explorerState.filters.splice(index, 1);
        renderFilters();
        loadExplorerPage(1);
      }
      
      // Toggle filters visibility
      function explorerToggleFilters() {
        const bar = document.getElementById('explorer-filter-bar');
        const btn = document.getElementById('toggle-filters-btn');
        const isVisible = bar.style.display !== 'none';
        bar.style.display = isVisible ? 'none' : 'block';
        btn.textContent = isVisible ? ' Show Filters' : ' Hide Filters';
      }
      
      // Clear filters
      function explorerClearFilters() {
        explorerState.filters = [];
        renderFilters();
        loadExplorerPage(1);
      }
      
      // Clear sorting
      function explorerClearSorting() {
        explorerState.sorts = [];
        loadExplorerPage(explorerState.page);
      }
      
      // Convert to code
      function explorerConvertToCode() {
        if (!explorerState.currentDataframe) {
          alert('Please select a dataframe first');
          return;
        }
        
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            action: "convert_explorer_to_code",
            dataframe: explorerState.currentDataframe,
            filters: explorerState.filters,
            sorts: explorerState.sorts
          }));
        }
      }
      
      // Refresh explorer
      function explorerRefresh() {
        if (explorerState.currentDataframe) {
          loadExplorerDataframe();
        } else {
          loadExplorerDataframes();
        }
      }
      
      // Helper function to escape JavaScript string values for use in onclick handlers
      const escapeJSString = (str) => {
        if (!str) return '';
        return String(str)
          .replace(/\\/g, '\\\\')  // Escape backslashes first
          .replace(/'/g, "\\'")     // Escape single quotes
          .replace(/"/g, '\\"')     // Escape double quotes
          .replace(/\n/g, '\\n')    // Escape newlines
          .replace(/\r/g, '\\r')    // Escape carriage returns
          .replace(/\t/g, '\\t');   // Escape tabs
      };
      
      // Context menus (simplified versions)
      function showColumnContextMenu(event, column) {
        // Create simple context menu
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.style.left = event.pageX + 'px';
        menu.style.top = event.pageY + 'px';
        
        const escapedColumn = escapeJSString(column);
        menu.innerHTML = `
          <div class="context-menu-item" onclick="copyColumn('${escapedColumn}'); document.body.removeChild(this.parentElement);">Copy Column</div>
          <div class="context-menu-item" onclick="pinColumn('${escapedColumn}'); document.body.removeChild(this.parentElement);">Pin Column</div>
          <div class="context-menu-item" onclick="toggleColumnSort('${escapedColumn}'); document.body.removeChild(this.parentElement);">Sort Ascending</div>
          <div class="context-menu-item" onclick="addColumnFilter('${escapedColumn}'); document.body.removeChild(this.parentElement);">Add Filter</div>
        `;
        
        document.body.appendChild(menu);
        
        setTimeout(() => {
          document.addEventListener('click', function removeMenu() {
            if (document.body.contains(menu)) {
              document.body.removeChild(menu);
            }
            document.removeEventListener('click', removeMenu);
          });
        }, 0);
      }
      
      function showRowContextMenu(event, row) {
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.style.left = event.pageX + 'px';
        menu.style.top = event.pageY + 'px';
        
        menu.innerHTML = `
          <div class="context-menu-item" onclick="copyRow(${row}); document.body.removeChild(this.parentElement);">Copy Row</div>
          <div class="context-menu-item" onclick="pinRow(${row}); document.body.removeChild(this.parentElement);">Pin Row</div>
        `;
        
        document.body.appendChild(menu);
        
        setTimeout(() => {
          document.addEventListener('click', function removeMenu() {
            if (document.body.contains(menu)) {
              document.body.removeChild(menu);
            }
            document.removeEventListener('click', removeMenu);
          });
        }, 0);
      }
      
      function showCellContextMenu(event, row, col) {
        const menu = document.createElement('div');
        menu.className = 'context-menu';
        menu.style.left = event.pageX + 'px';
        menu.style.top = event.pageY + 'px';
        
        const escapedCol = escapeJSString(col);
        menu.innerHTML = `
          <div class="context-menu-item" onclick="copyCell(${row}, '${escapedCol}'); document.body.removeChild(this.parentElement);">Copy</div>
          <div class="context-menu-item" onclick="selectColumn('${escapedCol}'); document.body.removeChild(this.parentElement);">Select Column</div>
          <div class="context-menu-item" onclick="selectRow(${row}); document.body.removeChild(this.parentElement);">Select Row</div>
        `;
        
        document.body.appendChild(menu);
        
        setTimeout(() => {
          document.addEventListener('click', function removeMenu() {
            if (document.body.contains(menu)) {
              document.body.removeChild(menu);
            }
            document.removeEventListener('click', removeMenu);
          });
        }, 0);
      }
      
      // Helper functions for context menus
      function copyColumn(column) {
        // Implementation for copying column
        alert('Copy column: ' + column);
      }
      
      function pinColumn(column) {
        if (!explorerState.pinnedCols.includes(column)) {
          explorerState.pinnedCols.push(column);
          loadExplorerPage(explorerState.page);
        }
      }
      
      function addColumnFilter(column) {
        explorerAddFilter(column);
        // Close context menu if open
        document.querySelectorAll('.context-menu').forEach(menu => {
          if (document.body.contains(menu)) {
            document.body.removeChild(menu);
          }
        });
      }
      
      function copyRow(row) {
        alert('Copy row: ' + row);
      }
      
      function pinRow(row) {
        if (!explorerState.pinnedRows.includes(row)) {
          explorerState.pinnedRows.push(row);
          loadExplorerPage(explorerState.page);
        }
      }
      
      function copyCell(row, col) {
        const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
        if (cell) {
          navigator.clipboard.writeText(cell.textContent);
        }
      }
      
      function selectColumn(col) {
        // Select all cells in column
        document.querySelectorAll(`.grid-cell[data-col="${col}"]`).forEach(cell => {
          cell.classList.add('selected');
        });
      }
      
      function selectRow(row) {
        // Select all cells in row
        document.querySelectorAll(`.grid-cell[data-row="${row}"]`).forEach(cell => {
          cell.classList.add('selected');
        });
      }
      
      // Handle WebSocket messages for explorer - integrate into main handler
      // This will be called from the main WebSocket message handler
      
    </script>
</body>
</html> 